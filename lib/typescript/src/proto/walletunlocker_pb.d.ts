import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import type { ChanBackupSnapshot } from "./lightning_pb";
import type { Message } from "@bufbuild/protobuf";
/**
 * Describes the file walletunlocker.proto.
 */
export declare const file_walletunlocker: GenFile;
/**
 * @generated from message lnrpc.GenSeedRequest
 */
export type GenSeedRequest = Message<"lnrpc.GenSeedRequest"> & {
    /**
     *
     * aezeed_passphrase is an optional user provided passphrase that will be used
     * to encrypt the generated aezeed cipher seed. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from field: bytes aezeed_passphrase = 1;
     */
    aezeedPassphrase: Uint8Array;
    /**
     *
     * seed_entropy is an optional 16-bytes generated via CSPRNG. If not
     * specified, then a fresh set of randomness will be used to create the seed.
     * When using REST, this field must be encoded as base64.
     *
     * @generated from field: bytes seed_entropy = 2;
     */
    seedEntropy: Uint8Array;
};
/**
 * Describes the message lnrpc.GenSeedRequest.
 * Use `create(GenSeedRequestSchema)` to create a new message.
 */
export declare const GenSeedRequestSchema: GenMessage<GenSeedRequest>;
/**
 * @generated from message lnrpc.GenSeedResponse
 */
export type GenSeedResponse = Message<"lnrpc.GenSeedResponse"> & {
    /**
     *
     * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     * cipher seed obtained by the user. This field is optional, as if not
     * provided, then the daemon will generate a new cipher seed for the user.
     * Otherwise, then the daemon will attempt to recover the wallet state linked
     * to this cipher seed.
     *
     * @generated from field: repeated string cipher_seed_mnemonic = 1;
     */
    cipherSeedMnemonic: string[];
    /**
     *
     * enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
     * cipher text before run through our mnemonic encoding scheme.
     *
     * @generated from field: bytes enciphered_seed = 2;
     */
    encipheredSeed: Uint8Array;
};
/**
 * Describes the message lnrpc.GenSeedResponse.
 * Use `create(GenSeedResponseSchema)` to create a new message.
 */
export declare const GenSeedResponseSchema: GenMessage<GenSeedResponse>;
/**
 * @generated from message lnrpc.InitWalletRequest
 */
export type InitWalletRequest = Message<"lnrpc.InitWalletRequest"> & {
    /**
     *
     * wallet_password is the passphrase that should be used to encrypt the
     * wallet. This MUST be at least 8 chars in length. After creation, this
     * password is required to unlock the daemon. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from field: bytes wallet_password = 1;
     */
    walletPassword: Uint8Array;
    /**
     *
     * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
     * cipher seed obtained by the user. This may have been generated by the
     * GenSeed method, or be an existing seed.
     *
     * @generated from field: repeated string cipher_seed_mnemonic = 2;
     */
    cipherSeedMnemonic: string[];
    /**
     *
     * aezeed_passphrase is an optional user provided passphrase that will be used
     * to encrypt the generated aezeed cipher seed. When using REST, this field
     * must be encoded as base64.
     *
     * @generated from field: bytes aezeed_passphrase = 3;
     */
    aezeedPassphrase: Uint8Array;
    /**
     *
     * recovery_window is an optional argument specifying the address lookahead
     * when restoring a wallet seed. The recovery window applies to each
     * individual branch of the BIP44 derivation paths. Supplying a recovery
     * window of zero indicates that no addresses should be recovered, such after
     * the first initialization of the wallet.
     *
     * @generated from field: int32 recovery_window = 4;
     */
    recoveryWindow: number;
    /**
     *
     * channel_backups is an optional argument that allows clients to recover the
     * settled funds within a set of channels. This should be populated if the
     * user was unable to close out all channels and sweep funds before partial or
     * total data loss occurred. If specified, then after on-chain recovery of
     * funds, lnd begin to carry out the data loss recovery protocol in order to
     * recover the funds in each channel from a remote force closed transaction.
     *
     * @generated from field: lnrpc.ChanBackupSnapshot channel_backups = 5;
     */
    channelBackups?: ChanBackupSnapshot;
    /**
     *
     * stateless_init is an optional argument instructing the daemon NOT to create
     * any *.macaroon files in its filesystem. If this parameter is set, then the
     * admin macaroon returned in the response MUST be stored by the caller of the
     * RPC as otherwise all access to the daemon will be lost!
     *
     * @generated from field: bool stateless_init = 6;
     */
    statelessInit: boolean;
    /**
     *
     * extended_master_key is an alternative to specifying cipher_seed_mnemonic and
     * aezeed_passphrase. Instead of deriving the master root key from the entropy
     * of an aezeed cipher seed, the given extended master root key is used
     * directly as the wallet's master key. This allows users to import/use a
     * master key from another wallet. When doing so, lnd still uses its default
     * SegWit only (BIP49/84) derivation paths and funds from custom/non-default
     * derivation paths will not automatically appear in the on-chain wallet. Using
     * an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
     * birthday is not known as that is an information that's only encoded in the
     * aezeed, not the xprv. Therefore a birthday needs to be specified in
     * extended_master_key_birthday_timestamp or a "safe" default value will be
     * used.
     *
     * @generated from field: string extended_master_key = 7;
     */
    extendedMasterKey: string;
    /**
     *
     * extended_master_key_birthday_timestamp is the optional unix timestamp in
     * seconds to use as the wallet's birthday when using an extended master key
     * to restore the wallet. lnd will only start scanning for funds in blocks that
     * are after the birthday which can speed up the process significantly. If the
     * birthday is not known, this should be left at its default value of 0 in
     * which case lnd will start scanning from the first SegWit block (481824 on
     * mainnet).
     *
     * @generated from field: uint64 extended_master_key_birthday_timestamp = 8;
     */
    extendedMasterKeyBirthdayTimestamp: bigint;
    /**
     *
     * watch_only is the third option of initializing a wallet: by importing
     * account xpubs only and therefore creating a watch-only wallet that does not
     * contain any private keys. That means the wallet won't be able to sign for
     * any of the keys and _needs_ to be run with a remote signer that has the
     * corresponding private keys and can serve signing RPC requests.
     *
     * @generated from field: lnrpc.WatchOnly watch_only = 9;
     */
    watchOnly?: WatchOnly;
    /**
     *
     * macaroon_root_key is an optional 32 byte macaroon root key that can be
     * provided when initializing the wallet rather than letting lnd generate one
     * on its own.
     *
     * @generated from field: bytes macaroon_root_key = 10;
     */
    macaroonRootKey: Uint8Array;
};
/**
 * Describes the message lnrpc.InitWalletRequest.
 * Use `create(InitWalletRequestSchema)` to create a new message.
 */
export declare const InitWalletRequestSchema: GenMessage<InitWalletRequest>;
/**
 * @generated from message lnrpc.InitWalletResponse
 */
export type InitWalletResponse = Message<"lnrpc.InitWalletResponse"> & {
    /**
     *
     * The binary serialized admin macaroon that can be used to access the daemon
     * after creating the wallet. If the stateless_init parameter was set to true,
     * this is the ONLY copy of the macaroon and MUST be stored safely by the
     * caller. Otherwise a copy of this macaroon is also persisted on disk by the
     * daemon, together with other macaroon files.
     *
     * @generated from field: bytes admin_macaroon = 1;
     */
    adminMacaroon: Uint8Array;
};
/**
 * Describes the message lnrpc.InitWalletResponse.
 * Use `create(InitWalletResponseSchema)` to create a new message.
 */
export declare const InitWalletResponseSchema: GenMessage<InitWalletResponse>;
/**
 * @generated from message lnrpc.WatchOnly
 */
export type WatchOnly = Message<"lnrpc.WatchOnly"> & {
    /**
     *
     * The unix timestamp in seconds of when the master key was created. lnd will
     * only start scanning for funds in blocks that are after the birthday which
     * can speed up the process significantly. If the birthday is not known, this
     * should be left at its default value of 0 in which case lnd will start
     * scanning from the first SegWit block (481824 on mainnet).
     *
     * @generated from field: uint64 master_key_birthday_timestamp = 1;
     */
    masterKeyBirthdayTimestamp: bigint;
    /**
     *
     * The fingerprint of the root key (also known as the key with derivation path
     * m/) from which the account public keys were derived from. This may be
     * required by some hardware wallets for proper identification and signing. The
     * bytes must be in big-endian order.
     *
     * @generated from field: bytes master_key_fingerprint = 2;
     */
    masterKeyFingerprint: Uint8Array;
    /**
     *
     * The list of accounts to import. There _must_ be an account for all of lnd's
     * main key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the
     * coin type is always 0, even for testnet/regtest) and lnd's internal key
     * scope (m/1017'/<coin_type>'/<account>'), where account is the key family as
     * defined in `keychain/derivation.go` (currently indices 0 to 9).
     *
     * @generated from field: repeated lnrpc.WatchOnlyAccount accounts = 3;
     */
    accounts: WatchOnlyAccount[];
};
/**
 * Describes the message lnrpc.WatchOnly.
 * Use `create(WatchOnlySchema)` to create a new message.
 */
export declare const WatchOnlySchema: GenMessage<WatchOnly>;
/**
 * @generated from message lnrpc.WatchOnlyAccount
 */
export type WatchOnlyAccount = Message<"lnrpc.WatchOnlyAccount"> & {
    /**
     *
     * Purpose is the first number in the derivation path, must be either 49, 84
     * or 1017.
     *
     * @generated from field: uint32 purpose = 1;
     */
    purpose: number;
    /**
     *
     * Coin type is the second number in the derivation path, this is _always_ 0
     * for purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on
     * testnet or regtest.
     *
     * @generated from field: uint32 coin_type = 2;
     */
    coinType: number;
    /**
     *
     * Account is the third number in the derivation path. For purposes 49 and 84
     * at least the default account (index 0) needs to be created but optional
     * additional accounts are allowed. For purpose 1017 there needs to be exactly
     * one account for each of the key families defined in `keychain/derivation.go`
     * (currently indices 0 to 9)
     *
     * @generated from field: uint32 account = 3;
     */
    account: number;
    /**
     *
     * The extended public key at depth 3 for the given account.
     *
     * @generated from field: string xpub = 4;
     */
    xpub: string;
};
/**
 * Describes the message lnrpc.WatchOnlyAccount.
 * Use `create(WatchOnlyAccountSchema)` to create a new message.
 */
export declare const WatchOnlyAccountSchema: GenMessage<WatchOnlyAccount>;
/**
 * @generated from message lnrpc.UnlockWalletRequest
 */
export type UnlockWalletRequest = Message<"lnrpc.UnlockWalletRequest"> & {
    /**
     *
     * wallet_password should be the current valid passphrase for the daemon. This
     * will be required to decrypt on-disk material that the daemon requires to
     * function properly. When using REST, this field must be encoded as base64.
     *
     * @generated from field: bytes wallet_password = 1;
     */
    walletPassword: Uint8Array;
    /**
     *
     * recovery_window is an optional argument specifying the address lookahead
     * when restoring a wallet seed. The recovery window applies to each
     * individual branch of the BIP44 derivation paths. Supplying a recovery
     * window of zero indicates that no addresses should be recovered, such after
     * the first initialization of the wallet.
     *
     * @generated from field: int32 recovery_window = 2;
     */
    recoveryWindow: number;
    /**
     *
     * channel_backups is an optional argument that allows clients to recover the
     * settled funds within a set of channels. This should be populated if the
     * user was unable to close out all channels and sweep funds before partial or
     * total data loss occurred. If specified, then after on-chain recovery of
     * funds, lnd begin to carry out the data loss recovery protocol in order to
     * recover the funds in each channel from a remote force closed transaction.
     *
     * @generated from field: lnrpc.ChanBackupSnapshot channel_backups = 3;
     */
    channelBackups?: ChanBackupSnapshot;
    /**
     *
     * stateless_init is an optional argument instructing the daemon NOT to create
     * any *.macaroon files in its file system.
     *
     * @generated from field: bool stateless_init = 4;
     */
    statelessInit: boolean;
};
/**
 * Describes the message lnrpc.UnlockWalletRequest.
 * Use `create(UnlockWalletRequestSchema)` to create a new message.
 */
export declare const UnlockWalletRequestSchema: GenMessage<UnlockWalletRequest>;
/**
 * @generated from message lnrpc.UnlockWalletResponse
 */
export type UnlockWalletResponse = Message<"lnrpc.UnlockWalletResponse"> & {};
/**
 * Describes the message lnrpc.UnlockWalletResponse.
 * Use `create(UnlockWalletResponseSchema)` to create a new message.
 */
export declare const UnlockWalletResponseSchema: GenMessage<UnlockWalletResponse>;
/**
 * @generated from message lnrpc.ChangePasswordRequest
 */
export type ChangePasswordRequest = Message<"lnrpc.ChangePasswordRequest"> & {
    /**
     *
     * current_password should be the current valid passphrase used to unlock the
     * daemon. When using REST, this field must be encoded as base64.
     *
     * @generated from field: bytes current_password = 1;
     */
    currentPassword: Uint8Array;
    /**
     *
     * new_password should be the new passphrase that will be needed to unlock the
     * daemon. When using REST, this field must be encoded as base64.
     *
     * @generated from field: bytes new_password = 2;
     */
    newPassword: Uint8Array;
    /**
     *
     * stateless_init is an optional argument instructing the daemon NOT to create
     * any *.macaroon files in its filesystem. If this parameter is set, then the
     * admin macaroon returned in the response MUST be stored by the caller of the
     * RPC as otherwise all access to the daemon will be lost!
     *
     * @generated from field: bool stateless_init = 3;
     */
    statelessInit: boolean;
    /**
     *
     * new_macaroon_root_key is an optional argument instructing the daemon to
     * rotate the macaroon root key when set to true. This will invalidate all
     * previously generated macaroons.
     *
     * @generated from field: bool new_macaroon_root_key = 4;
     */
    newMacaroonRootKey: boolean;
};
/**
 * Describes the message lnrpc.ChangePasswordRequest.
 * Use `create(ChangePasswordRequestSchema)` to create a new message.
 */
export declare const ChangePasswordRequestSchema: GenMessage<ChangePasswordRequest>;
/**
 * @generated from message lnrpc.ChangePasswordResponse
 */
export type ChangePasswordResponse = Message<"lnrpc.ChangePasswordResponse"> & {
    /**
     *
     * The binary serialized admin macaroon that can be used to access the daemon
     * after rotating the macaroon root key. If both the stateless_init and
     * new_macaroon_root_key parameter were set to true, this is the ONLY copy of
     * the macaroon that was created from the new root key and MUST be stored
     * safely by the caller. Otherwise a copy of this macaroon is also persisted on
     * disk by the daemon, together with other macaroon files.
     *
     * @generated from field: bytes admin_macaroon = 1;
     */
    adminMacaroon: Uint8Array;
};
/**
 * Describes the message lnrpc.ChangePasswordResponse.
 * Use `create(ChangePasswordResponseSchema)` to create a new message.
 */
export declare const ChangePasswordResponseSchema: GenMessage<ChangePasswordResponse>;
/**
 * WalletUnlocker is a service that is used to set up a wallet password for
 * lnd at first startup, and unlock a previously set up wallet.
 *
 * @generated from service lnrpc.WalletUnlocker
 */
export declare const WalletUnlocker: GenService<{
    /**
     *
     * GenSeed is the first method that should be used to instantiate a new lnd
     * instance. This method allows a caller to generate a new aezeed cipher seed
     * given an optional passphrase. If provided, the passphrase will be necessary
     * to decrypt the cipherseed to expose the internal wallet seed.
     *
     * Once the cipherseed is obtained and verified by the user, the InitWallet
     * method should be used to commit the newly generated seed, and create the
     * wallet.
     *
     * @generated from rpc lnrpc.WalletUnlocker.GenSeed
     */
    genSeed: {
        methodKind: "unary";
        input: typeof GenSeedRequestSchema;
        output: typeof GenSeedResponseSchema;
    };
    /**
     *
     * InitWallet is used when lnd is starting up for the first time to fully
     * initialize the daemon and its internal wallet. At the very least a wallet
     * password must be provided. This will be used to encrypt sensitive material
     * on disk.
     *
     * In the case of a recovery scenario, the user can also specify their aezeed
     * mnemonic and passphrase. If set, then the daemon will use this prior state
     * to initialize its internal wallet.
     *
     * Alternatively, this can be used along with the GenSeed RPC to obtain a
     * seed, then present it to the user. Once it has been verified by the user,
     * the seed can be fed into this RPC in order to commit the new wallet.
     *
     * @generated from rpc lnrpc.WalletUnlocker.InitWallet
     */
    initWallet: {
        methodKind: "unary";
        input: typeof InitWalletRequestSchema;
        output: typeof InitWalletResponseSchema;
    };
    /**
     * lncli: `unlock`
     * UnlockWallet is used at startup of lnd to provide a password to unlock
     * the wallet database.
     *
     * @generated from rpc lnrpc.WalletUnlocker.UnlockWallet
     */
    unlockWallet: {
        methodKind: "unary";
        input: typeof UnlockWalletRequestSchema;
        output: typeof UnlockWalletResponseSchema;
    };
    /**
     * lncli: `changepassword`
     * ChangePassword changes the password of the encrypted wallet. This will
     * automatically unlock the wallet database if successful.
     *
     * @generated from rpc lnrpc.WalletUnlocker.ChangePassword
     */
    changePassword: {
        methodKind: "unary";
        input: typeof ChangePasswordRequestSchema;
        output: typeof ChangePasswordResponseSchema;
    };
}>;
//# sourceMappingURL=walletunlocker_pb.d.ts.map