"use strict";

// Note to react-native-turbo-lnd contributors:
// This file is automatically generated by the protoc plugin inside the
// protoc-generator folder.
// Any changes to this file should be made there instead.
/* eslint-disable */
import "./setup-text-encoding.js";
let TurboLnd;
if (globalThis["fakelnd"] || typeof jest !== 'undefined') {
  TurboLnd = require('./mocks/index').default;
} else {
  TurboLnd = require('./core/NativeTurboLnd').default;
}
import { create, toBinary, fromBinary } from "@bufbuild/protobuf";
import { base64Encode, base64Decode } from "@bufbuild/protobuf/wire";
import * as lnrpc from "./proto/lightning_pb.js";
// import * as walletunlocker from "./proto/walletunlocker_pb";
// import * as state from "./proto/stateservice_pb";
import * as autopilotrpc from "./proto/autopilotrpc/autopilot_pb.js";
// import * as chainrpc from "./proto/chainrpc/chainkit_pb";
import * as chainrpc from "./proto/chainrpc/chainnotifier_pb.js";
// import * as dev from "./proto/devrpc/dev_pb";
import * as invoicesrpc from "./proto/invoicesrpc/invoices_pb.js";
// import * as versionresponse from "./proto/lnclipb/lncli_pb";
import * as neutrinorpc from "./proto/neutrinorpc/neutrino_pb.js";
import * as peersrpc from "./proto/peersrpc/peers_pb.js";
import * as routerrpc from "./proto/routerrpc/router_pb.js";
import * as signrpc from "./proto/signrpc/signer_pb.js";
import * as verrpc from "./proto/verrpc/verrpc_pb.js";
import * as walletrpc from "./proto/walletrpc/walletkit_pb.js";
import * as watchtowerrpc from "./proto/watchtowerrpc/watchtower_pb.js";
import * as wtclientrpc from "./proto/wtclientrpc/wtclient_pb.js";

/**
 *
 * Starts up lnd.
 * You need to provide path to the app's local dir to lnd via `--lnddir` arg.
 * Use `subscribeState` to know when lnd is ready for wallet unlock/creation.
 *
 */
export const start = TurboLnd.start;

/**
   *
   * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
   * confirmed unspent outputs and all unconfirmed unspent outputs under control
   * of the wallet.
   *
   * @param [WalletBalanceRequest]
   * @returns [WalletBalanceResponse]
   *
   */
export async function walletBalance(request) {
  const message = create(lnrpc.WalletBalanceRequestSchema, request);
  const b64 = await TurboLnd.walletBalance(base64Encode(toBinary(lnrpc.WalletBalanceRequestSchema, message)));
  const response = fromBinary(lnrpc.WalletBalanceResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ChannelBalance returns a report on the total funds across all open channels,
   * categorized in local/remote, pending local/remote and unsettled local/remote
   * balances.
   *
   * @param [ChannelBalanceRequest]
   * @returns [ChannelBalanceResponse]
   *
   */
export async function channelBalance(request) {
  const message = create(lnrpc.ChannelBalanceRequestSchema, request);
  const b64 = await TurboLnd.channelBalance(base64Encode(toBinary(lnrpc.ChannelBalanceRequestSchema, message)));
  const response = fromBinary(lnrpc.ChannelBalanceResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetTransactions returns a list describing all the known transactions
   * relevant to the wallet.
   *
   * @param [GetTransactionsRequest]
   * @returns [TransactionDetails]
   *
   */
export async function getTransactions(request) {
  const message = create(lnrpc.GetTransactionsRequestSchema, request);
  const b64 = await TurboLnd.getTransactions(base64Encode(toBinary(lnrpc.GetTransactionsRequestSchema, message)));
  const response = fromBinary(lnrpc.TransactionDetailsSchema, base64Decode(b64));
  return response;
}

/**
   *
   * EstimateFee attempts to query the internal fee estimator of the wallet to
   * determine the fee (in sat/kw) to attach to a transaction in order to
   * achieve the confirmation target.
   *
   * @param [EstimateFeeRequest]
   * @returns [EstimateFeeResponse]
   *
   */
export async function estimateFee(request) {
  const message = create(lnrpc.EstimateFeeRequestSchema, request);
  const b64 = await TurboLnd.estimateFee(base64Encode(toBinary(lnrpc.EstimateFeeRequestSchema, message)));
  const response = fromBinary(lnrpc.EstimateFeeResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SendCoins executes a request to send coins to a particular address. Unlike
   * SendMany, this RPC call only allows creating a single output at a time. If
   * neither target_conf, or sat_per_vbyte are set, then the internal wallet will
   * consult its fee model to determine a fee for the default confirmation
   * target.
   *
   * @param [SendCoinsRequest]
   * @returns [SendCoinsResponse]
   *
   */
export async function sendCoins(request) {
  const message = create(lnrpc.SendCoinsRequestSchema, request);
  const b64 = await TurboLnd.sendCoins(base64Encode(toBinary(lnrpc.SendCoinsRequestSchema, message)));
  const response = fromBinary(lnrpc.SendCoinsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListUnspent returns a list of all utxos spendable by the wallet with a
   * number of confirmations between the specified minimum and maximum. By
   * default, all utxos are listed. To list only the unconfirmed utxos, set
   * the unconfirmed_only to true.
   *
   * @param [ListUnspentRequest]
   * @returns [ListUnspentResponse]
   *
   */
export async function listUnspent(request) {
  const message = create(lnrpc.ListUnspentRequestSchema, request);
  const b64 = await TurboLnd.listUnspent(base64Encode(toBinary(lnrpc.ListUnspentRequestSchema, message)));
  const response = fromBinary(lnrpc.ListUnspentResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeTransactions creates a uni-directional stream from the server to
   * the client in which any newly discovered transactions relevant to the
   * wallet are sent over.
   *
   * @param [GetTransactionsRequest]
   * @returns [Transaction]
   *
   */
export function subscribeTransactions(request, onResponse, onError) {
  const message = create(lnrpc.GetTransactionsRequestSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.GetTransactionsRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.TransactionSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeTransactions(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * SendMany handles a request for a transaction that creates multiple specified
   * outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
   * the internal wallet will consult its fee model to determine a fee for the
   * default confirmation target.
   *
   * @param [SendManyRequest]
   * @returns [SendManyResponse]
   *
   */
export async function sendMany(request) {
  const message = create(lnrpc.SendManyRequestSchema, request);
  const b64 = await TurboLnd.sendMany(base64Encode(toBinary(lnrpc.SendManyRequestSchema, message)));
  const response = fromBinary(lnrpc.SendManyResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * NewAddress creates a new address under control of the local wallet.
   *
   * @param [NewAddressRequest]
   * @returns [NewAddressResponse]
   *
   */
export async function newAddress(request) {
  const message = create(lnrpc.NewAddressRequestSchema, request);
  const b64 = await TurboLnd.newAddress(base64Encode(toBinary(lnrpc.NewAddressRequestSchema, message)));
  const response = fromBinary(lnrpc.NewAddressResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SignMessage signs a message with the key specified in the key locator. The
   * returned signature is fixed-size LN wire format encoded.
   *
   * The main difference to SignMessage in the main RPC is that a specific key is
   * used to sign the message instead of the node identity private key.
   *
   * @param [SignMessageRequest]
   * @returns [SignMessageResponse]
   *
   */
export async function signMessage(request) {
  const message = create(lnrpc.SignMessageRequestSchema, request);
  const b64 = await TurboLnd.signMessage(base64Encode(toBinary(lnrpc.SignMessageRequestSchema, message)));
  const response = fromBinary(lnrpc.SignMessageResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * VerifyMessage verifies a signature over a message using the public key
   * provided. The signature must be fixed-size LN wire format encoded.
   *
   * The main difference to VerifyMessage in the main RPC is that the public key
   * used to sign the message does not have to be a node known to the network.
   *
   * @param [VerifyMessageRequest]
   * @returns [VerifyMessageResponse]
   *
   */
export async function verifyMessage(request) {
  const message = create(lnrpc.VerifyMessageRequestSchema, request);
  const b64 = await TurboLnd.verifyMessage(base64Encode(toBinary(lnrpc.VerifyMessageRequestSchema, message)));
  const response = fromBinary(lnrpc.VerifyMessageResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ConnectPeer attempts to establish a connection to a remote peer. This is at
   * the networking level, and is used for communication between nodes. This is
   * distinct from establishing a channel with a peer.
   *
   * @param [ConnectPeerRequest]
   * @returns [ConnectPeerResponse]
   *
   */
export async function connectPeer(request) {
  const message = create(lnrpc.ConnectPeerRequestSchema, request);
  const b64 = await TurboLnd.connectPeer(base64Encode(toBinary(lnrpc.ConnectPeerRequestSchema, message)));
  const response = fromBinary(lnrpc.ConnectPeerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DisconnectPeer disconnects a peer by target address. Both outbound and
   * inbound nodes will be searched for the target node. An error message will
   * be returned if the peer was not found.
   *
   * @param [DisconnectPeerRequest]
   * @returns [DisconnectPeerResponse]
   *
   */
export async function disconnectPeer(request) {
  const message = create(lnrpc.DisconnectPeerRequestSchema, request);
  const b64 = await TurboLnd.disconnectPeer(base64Encode(toBinary(lnrpc.DisconnectPeerRequestSchema, message)));
  const response = fromBinary(lnrpc.DisconnectPeerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListPeers returns a verbose listing of all currently active peers.
   *
   * @param [ListPeersRequest]
   * @returns [ListPeersResponse]
   *
   */
export async function listPeers(request) {
  const message = create(lnrpc.ListPeersRequestSchema, request);
  const b64 = await TurboLnd.listPeers(base64Encode(toBinary(lnrpc.ListPeersRequestSchema, message)));
  const response = fromBinary(lnrpc.ListPeersResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribePeerEvents creates a uni-directional stream from the server to
   * the client in which any events relevant to the state of peers are sent
   * over. Events include peers going online and offline.
   *
   * @param [PeerEventSubscription]
   * @returns [PeerEvent]
   *
   */
export function subscribePeerEvents(request, onResponse, onError) {
  const message = create(lnrpc.PeerEventSubscriptionSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.PeerEventSubscriptionSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.PeerEventSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribePeerEvents(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * GetInfo returns general information concerning the companion watchtower
   * including its public key and URIs where the server is currently
   * listening for clients.
   *
   * @param [GetInfoRequest]
   * @returns [GetInfoResponse]
   *
   */
export async function getInfo(request) {
  const message = create(lnrpc.GetInfoRequestSchema, request);
  const b64 = await TurboLnd.getInfo(base64Encode(toBinary(lnrpc.GetInfoRequestSchema, message)));
  const response = fromBinary(lnrpc.GetInfoResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetRecoveryInfo returns information concerning the recovery mode including
   * whether it's in a recovery mode, whether the recovery is finished, and the
   * progress made so far.
   *
   * @param [GetRecoveryInfoRequest]
   * @returns [GetRecoveryInfoResponse]
   *
   */
export async function getRecoveryInfo(request) {
  const message = create(lnrpc.GetRecoveryInfoRequestSchema, request);
  const b64 = await TurboLnd.getRecoveryInfo(base64Encode(toBinary(lnrpc.GetRecoveryInfoRequestSchema, message)));
  const response = fromBinary(lnrpc.GetRecoveryInfoResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * PendingChannels returns a list of all the channels that are currently
   * considered "pending". A channel is pending if it has finished the funding
   * workflow and is waiting for confirmations for the funding txn, or is in the
   * process of closure, either initiated cooperatively or non-cooperatively.
   *
   * @param [PendingChannelsRequest]
   * @returns [PendingChannelsResponse]
   *
   */
export async function pendingChannels(request) {
  const message = create(lnrpc.PendingChannelsRequestSchema, request);
  const b64 = await TurboLnd.pendingChannels(base64Encode(toBinary(lnrpc.PendingChannelsRequestSchema, message)));
  const response = fromBinary(lnrpc.PendingChannelsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListChannels returns a description of all the open channels that this node
   * is a participant in.
   *
   * @param [ListChannelsRequest]
   * @returns [ListChannelsResponse]
   *
   */
export async function listChannels(request) {
  const message = create(lnrpc.ListChannelsRequestSchema, request);
  const b64 = await TurboLnd.listChannels(base64Encode(toBinary(lnrpc.ListChannelsRequestSchema, message)));
  const response = fromBinary(lnrpc.ListChannelsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeChannelEvents creates a uni-directional stream from the server to
   * the client in which any updates relevant to the state of the channels are
   * sent over. Events include new active channels, inactive channels, and closed
   * channels.
   *
   * @param [ChannelEventSubscription]
   * @returns [ChannelEventUpdate]
   *
   */
export function subscribeChannelEvents(request, onResponse, onError) {
  const message = create(lnrpc.ChannelEventSubscriptionSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.ChannelEventSubscriptionSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.ChannelEventUpdateSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeChannelEvents(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * ClosedChannels returns a description of all the closed channels that
   * this node was a participant in.
   *
   * @param [ClosedChannelsRequest]
   * @returns [ClosedChannelsResponse]
   *
   */
export async function closedChannels(request) {
  const message = create(lnrpc.ClosedChannelsRequestSchema, request);
  const b64 = await TurboLnd.closedChannels(base64Encode(toBinary(lnrpc.ClosedChannelsRequestSchema, message)));
  const response = fromBinary(lnrpc.ClosedChannelsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
   * call is meant to be consumed by clients to the REST proxy. As with all
   * other sync calls, all byte slices are intended to be populated as hex
   * encoded strings.
   *
   * @param [OpenChannelRequest]
   * @returns [ChannelPoint]
   *
   */
export async function openChannelSync(request) {
  const message = create(lnrpc.OpenChannelRequestSchema, request);
  const b64 = await TurboLnd.openChannelSync(base64Encode(toBinary(lnrpc.OpenChannelRequestSchema, message)));
  const response = fromBinary(lnrpc.ChannelPointSchema, base64Decode(b64));
  return response;
}

/**
   *
   * OpenChannel attempts to open a singly funded channel specified in the
   * request to a remote peer. Users are able to specify a target number of
   * blocks that the funding transaction should be confirmed in, or a manual fee
   * rate to us for the funding transaction. If neither are specified, then a
   * lax block confirmation target is used. Each OpenStatusUpdate will return
   * the pending channel ID of the in-progress channel. Depending on the
   * arguments specified in the OpenChannelRequest, this pending channel ID can
   * then be used to manually progress the channel funding flow.
   *
   * @param [OpenChannelRequest]
   * @returns [OpenStatusUpdate]
   *
   */
export function openChannel(request, onResponse, onError) {
  const message = create(lnrpc.OpenChannelRequestSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.OpenChannelRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.OpenStatusUpdateSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.openChannel(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * BatchOpenChannel attempts to open multiple single-funded channels in a
   * single transaction in an atomic way. This means either all channel open
   * requests succeed at once or all attempts are aborted if any of them fail.
   * This is the safer variant of using PSBTs to manually fund a batch of
   * channels through the OpenChannel RPC.
   *
   * @param [BatchOpenChannelRequest]
   * @returns [BatchOpenChannelResponse]
   *
   */
export async function batchOpenChannel(request) {
  const message = create(lnrpc.BatchOpenChannelRequestSchema, request);
  const b64 = await TurboLnd.batchOpenChannel(base64Encode(toBinary(lnrpc.BatchOpenChannelRequestSchema, message)));
  const response = fromBinary(lnrpc.BatchOpenChannelResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * FundingStateStep is an advanced funding related call that allows the caller
   * to either execute some preparatory steps for a funding workflow, or
   * manually progress a funding workflow. The primary way a funding flow is
   * identified is via its pending channel ID. As an example, this method can be
   * used to specify that we're expecting a funding flow for a particular
   * pending channel ID, for which we need to use specific parameters.
   * Alternatively, this can be used to interactively drive PSBT signing for
   * funding for partially complete funding transactions.
   *
   * @param [FundingTransitionMsg]
   * @returns [FundingStateStepResp]
   *
   */
export async function fundingStateStep(request) {
  const message = create(lnrpc.FundingTransitionMsgSchema, request);
  const b64 = await TurboLnd.fundingStateStep(base64Encode(toBinary(lnrpc.FundingTransitionMsgSchema, message)));
  const response = fromBinary(lnrpc.FundingStateStepRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ChannelAcceptor dispatches a bi-directional streaming RPC in which
   * OpenChannel requests are sent to the client and the client responds with
   * a boolean that tells LND whether or not to accept the channel. This allows
   * node operators to specify their own criteria for accepting inbound channels
   * through a single persistent connection.
   *
   * @param [ChannelAcceptResponse]
   * @returns [ChannelAcceptRequest]
   *
   */
export function channelAcceptor(onResponse, onError) {
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.ChannelAcceptRequestSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  const writeableStream = TurboLnd.channelAcceptor(onResponseWrapper, onErrorWrapper);
  return {
    send: response => {
      const message = create(lnrpc.ChannelAcceptResponseSchema, response);
      const responseB64 = base64Encode(toBinary(lnrpc.ChannelAcceptResponseSchema, message));
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  };
}

/**
   *
   * CloseChannel attempts to close an active channel identified by its channel
   * outpoint (ChannelPoint). The actions of this method can additionally be
   * augmented to attempt a force close after a timeout period in the case of an
   * inactive peer. If a non-force close (cooperative closure) is requested,
   * then the user can specify either a target number of blocks until the
   * closure transaction is confirmed, or a manual fee rate. If neither are
   * specified, then a default lax, block confirmation target is used.
   *
   * @param [CloseChannelRequest]
   * @returns [CloseStatusUpdate]
   *
   */
export function closeChannel(request, onResponse, onError) {
  const message = create(lnrpc.CloseChannelRequestSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.CloseChannelRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.CloseStatusUpdateSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.closeChannel(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * AbandonChannel removes all channel state from the database except for a
   * close summary. This method can be used to get rid of permanently unusable
   * channels due to bugs fixed in newer versions of lnd. This method can also be
   * used to remove externally funded channels where the funding transaction was
   * never broadcast. Only available for non-externally funded channels in dev
   * build.
   *
   * @param [AbandonChannelRequest]
   * @returns [AbandonChannelResponse]
   *
   */
export async function abandonChannel(request) {
  const message = create(lnrpc.AbandonChannelRequestSchema, request);
  const b64 = await TurboLnd.abandonChannel(base64Encode(toBinary(lnrpc.AbandonChannelRequestSchema, message)));
  const response = fromBinary(lnrpc.AbandonChannelResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Deprecated, use SendPaymentV2. SendPayment attempts to route a payment
   * described by the passed PaymentRequest to the final destination. The call
   * returns a stream of payment status updates.
   *
   * @param [SendRequest]
   * @returns [SendResponse]
   *
   */
export function sendPayment(onResponse, onError) {
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.SendResponseSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  const writeableStream = TurboLnd.sendPayment(onResponseWrapper, onErrorWrapper);
  return {
    send: response => {
      const message = create(lnrpc.SendRequestSchema, response);
      const responseB64 = base64Encode(toBinary(lnrpc.SendRequestSchema, message));
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  };
}

/**
   *
   * SendPaymentSync is the synchronous non-streaming version of SendPayment.
   * This RPC is intended to be consumed by clients of the REST proxy.
   * Additionally, this RPC expects the destination's public key and the payment
   * hash (if any) to be encoded as hex strings.
   *
   * @param [SendRequest]
   * @returns [SendResponse]
   *
   */
export async function sendPaymentSync(request) {
  const message = create(lnrpc.SendRequestSchema, request);
  const b64 = await TurboLnd.sendPaymentSync(base64Encode(toBinary(lnrpc.SendRequestSchema, message)));
  const response = fromBinary(lnrpc.SendResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via
   * the specified route. This method differs from SendPayment in that it
   * allows users to specify a full route manually. This can be used for
   * things like rebalancing, and atomic swaps. It differs from the newer
   * SendToRouteV2 in that it doesn't return the full HTLC information.
   *
   * @param [SendToRouteRequest]
   * @returns [SendResponse]
   *
   */
export function sendToRoute(onResponse, onError) {
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.SendResponseSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  const writeableStream = TurboLnd.sendToRoute(onResponseWrapper, onErrorWrapper);
  return {
    send: response => {
      const message = create(lnrpc.SendToRouteRequestSchema, response);
      const responseB64 = base64Encode(toBinary(lnrpc.SendToRouteRequestSchema, message));
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  };
}

/**
   *
   * SendToRouteSync is a synchronous version of SendToRoute. It Will block
   * until the payment either fails or succeeds.
   *
   * @param [SendToRouteRequest]
   * @returns [SendResponse]
   *
   */
export async function sendToRouteSync(request) {
  const message = create(lnrpc.SendToRouteRequestSchema, request);
  const b64 = await TurboLnd.sendToRouteSync(base64Encode(toBinary(lnrpc.SendToRouteRequestSchema, message)));
  const response = fromBinary(lnrpc.SendResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * AddInvoice attempts to add a new invoice to the invoice database. Any
   * duplicated invoices are rejected, therefore all invoices *must* have a
   * unique payment preimage.
   *
   * @param [Invoice]
   * @returns [AddInvoiceResponse]
   *
   */
export async function addInvoice(request) {
  const message = create(lnrpc.InvoiceSchema, request);
  const b64 = await TurboLnd.addInvoice(base64Encode(toBinary(lnrpc.InvoiceSchema, message)));
  const response = fromBinary(lnrpc.AddInvoiceResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListInvoices returns a list of all the invoices currently stored within the
   * database. Any active debug invoices are ignored. It has full support for
   * paginated responses, allowing users to query for specific invoices through
   * their add_index. This can be done by using either the first_index_offset or
   * last_index_offset fields included in the response as the index_offset of the
   * next request. By default, the first 100 invoices created will be returned.
   * Backwards pagination is also supported through the Reversed flag.
   *
   * @param [ListInvoiceRequest]
   * @returns [ListInvoiceResponse]
   *
   */
export async function listInvoices(request) {
  const message = create(lnrpc.ListInvoiceRequestSchema, request);
  const b64 = await TurboLnd.listInvoices(base64Encode(toBinary(lnrpc.ListInvoiceRequestSchema, message)));
  const response = fromBinary(lnrpc.ListInvoiceResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * LookupInvoice attempts to look up an invoice according to its payment hash.
   * The passed payment hash *must* be exactly 32 bytes, if not, an error is
   * returned.
   *
   * @param [PaymentHash]
   * @returns [Invoice]
   *
   */
export async function lookupInvoice(request) {
  const message = create(lnrpc.PaymentHashSchema, request);
  const b64 = await TurboLnd.lookupInvoice(base64Encode(toBinary(lnrpc.PaymentHashSchema, message)));
  const response = fromBinary(lnrpc.InvoiceSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeInvoices returns a uni-directional stream (server -> client) for
   * notifying the client of newly added/settled invoices. The caller can
   * optionally specify the add_index and/or the settle_index. If the add_index
   * is specified, then we'll first start by sending add invoice events for all
   * invoices with an add_index greater than the specified value. If the
   * settle_index is specified, the next, we'll send out all settle events for
   * invoices with a settle_index greater than the specified value. One or both
   * of these fields can be set. If no fields are set, then we'll only send out
   * the latest add/settle events.
   *
   * @param [InvoiceSubscription]
   * @returns [Invoice]
   *
   */
export function subscribeInvoices(request, onResponse, onError) {
  const message = create(lnrpc.InvoiceSubscriptionSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.InvoiceSubscriptionSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.InvoiceSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeInvoices(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * DecodePayReq takes an encoded payment request string and attempts to decode
   * it, returning a full description of the conditions encoded within the
   * payment request.
   *
   * @param [PayReqString]
   * @returns [PayReq]
   *
   */
export async function decodePayReq(request) {
  const message = create(lnrpc.PayReqStringSchema, request);
  const b64 = await TurboLnd.decodePayReq(base64Encode(toBinary(lnrpc.PayReqStringSchema, message)));
  const response = fromBinary(lnrpc.PayReqSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListPayments returns a list of all outgoing payments.
   *
   * @param [ListPaymentsRequest]
   * @returns [ListPaymentsResponse]
   *
   */
export async function listPayments(request) {
  const message = create(lnrpc.ListPaymentsRequestSchema, request);
  const b64 = await TurboLnd.listPayments(base64Encode(toBinary(lnrpc.ListPaymentsRequestSchema, message)));
  const response = fromBinary(lnrpc.ListPaymentsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeletePayment deletes an outgoing payment from DB. Note that it will not
   * attempt to delete an In-Flight payment, since that would be unsafe.
   *
   * @param [DeletePaymentRequest]
   * @returns [DeletePaymentResponse]
   *
   */
export async function deletePayment(request) {
  const message = create(lnrpc.DeletePaymentRequestSchema, request);
  const b64 = await TurboLnd.deletePayment(base64Encode(toBinary(lnrpc.DeletePaymentRequestSchema, message)));
  const response = fromBinary(lnrpc.DeletePaymentResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeleteAllPayments deletes all outgoing payments from DB. Note that it will
   * not attempt to delete In-Flight payments, since that would be unsafe.
   *
   * @param [DeleteAllPaymentsRequest]
   * @returns [DeleteAllPaymentsResponse]
   *
   */
export async function deleteAllPayments(request) {
  const message = create(lnrpc.DeleteAllPaymentsRequestSchema, request);
  const b64 = await TurboLnd.deleteAllPayments(base64Encode(toBinary(lnrpc.DeleteAllPaymentsRequestSchema, message)));
  const response = fromBinary(lnrpc.DeleteAllPaymentsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DescribeGraph returns a description of the latest graph state from the
   * point of view of the node. The graph information is partitioned into two
   * components: all the nodes/vertexes, and all the edges that connect the
   * vertexes themselves. As this is a directed graph, the edges also contain
   * the node directional specific routing policy which includes: the time lock
   * delta, fee information, etc.
   *
   * @param [ChannelGraphRequest]
   * @returns [ChannelGraph]
   *
   */
export async function describeGraph(request) {
  const message = create(lnrpc.ChannelGraphRequestSchema, request);
  const b64 = await TurboLnd.describeGraph(base64Encode(toBinary(lnrpc.ChannelGraphRequestSchema, message)));
  const response = fromBinary(lnrpc.ChannelGraphSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetNodeMetrics returns node metrics calculated from the graph. Currently
   * the only supported metric is betweenness centrality of individual nodes.
   *
   * @param [NodeMetricsRequest]
   * @returns [NodeMetricsResponse]
   *
   */
export async function getNodeMetrics(request) {
  const message = create(lnrpc.NodeMetricsRequestSchema, request);
  const b64 = await TurboLnd.getNodeMetrics(base64Encode(toBinary(lnrpc.NodeMetricsRequestSchema, message)));
  const response = fromBinary(lnrpc.NodeMetricsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetChanInfo returns the latest authenticated network announcement for the
   * given channel identified by its channel ID: an 8-byte integer which
   * uniquely identifies the location of transaction's funding output within the
   * blockchain.
   *
   * @param [ChanInfoRequest]
   * @returns [ChannelEdge]
   *
   */
export async function getChanInfo(request) {
  const message = create(lnrpc.ChanInfoRequestSchema, request);
  const b64 = await TurboLnd.getChanInfo(base64Encode(toBinary(lnrpc.ChanInfoRequestSchema, message)));
  const response = fromBinary(lnrpc.ChannelEdgeSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetNodeInfo returns the latest advertised, aggregated, and authenticated
   * channel information for the specified node identified by its public key.
   *
   * @param [NodeInfoRequest]
   * @returns [NodeInfo]
   *
   */
export async function getNodeInfo(request) {
  const message = create(lnrpc.NodeInfoRequestSchema, request);
  const b64 = await TurboLnd.getNodeInfo(base64Encode(toBinary(lnrpc.NodeInfoRequestSchema, message)));
  const response = fromBinary(lnrpc.NodeInfoSchema, base64Decode(b64));
  return response;
}

/**
   *
   * QueryRoutes attempts to query the daemon's Channel Router for a possible
   * route to a target destination capable of carrying a specific amount of
   * satoshis. The returned route contains the full details required to craft and
   * send an HTLC, also including the necessary information that should be
   * present within the Sphinx packet encapsulated within the HTLC.
   *
   * When using REST, the `dest_custom_records` map type can be set by appending
   * `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
   * to the URL. Unfortunately this map type doesn't appear in the REST API
   * documentation because of a bug in the grpc-gateway library.
   *
   * @param [QueryRoutesRequest]
   * @returns [QueryRoutesResponse]
   *
   */
export async function queryRoutes(request) {
  const message = create(lnrpc.QueryRoutesRequestSchema, request);
  const b64 = await TurboLnd.queryRoutes(base64Encode(toBinary(lnrpc.QueryRoutesRequestSchema, message)));
  const response = fromBinary(lnrpc.QueryRoutesResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetNetworkInfo returns some basic stats about the known channel graph from
   * the point of view of the node.
   *
   * @param [NetworkInfoRequest]
   * @returns [NetworkInfo]
   *
   */
export async function getNetworkInfo(request) {
  const message = create(lnrpc.NetworkInfoRequestSchema, request);
  const b64 = await TurboLnd.getNetworkInfo(base64Encode(toBinary(lnrpc.NetworkInfoRequestSchema, message)));
  const response = fromBinary(lnrpc.NetworkInfoSchema, base64Decode(b64));
  return response;
}

/**
   *
   * StopDaemon will send a shutdown request to the interrupt handler, triggering
   * a graceful shutdown of the daemon.
   *
   * @param [StopRequest]
   * @returns [StopResponse]
   *
   */
export async function stopDaemon(request) {
  const message = create(lnrpc.StopRequestSchema, request);
  const b64 = await TurboLnd.stopDaemon(base64Encode(toBinary(lnrpc.StopRequestSchema, message)));
  const response = fromBinary(lnrpc.StopResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeChannelGraph launches a streaming RPC that allows the caller to
   * receive notifications upon any changes to the channel graph topology from
   * the point of view of the responding node. Events notified include: new
   * nodes coming online, nodes updating their authenticated attributes, new
   * channels being advertised, updates in the routing policy for a directional
   * channel edge, and when channels are closed on-chain.
   *
   * @param [GraphTopologySubscription]
   * @returns [GraphTopologyUpdate]
   *
   */
export function subscribeChannelGraph(request, onResponse, onError) {
  const message = create(lnrpc.GraphTopologySubscriptionSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.GraphTopologySubscriptionSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.GraphTopologyUpdateSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeChannelGraph(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * DebugLevel allows a caller to programmatically set the logging verbosity of
   * lnd. The logging can be targeted according to a coarse daemon-wide logging
   * level, or in a granular fashion to specify the logging for a target
   * sub-system.
   *
   * @param [DebugLevelRequest]
   * @returns [DebugLevelResponse]
   *
   */
export async function debugLevel(request) {
  const message = create(lnrpc.DebugLevelRequestSchema, request);
  const b64 = await TurboLnd.debugLevel(base64Encode(toBinary(lnrpc.DebugLevelRequestSchema, message)));
  const response = fromBinary(lnrpc.DebugLevelResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * FeeReport allows the caller to obtain a report detailing the current fee
   * schedule enforced by the node globally for each channel.
   *
   * @param [FeeReportRequest]
   * @returns [FeeReportResponse]
   *
   */
export async function feeReport(request) {
  const message = create(lnrpc.FeeReportRequestSchema, request);
  const b64 = await TurboLnd.feeReport(base64Encode(toBinary(lnrpc.FeeReportRequestSchema, message)));
  const response = fromBinary(lnrpc.FeeReportResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * UpdateChannelPolicy allows the caller to update the fee schedule and
   * channel policies for all channels globally, or a particular channel.
   *
   * @param [PolicyUpdateRequest]
   * @returns [PolicyUpdateResponse]
   *
   */
export async function updateChannelPolicy(request) {
  const message = create(lnrpc.PolicyUpdateRequestSchema, request);
  const b64 = await TurboLnd.updateChannelPolicy(base64Encode(toBinary(lnrpc.PolicyUpdateRequestSchema, message)));
  const response = fromBinary(lnrpc.PolicyUpdateResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ForwardingHistory allows the caller to query the htlcswitch for a record of
   * all HTLCs forwarded within the target time range, and integer offset
   * within that time range, for a maximum number of events. If no maximum number
   * of events is specified, up to 100 events will be returned. If no time-range
   * is specified, then events will be returned in the order that they occured.
   *
   * A list of forwarding events are returned. The size of each forwarding event
   * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
   * As a result each message can only contain 50k entries. Each response has
   * the index offset of the last entry. The index offset can be provided to the
   * request to allow the caller to skip a series of records.
   *
   * @param [ForwardingHistoryRequest]
   * @returns [ForwardingHistoryResponse]
   *
   */
export async function forwardingHistory(request) {
  const message = create(lnrpc.ForwardingHistoryRequestSchema, request);
  const b64 = await TurboLnd.forwardingHistory(base64Encode(toBinary(lnrpc.ForwardingHistoryRequestSchema, message)));
  const response = fromBinary(lnrpc.ForwardingHistoryResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ExportChannelBackup attempts to return an encrypted static channel backup
   * for the target channel identified by it channel point. The backup is
   * encrypted with a key generated from the aezeed seed of the user. The
   * returned backup can either be restored using the RestoreChannelBackup
   * method once lnd is running, or via the InitWallet and UnlockWallet methods
   * from the WalletUnlocker service.
   *
   * @param [ExportChannelBackupRequest]
   * @returns [ChannelBackup]
   *
   */
export async function exportChannelBackup(request) {
  const message = create(lnrpc.ExportChannelBackupRequestSchema, request);
  const b64 = await TurboLnd.exportChannelBackup(base64Encode(toBinary(lnrpc.ExportChannelBackupRequestSchema, message)));
  const response = fromBinary(lnrpc.ChannelBackupSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ExportAllChannelBackups returns static channel backups for all existing
   * channels known to lnd. A set of regular singular static channel backups for
   * each channel are returned. Additionally, a multi-channel backup is returned
   * as well, which contains a single encrypted blob containing the backups of
   * each channel.
   *
   * @param [ChanBackupExportRequest]
   * @returns [ChanBackupSnapshot]
   *
   */
export async function exportAllChannelBackups(request) {
  const message = create(lnrpc.ChanBackupExportRequestSchema, request);
  const b64 = await TurboLnd.exportAllChannelBackups(base64Encode(toBinary(lnrpc.ChanBackupExportRequestSchema, message)));
  const response = fromBinary(lnrpc.ChanBackupSnapshotSchema, base64Decode(b64));
  return response;
}

/**
   *
   * VerifyChanBackup allows a caller to verify the integrity of a channel backup
   * snapshot. This method will accept either a packed Single or a packed Multi.
   * Specifying both will result in an error.
   *
   * @param [ChanBackupSnapshot]
   * @returns [VerifyChanBackupResponse]
   *
   */
export async function verifyChanBackup(request) {
  const message = create(lnrpc.ChanBackupSnapshotSchema, request);
  const b64 = await TurboLnd.verifyChanBackup(base64Encode(toBinary(lnrpc.ChanBackupSnapshotSchema, message)));
  const response = fromBinary(lnrpc.VerifyChanBackupResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * RestoreChannelBackups accepts a set of singular channel backups, or a
   * single encrypted multi-chan backup and attempts to recover any funds
   * remaining within the channel. If we are able to unpack the backup, then the
   * new channel will be shown under listchannels, as well as pending channels.
   *
   * @param [RestoreChanBackupRequest]
   * @returns [RestoreBackupResponse]
   *
   */
export async function restoreChannelBackups(request) {
  const message = create(lnrpc.RestoreChanBackupRequestSchema, request);
  const b64 = await TurboLnd.restoreChannelBackups(base64Encode(toBinary(lnrpc.RestoreChanBackupRequestSchema, message)));
  const response = fromBinary(lnrpc.RestoreBackupResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeChannelBackups allows a client to sub-subscribe to the most up to
   * date information concerning the state of all channel backups. Each time a
   * new channel is added, we return the new set of channels, along with a
   * multi-chan backup containing the backup info for all channels. Each time a
   * channel is closed, we send a new update, which contains new new chan back
   * ups, but the updated set of encrypted multi-chan backups with the closed
   * channel(s) removed.
   *
   * @param [ChannelBackupSubscription]
   * @returns [ChanBackupSnapshot]
   *
   */
export function subscribeChannelBackups(request, onResponse, onError) {
  const message = create(lnrpc.ChannelBackupSubscriptionSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.ChannelBackupSubscriptionSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.ChanBackupSnapshotSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeChannelBackups(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * BakeMacaroon allows the creation of a new macaroon with custom read and
   * write permissions. No first-party caveats are added since this can be done
   * offline.
   *
   * @param [BakeMacaroonRequest]
   * @returns [BakeMacaroonResponse]
   *
   */
export async function bakeMacaroon(request) {
  const message = create(lnrpc.BakeMacaroonRequestSchema, request);
  const b64 = await TurboLnd.bakeMacaroon(base64Encode(toBinary(lnrpc.BakeMacaroonRequestSchema, message)));
  const response = fromBinary(lnrpc.BakeMacaroonResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListMacaroonIDs returns all root key IDs that are in use.
   *
   * @param [ListMacaroonIDsRequest]
   * @returns [ListMacaroonIDsResponse]
   *
   */
export async function listMacaroonIDs(request) {
  const message = create(lnrpc.ListMacaroonIDsRequestSchema, request);
  const b64 = await TurboLnd.listMacaroonIDs(base64Encode(toBinary(lnrpc.ListMacaroonIDsRequestSchema, message)));
  const response = fromBinary(lnrpc.ListMacaroonIDsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeleteMacaroonID deletes the specified macaroon ID and invalidates all
   * macaroons derived from that ID.
   *
   * @param [DeleteMacaroonIDRequest]
   * @returns [DeleteMacaroonIDResponse]
   *
   */
export async function deleteMacaroonID(request) {
  const message = create(lnrpc.DeleteMacaroonIDRequestSchema, request);
  const b64 = await TurboLnd.deleteMacaroonID(base64Encode(toBinary(lnrpc.DeleteMacaroonIDRequestSchema, message)));
  const response = fromBinary(lnrpc.DeleteMacaroonIDResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListPermissions lists all RPC method URIs and their required macaroon
   * permissions to access them.
   *
   * @param [ListPermissionsRequest]
   * @returns [ListPermissionsResponse]
   *
   */
export async function listPermissions(request) {
  const message = create(lnrpc.ListPermissionsRequestSchema, request);
  const b64 = await TurboLnd.listPermissions(base64Encode(toBinary(lnrpc.ListPermissionsRequestSchema, message)));
  const response = fromBinary(lnrpc.ListPermissionsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * CheckMacaroonPermissions checks whether a request follows the constraints
   * imposed on the macaroon and that the macaroon is authorized to follow the
   * provided permissions.
   *
   * @param [CheckMacPermRequest]
   * @returns [CheckMacPermResponse]
   *
   */
export async function checkMacaroonPermissions(request) {
  const message = create(lnrpc.CheckMacPermRequestSchema, request);
  const b64 = await TurboLnd.checkMacaroonPermissions(base64Encode(toBinary(lnrpc.CheckMacPermRequestSchema, message)));
  const response = fromBinary(lnrpc.CheckMacPermResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
   * gRPC middleware is software component external to lnd that aims to add
   * additional business logic to lnd by observing/intercepting/validating
   * incoming gRPC client requests and (if needed) replacing/overwriting outgoing
   * messages before they're sent to the client. When registering the middleware
   * must identify itself and indicate what custom macaroon caveats it wants to
   * be responsible for. Only requests that contain a macaroon with that specific
   * custom caveat are then sent to the middleware for inspection. The other
   * option is to register for the read-only mode in which all requests/responses
   * are forwarded for interception to the middleware but the middleware is not
   * allowed to modify any responses. As a security measure, _no_ middleware can
   * modify responses for requests made with _unencumbered_ macaroons!
   *
   * @param [RPCMiddlewareResponse]
   * @returns [RPCMiddlewareRequest]
   *
   */
export function registerRPCMiddleware(onResponse, onError) {
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.RPCMiddlewareRequestSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  const writeableStream = TurboLnd.registerRPCMiddleware(onResponseWrapper, onErrorWrapper);
  return {
    send: response => {
      const message = create(lnrpc.RPCMiddlewareResponseSchema, response);
      const responseB64 = base64Encode(toBinary(lnrpc.RPCMiddlewareResponseSchema, message));
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  };
}

/**
   *
   * SendCustomMessage sends a custom peer message.
   *
   * @param [SendCustomMessageRequest]
   * @returns [SendCustomMessageResponse]
   *
   */
export async function sendCustomMessage(request) {
  const message = create(lnrpc.SendCustomMessageRequestSchema, request);
  const b64 = await TurboLnd.sendCustomMessage(base64Encode(toBinary(lnrpc.SendCustomMessageRequestSchema, message)));
  const response = fromBinary(lnrpc.SendCustomMessageResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeCustomMessages subscribes to a stream of incoming custom peer
   * messages.
   *
   * To include messages with type outside of the custom range (>= 32768) lnd
   * needs to be compiled with  the `dev` build tag, and the message type to
   * override should be specified in lnd's experimental protocol configuration.
   *
   * @param [SubscribeCustomMessagesRequest]
   * @returns [CustomMessage]
   *
   */
export function subscribeCustomMessages(request, onResponse, onError) {
  const message = create(lnrpc.SubscribeCustomMessagesRequestSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.SubscribeCustomMessagesRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.CustomMessageSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeCustomMessages(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * ListAliases returns the set of all aliases that have ever existed with
   * their confirmed SCID (if it exists) and/or the base SCID (in the case of
   * zero conf).
   *
   * @param [ListAliasesRequest]
   * @returns [ListAliasesResponse]
   *
   */
export async function listAliases(request) {
  const message = create(lnrpc.ListAliasesRequestSchema, request);
  const b64 = await TurboLnd.listAliases(base64Encode(toBinary(lnrpc.ListAliasesRequestSchema, message)));
  const response = fromBinary(lnrpc.ListAliasesResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * If the replace_response field is set to true, this field must contain the
   * binary serialized gRPC message in the protobuf format.
   *
   * @param [LookupHtlcResolutionRequest]
   * @returns [LookupHtlcResolutionResponse]
   *
   */
export async function lookupHtlcResolution(request) {
  const message = create(lnrpc.LookupHtlcResolutionRequestSchema, request);
  const b64 = await TurboLnd.lookupHtlcResolution(base64Encode(toBinary(lnrpc.LookupHtlcResolutionRequestSchema, message)));
  const response = fromBinary(lnrpc.LookupHtlcResolutionResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GenSeed is the first method that should be used to instantiate a new lnd
   * instance. This method allows a caller to generate a new aezeed cipher seed
   * given an optional passphrase. If provided, the passphrase will be necessary
   * to decrypt the cipherseed to expose the internal wallet seed.
   *
   * Once the cipherseed is obtained and verified by the user, the InitWallet
   * method should be used to commit the newly generated seed, and create the
   * wallet.
   *
   * @param [GenSeedRequest]
   * @returns [GenSeedResponse]
   *
   */
export async function genSeed(request) {
  const message = create(lnrpc.GenSeedRequestSchema, request);
  const b64 = await TurboLnd.genSeed(base64Encode(toBinary(lnrpc.GenSeedRequestSchema, message)));
  const response = fromBinary(lnrpc.GenSeedResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * InitWallet is used when lnd is starting up for the first time to fully
   * initialize the daemon and its internal wallet. At the very least a wallet
   * password must be provided. This will be used to encrypt sensitive material
   * on disk.
   *
   * In the case of a recovery scenario, the user can also specify their aezeed
   * mnemonic and passphrase. If set, then the daemon will use this prior state
   * to initialize its internal wallet.
   *
   * Alternatively, this can be used along with the GenSeed RPC to obtain a
   * seed, then present it to the user. Once it has been verified by the user,
   * the seed can be fed into this RPC in order to commit the new wallet.
   *
   * @param [InitWalletRequest]
   * @returns [InitWalletResponse]
   *
   */
export async function initWallet(request) {
  const message = create(lnrpc.InitWalletRequestSchema, request);
  const b64 = await TurboLnd.initWallet(base64Encode(toBinary(lnrpc.InitWalletRequestSchema, message)));
  const response = fromBinary(lnrpc.InitWalletResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * UnlockWallet is used at startup of lnd to provide a password to unlock
   * the wallet database.
   *
   * @param [UnlockWalletRequest]
   * @returns [UnlockWalletResponse]
   *
   */
export async function unlockWallet(request) {
  const message = create(lnrpc.UnlockWalletRequestSchema, request);
  const b64 = await TurboLnd.unlockWallet(base64Encode(toBinary(lnrpc.UnlockWalletRequestSchema, message)));
  const response = fromBinary(lnrpc.UnlockWalletResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * The binary serialized admin macaroon that can be used to access the daemon
   * after rotating the macaroon root key. If both the stateless_init and
   * new_macaroon_root_key parameter were set to true, this is the ONLY copy of
   * the macaroon that was created from the new root key and MUST be stored
   * safely by the caller. Otherwise a copy of this macaroon is also persisted on
   * disk by the daemon, together with other macaroon files.
   *
   * @param [ChangePasswordRequest]
   * @returns [ChangePasswordResponse]
   *
   */
export async function changePassword(request) {
  const message = create(lnrpc.ChangePasswordRequestSchema, request);
  const b64 = await TurboLnd.changePassword(base64Encode(toBinary(lnrpc.ChangePasswordRequestSchema, message)));
  const response = fromBinary(lnrpc.ChangePasswordResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Comments in this file will be directly parsed into the API
   * Documentation as descriptions of the associated method, message, or field.
   * These descriptions should go right above the definition of the object, and
   * can be in either block or // comment format.
   *
   * An RPC method can be matched to an lncli command by placing a line in the
   * beginning of the description in exactly the following format:
   * lncli: `methodname`
   *
   * Failure to specify the exact name of the command will cause documentation
   * generation to fail.
   *
   * More information on how exactly the gRPC documentation is generated from
   * this proto file can be found here:
   * https://github.com/lightninglabs/lightning-api
   *
   * @param [SubscribeStateRequest]
   * @returns [SubscribeStateResponse]
   *
   */
export function subscribeState(request, onResponse, onError) {
  const message = create(lnrpc.SubscribeStateRequestSchema, request);
  const requestB64 = base64Encode(toBinary(lnrpc.SubscribeStateRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.SubscribeStateResponseSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.subscribeState(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   *
   * @param [GetStateRequest]
   * @returns [GetStateResponse]
   */
export async function getState(request) {
  const message = create(lnrpc.GetStateRequestSchema, request);
  const b64 = await TurboLnd.getState(base64Encode(toBinary(lnrpc.GetStateRequestSchema, message)));
  const response = fromBinary(lnrpc.GetStateResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Status returns the status of the light client neutrino instance,
   * along with height and hash of the best block, and a list of connected
   * peers.
   *
   * @param [StatusRequest]
   * @returns [StatusResponse]
   *
   */
export async function autopilotStatus(request) {
  const message = create(autopilotrpc.StatusRequestSchema, request);
  const b64 = await TurboLnd.autopilotStatus(base64Encode(toBinary(autopilotrpc.StatusRequestSchema, message)));
  const response = fromBinary(autopilotrpc.StatusResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ModifyStatus is used to modify the status of the autopilot agent, like
   * enabling or disabling it.
   *
   * @param [ModifyStatusRequest]
   * @returns [ModifyStatusResponse]
   *
   */
export async function autopilotModifyStatus(request) {
  const message = create(autopilotrpc.ModifyStatusRequestSchema, request);
  const b64 = await TurboLnd.autopilotModifyStatus(base64Encode(toBinary(autopilotrpc.ModifyStatusRequestSchema, message)));
  const response = fromBinary(autopilotrpc.ModifyStatusResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * QueryScores queries all available autopilot heuristics, in addition to any
   * active combination of these heruristics, for the scores they would give to
   * the given nodes.
   *
   * @param [QueryScoresRequest]
   * @returns [QueryScoresResponse]
   *
   */
export async function autopilotQueryScores(request) {
  const message = create(autopilotrpc.QueryScoresRequestSchema, request);
  const b64 = await TurboLnd.autopilotQueryScores(base64Encode(toBinary(autopilotrpc.QueryScoresRequestSchema, message)));
  const response = fromBinary(autopilotrpc.QueryScoresResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * A map from hex-encoded public keys to scores. Scores must be in the range
   * [0.0, 1.0].
   *
   * @param [SetScoresRequest]
   * @returns [SetScoresResponse]
   *
   */
export async function autopilotSetScores(request) {
  const message = create(autopilotrpc.SetScoresRequestSchema, request);
  const b64 = await TurboLnd.autopilotSetScores(base64Encode(toBinary(autopilotrpc.SetScoresRequestSchema, message)));
  const response = fromBinary(autopilotrpc.SetScoresResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * RegisterConfirmationsNtfn is a synchronous response-streaming RPC that
   * registers an intent for a client to be notified once a confirmation request
   * has reached its required number of confirmations on-chain.
   *
   * A confirmation request must have a valid output script. It is also possible
   * to give a transaction ID. If the transaction ID is not set, a notification
   * is sent once the output script confirms. If the transaction ID is also set,
   * a notification is sent once the output script confirms in the given
   * transaction.
   *
   * @param [ConfRequest]
   * @returns [ConfEvent]
   *
   */
export function chainNotifierRegisterConfirmationsNtfn(request, onResponse, onError) {
  const message = create(chainrpc.ConfRequestSchema, request);
  const requestB64 = base64Encode(toBinary(chainrpc.ConfRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(chainrpc.ConfEventSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.chainNotifierRegisterConfirmationsNtfn(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * RegisterSpendNtfn is a synchronous response-streaming RPC that registers an
   * intent for a client to be notification once a spend request has been spent
   * by a transaction that has confirmed on-chain.
   *
   * A client can specify whether the spend request should be for a particular
   * outpoint  or for an output script by specifying a zero outpoint.
   *
   * @param [SpendRequest]
   * @returns [SpendEvent]
   *
   */
export function chainNotifierRegisterSpendNtfn(request, onResponse, onError) {
  const message = create(chainrpc.SpendRequestSchema, request);
  const requestB64 = base64Encode(toBinary(chainrpc.SpendRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(chainrpc.SpendEventSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.chainNotifierRegisterSpendNtfn(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * An event sent when the spending transaction of the request was
   * reorged out of the chain.
   *
   * @param [BlockEpoch]
   * @returns [BlockEpoch]
   *
   */
export function chainNotifierRegisterBlockEpochNtfn(request, onResponse, onError) {
  const message = create(chainrpc.BlockEpochSchema, request);
  const requestB64 = base64Encode(toBinary(chainrpc.BlockEpochSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(chainrpc.BlockEpochSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.chainNotifierRegisterBlockEpochNtfn(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * SubscribeSingleInvoice returns a uni-directional stream (server -> client)
   * to notify the client of state transitions of the specified invoice.
   * Initially the current invoice state is always sent out.
   *
   * @param [SubscribeSingleInvoiceRequest]
   * @returns [Invoice]
   *
   */
export function invoicesSubscribeSingleInvoice(request, onResponse, onError) {
  const message = create(invoicesrpc.SubscribeSingleInvoiceRequestSchema, request);
  const requestB64 = base64Encode(toBinary(invoicesrpc.SubscribeSingleInvoiceRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.InvoiceSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.invoicesSubscribeSingleInvoice(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * CancelInvoice cancels a currently open invoice. If the invoice is already
   * canceled, this call will succeed. If the invoice is already settled, it will
   * fail.
   *
   * @param [CancelInvoiceMsg]
   * @returns [CancelInvoiceResp]
   *
   */
export async function invoicesCancelInvoice(request) {
  const message = create(invoicesrpc.CancelInvoiceMsgSchema, request);
  const b64 = await TurboLnd.invoicesCancelInvoice(base64Encode(toBinary(invoicesrpc.CancelInvoiceMsgSchema, message)));
  const response = fromBinary(invoicesrpc.CancelInvoiceRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * AddHoldInvoice creates a hold invoice. It ties the invoice to the hash
   * supplied in the request.
   *
   * @param [AddHoldInvoiceRequest]
   * @returns [AddHoldInvoiceResp]
   *
   */
export async function invoicesAddHoldInvoice(request) {
  const message = create(invoicesrpc.AddHoldInvoiceRequestSchema, request);
  const b64 = await TurboLnd.invoicesAddHoldInvoice(base64Encode(toBinary(invoicesrpc.AddHoldInvoiceRequestSchema, message)));
  const response = fromBinary(invoicesrpc.AddHoldInvoiceRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SettleInvoice settles an accepted invoice. If the invoice is already
   * settled, this call will succeed.
   *
   * @param [SettleInvoiceMsg]
   * @returns [SettleInvoiceResp]
   *
   */
export async function invoicesSettleInvoice(request) {
  const message = create(invoicesrpc.SettleInvoiceMsgSchema, request);
  const b64 = await TurboLnd.invoicesSettleInvoice(base64Encode(toBinary(invoicesrpc.SettleInvoiceMsgSchema, message)));
  const response = fromBinary(invoicesrpc.SettleInvoiceRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Indicates that when a look up is done using a payment_addr, then no HTLCs
   * related to the payment_addr should be returned. This is useful when one
   * wants to be able to obtain the set of associated setIDs with a given
   * invoice, then look up the sub-invoices "projected" by that set ID.
   *
   * @param [LookupInvoiceMsg]
   * @returns [Invoice]
   *
   */
export async function invoicesLookupInvoiceV2(request) {
  const message = create(invoicesrpc.LookupInvoiceMsgSchema, request);
  const b64 = await TurboLnd.invoicesLookupInvoiceV2(base64Encode(toBinary(invoicesrpc.LookupInvoiceMsgSchema, message)));
  const response = fromBinary(lnrpc.InvoiceSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Status returns the status of the light client neutrino instance,
   * along with height and hash of the best block, and a list of connected
   * peers.
   *
   * @param [StatusRequest]
   * @returns [StatusResponse]
   *
   */
export async function neutrinoKitStatus(request) {
  const message = create(neutrinorpc.StatusRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitStatus(base64Encode(toBinary(neutrinorpc.StatusRequestSchema, message)));
  const response = fromBinary(neutrinorpc.StatusResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * AddPeer adds a new peer that has already been connected to the server.
   *
   * @param [AddPeerRequest]
   * @returns [AddPeerResponse]
   *
   */
export async function neutrinoKitAddPeer(request) {
  const message = create(neutrinorpc.AddPeerRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitAddPeer(base64Encode(toBinary(neutrinorpc.AddPeerRequestSchema, message)));
  const response = fromBinary(neutrinorpc.AddPeerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DisconnectPeer disconnects a peer by target address. Both outbound and
   * inbound nodes will be searched for the target node. An error message will
   * be returned if the peer was not found.
   *
   * @param [DisconnectPeerRequest]
   * @returns [DisconnectPeerResponse]
   *
   */
export async function neutrinoKitDisconnectPeer(request) {
  const message = create(neutrinorpc.DisconnectPeerRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitDisconnectPeer(base64Encode(toBinary(neutrinorpc.DisconnectPeerRequestSchema, message)));
  const response = fromBinary(neutrinorpc.DisconnectPeerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * IsBanned returns true if the peer is banned, otherwise false.
   *
   * @param [IsBannedRequest]
   * @returns [IsBannedResponse]
   *
   */
export async function neutrinoKitIsBanned(request) {
  const message = create(neutrinorpc.IsBannedRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitIsBanned(base64Encode(toBinary(neutrinorpc.IsBannedRequestSchema, message)));
  const response = fromBinary(neutrinorpc.IsBannedResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetBlockHeader returns a block header with a particular block hash.
   *
   * @param [GetBlockHeaderRequest]
   * @returns [GetBlockHeaderResponse]
   *
   */
export async function neutrinoKitGetBlockHeader(request) {
  const message = create(neutrinorpc.GetBlockHeaderRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitGetBlockHeader(base64Encode(toBinary(neutrinorpc.GetBlockHeaderRequestSchema, message)));
  const response = fromBinary(neutrinorpc.GetBlockHeaderResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetBlock returns a block with a particular block hash.
   *
   * @param [GetBlockRequest]
   * @returns [GetBlockResponse]
   *
   */
export async function neutrinoKitGetBlock(request) {
  const message = create(neutrinorpc.GetBlockRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitGetBlock(base64Encode(toBinary(neutrinorpc.GetBlockRequestSchema, message)));
  const response = fromBinary(neutrinorpc.GetBlockResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetCFilter returns a compact filter from a block.
   *
   * @param [GetCFilterRequest]
   * @returns [GetCFilterResponse]
   *
   */
export async function neutrinoKitGetCFilter(request) {
  const message = create(neutrinorpc.GetCFilterRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitGetCFilter(base64Encode(toBinary(neutrinorpc.GetCFilterRequestSchema, message)));
  const response = fromBinary(neutrinorpc.GetCFilterResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Deprecated, use chainrpc.GetBlockHash instead.
   * GetBlockHash returns the header hash of a block at a given height.
   *
   * @param [GetBlockHashRequest]
   * @returns [GetBlockHashResponse]
   *
   */
export async function neutrinoKitGetBlockHash(request) {
  const message = create(neutrinorpc.GetBlockHashRequestSchema, request);
  const b64 = await TurboLnd.neutrinoKitGetBlockHash(base64Encode(toBinary(neutrinorpc.GetBlockHashRequestSchema, message)));
  const response = fromBinary(neutrinorpc.GetBlockHashResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SET_INVOICE_AMP identifies the features that should be advertised on
   * AMP invoices generated by the daemon.
   *
   * @param [NodeAnnouncementUpdateRequest]
   * @returns [NodeAnnouncementUpdateResponse]
   *
   */
export async function peersUpdateNodeAnnouncement(request) {
  const message = create(peersrpc.NodeAnnouncementUpdateRequestSchema, request);
  const b64 = await TurboLnd.peersUpdateNodeAnnouncement(base64Encode(toBinary(peersrpc.NodeAnnouncementUpdateRequestSchema, message)));
  const response = fromBinary(peersrpc.NodeAnnouncementUpdateResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SendPaymentV2 attempts to route a payment described by the passed
   * PaymentRequest to the final destination. The call returns a stream of
   * payment updates.
   *
   * @param [SendPaymentRequest]
   * @returns [Payment]
   *
   */
export function routerSendPaymentV2(request, onResponse, onError) {
  const message = create(routerrpc.SendPaymentRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.SendPaymentRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.PaymentSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerSendPaymentV2(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * TrackPaymentV2 returns an update stream for the payment identified by the
   * payment hash.
   *
   * @param [TrackPaymentRequest]
   * @returns [Payment]
   *
   */
export function routerTrackPaymentV2(request, onResponse, onError) {
  const message = create(routerrpc.TrackPaymentRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.TrackPaymentRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.PaymentSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerTrackPaymentV2(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * TrackPayments returns an update stream for every payment that is not in a
   * terminal state. Note that if payments are in-flight while starting a new
   * subscription, the start of the payment stream could produce out-of-order
   * and/or duplicate events. In order to get updates for every in-flight
   * payment attempt make sure to subscribe to this method before initiating any
   * payments.
   *
   * @param [TrackPaymentsRequest]
   * @returns [Payment]
   *
   */
export function routerTrackPayments(request, onResponse, onError) {
  const message = create(routerrpc.TrackPaymentsRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.TrackPaymentsRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(lnrpc.PaymentSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerTrackPayments(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * EstimateRouteFee allows callers to obtain a lower bound w.r.t how much it
   * may cost to send an HTLC to the target end destination.
   *
   * @param [RouteFeeRequest]
   * @returns [RouteFeeResponse]
   *
   */
export async function routerEstimateRouteFee(request) {
  const message = create(routerrpc.RouteFeeRequestSchema, request);
  const b64 = await TurboLnd.routerEstimateRouteFee(base64Encode(toBinary(routerrpc.RouteFeeRequestSchema, message)));
  const response = fromBinary(routerrpc.RouteFeeResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Deprecated, use SendToRouteV2. SendToRoute attempts to make a payment via
   * the specified route. This method differs from SendPayment in that it
   * allows users to specify a full route manually. This can be used for
   * things like rebalancing, and atomic swaps. It differs from the newer
   * SendToRouteV2 in that it doesn't return the full HTLC information.
   *
   * @param [SendToRouteRequest]
   * @returns [SendToRouteResponse]
   *
   */
export async function routerSendToRoute(request) {
  const message = create(routerrpc.SendToRouteRequestSchema, request);
  const b64 = await TurboLnd.routerSendToRoute(base64Encode(toBinary(routerrpc.SendToRouteRequestSchema, message)));
  const response = fromBinary(routerrpc.SendToRouteResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SendToRouteV2 attempts to make a payment via the specified route. This
   * method differs from SendPayment in that it allows users to specify a full
   * route manually. This can be used for things like rebalancing, and atomic
   * swaps.
   *
   * @param [SendToRouteRequest]
   * @returns [HTLCAttempt]
   *
   */
export async function routerSendToRouteV2(request) {
  const message = create(routerrpc.SendToRouteRequestSchema, request);
  const b64 = await TurboLnd.routerSendToRouteV2(base64Encode(toBinary(routerrpc.SendToRouteRequestSchema, message)));
  const response = fromBinary(lnrpc.HTLCAttemptSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ResetMissionControl clears all mission control state and starts with a clean
   * slate.
   *
   * @param [ResetMissionControlRequest]
   * @returns [ResetMissionControlResponse]
   *
   */
export async function routerResetMissionControl(request) {
  const message = create(routerrpc.ResetMissionControlRequestSchema, request);
  const b64 = await TurboLnd.routerResetMissionControl(base64Encode(toBinary(routerrpc.ResetMissionControlRequestSchema, message)));
  const response = fromBinary(routerrpc.ResetMissionControlResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * QueryMissionControl exposes the internal mission control state to callers.
   * It is a development feature.
   *
   * @param [QueryMissionControlRequest]
   * @returns [QueryMissionControlResponse]
   *
   */
export async function routerQueryMissionControl(request) {
  const message = create(routerrpc.QueryMissionControlRequestSchema, request);
  const b64 = await TurboLnd.routerQueryMissionControl(base64Encode(toBinary(routerrpc.QueryMissionControlRequestSchema, message)));
  const response = fromBinary(routerrpc.QueryMissionControlResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * XImportMissionControl is an experimental API that imports the state provided
   * to the internal mission control's state, using all results which are more
   * recent than our existing values. These values will only be imported
   * in-memory, and will not be persisted across restarts.
   *
   * @param [XImportMissionControlRequest]
   * @returns [XImportMissionControlResponse]
   *
   */
export async function routerXImportMissionControl(request) {
  const message = create(routerrpc.XImportMissionControlRequestSchema, request);
  const b64 = await TurboLnd.routerXImportMissionControl(base64Encode(toBinary(routerrpc.XImportMissionControlRequestSchema, message)));
  const response = fromBinary(routerrpc.XImportMissionControlResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetMissionControlConfig returns mission control's current config.
   *
   * @param [GetMissionControlConfigRequest]
   * @returns [GetMissionControlConfigResponse]
   *
   */
export async function routerGetMissionControlConfig(request) {
  const message = create(routerrpc.GetMissionControlConfigRequestSchema, request);
  const b64 = await TurboLnd.routerGetMissionControlConfig(base64Encode(toBinary(routerrpc.GetMissionControlConfigRequestSchema, message)));
  const response = fromBinary(routerrpc.GetMissionControlConfigResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SetMissionControlConfig will set mission control's config, if the config
   * provided is valid.
   *
   * @param [SetMissionControlConfigRequest]
   * @returns [SetMissionControlConfigResponse]
   *
   */
export async function routerSetMissionControlConfig(request) {
  const message = create(routerrpc.SetMissionControlConfigRequestSchema, request);
  const b64 = await TurboLnd.routerSetMissionControlConfig(base64Encode(toBinary(routerrpc.SetMissionControlConfigRequestSchema, message)));
  const response = fromBinary(routerrpc.SetMissionControlConfigResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * Deprecated. QueryProbability returns the current success probability
   * estimate for a given node pair and amount. The call returns a zero success
   * probability if no channel is available or if the amount violates min/max
   * HTLC constraints.
   *
   * @param [QueryProbabilityRequest]
   * @returns [QueryProbabilityResponse]
   *
   */
export async function routerQueryProbability(request) {
  const message = create(routerrpc.QueryProbabilityRequestSchema, request);
  const b64 = await TurboLnd.routerQueryProbability(base64Encode(toBinary(routerrpc.QueryProbabilityRequestSchema, message)));
  const response = fromBinary(routerrpc.QueryProbabilityResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * BuildRoute builds a fully specified route based on a list of hop public
   * keys. It retrieves the relevant channel policies from the graph in order to
   * calculate the correct fees and time locks.
   *
   * @param [BuildRouteRequest]
   * @returns [BuildRouteResponse]
   *
   */
export async function routerBuildRoute(request) {
  const message = create(routerrpc.BuildRouteRequestSchema, request);
  const b64 = await TurboLnd.routerBuildRoute(base64Encode(toBinary(routerrpc.BuildRouteRequestSchema, message)));
  const response = fromBinary(routerrpc.BuildRouteResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SubscribeHtlcEvents creates a uni-directional stream from the server to
   * the client which delivers a stream of htlc events.
   *
   * @param [SubscribeHtlcEventsRequest]
   * @returns [HtlcEvent]
   *
   */
export function routerSubscribeHtlcEvents(request, onResponse, onError) {
  const message = create(routerrpc.SubscribeHtlcEventsRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.SubscribeHtlcEventsRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(routerrpc.HtlcEventSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerSubscribeHtlcEvents(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * Deprecated, use SendPaymentV2. SendPayment attempts to route a payment
   * described by the passed PaymentRequest to the final destination. The call
   * returns a stream of payment status updates.
   *
   * @param [SendPaymentRequest]
   * @returns [PaymentStatus]
   *
   */
export function routerSendPayment(request, onResponse, onError) {
  const message = create(routerrpc.SendPaymentRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.SendPaymentRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(routerrpc.PaymentStatusSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerSendPayment(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * Deprecated, use TrackPaymentV2. TrackPayment returns an update stream for
   * the payment identified by the payment hash.
   *
   * @param [TrackPaymentRequest]
   * @returns [PaymentStatus]
   *
   */
export function routerTrackPayment(request, onResponse, onError) {
  const message = create(routerrpc.TrackPaymentRequestSchema, request);
  const requestB64 = base64Encode(toBinary(routerrpc.TrackPaymentRequestSchema, message));
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(routerrpc.PaymentStatusSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  return TurboLnd.routerTrackPayment(requestB64, onResponseWrapper, onErrorWrapper);
}

/**
   *
   * HtlcInterceptor dispatches a bi-directional streaming RPC in which
   * Forwarded HTLC requests are sent to the client and the client responds with
   * a boolean that tells LND if this htlc should be intercepted.
   * In case of interception, the htlc can be either settled, cancelled or
   * resumed later by using the ResolveHoldForward endpoint.
   *
   * @param [ForwardHtlcInterceptResponse]
   * @returns [ForwardHtlcInterceptRequest]
   *
   */
export function routerHtlcInterceptor(onResponse, onError) {
  const onResponseWrapper = responseB64 => {
    onResponse(fromBinary(routerrpc.ForwardHtlcInterceptRequestSchema, base64Decode(responseB64)));
  };
  const onErrorWrapper = error => onError(error);
  const writeableStream = TurboLnd.routerHtlcInterceptor(onResponseWrapper, onErrorWrapper);
  return {
    send: response => {
      const message = create(routerrpc.ForwardHtlcInterceptResponseSchema, response);
      const responseB64 = base64Encode(toBinary(routerrpc.ForwardHtlcInterceptResponseSchema, message));
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  };
}

/**
   *
   * The key of this forwarded htlc. It defines the incoming channel id and
   * the index in this channel.
   *
   * @param [UpdateChanStatusRequest]
   * @returns [UpdateChanStatusResponse]
   *
   */
export async function routerUpdateChanStatus(request) {
  const message = create(routerrpc.UpdateChanStatusRequestSchema, request);
  const b64 = await TurboLnd.routerUpdateChanStatus(base64Encode(toBinary(routerrpc.UpdateChanStatusRequestSchema, message)));
  const response = fromBinary(routerrpc.UpdateChanStatusResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SignOutputRaw is a method that can be used to generated a signature for a
   * set of inputs/outputs to a transaction. Each request specifies details
   * concerning how the outputs should be signed, which keys they should be
   * signed with, and also any optional tweaks. The return value is a fixed
   * 64-byte signature (the same format as we use on the wire in Lightning).
   *
   * If we are  unable to sign using the specified keys, then an error will be
   * returned.
   *
   * @param [SignReq]
   * @returns [SignResp]
   *
   */
export async function signerSignOutputRaw(request) {
  const message = create(signrpc.SignReqSchema, request);
  const b64 = await TurboLnd.signerSignOutputRaw(base64Encode(toBinary(signrpc.SignReqSchema, message)));
  const response = fromBinary(signrpc.SignRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ComputeInputScript generates a complete InputIndex for the passed
   * transaction with the signature as defined within the passed SignDescriptor.
   * This method should be capable of generating the proper input script for both
   * regular p2wkh/p2tr outputs and p2wkh outputs nested within a regular p2sh
   * output.
   *
   * Note that when using this method to sign inputs belonging to the wallet,
   * the only items of the SignDescriptor that need to be populated are pkScript
   * in the TxOut field, the value in that same field, and finally the input
   * index.
   *
   * @param [SignReq]
   * @returns [InputScriptResp]
   *
   */
export async function signerComputeInputScript(request) {
  const message = create(signrpc.SignReqSchema, request);
  const b64 = await TurboLnd.signerComputeInputScript(base64Encode(toBinary(signrpc.SignReqSchema, message)));
  const response = fromBinary(signrpc.InputScriptRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SignMessage signs a message with the key specified in the key locator. The
   * returned signature is fixed-size LN wire format encoded.
   *
   * The main difference to SignMessage in the main RPC is that a specific key is
   * used to sign the message instead of the node identity private key.
   *
   * @param [SignMessageReq]
   * @returns [SignMessageResp]
   *
   */
export async function signerSignMessage(request) {
  const message = create(signrpc.SignMessageReqSchema, request);
  const b64 = await TurboLnd.signerSignMessage(base64Encode(toBinary(signrpc.SignMessageReqSchema, message)));
  const response = fromBinary(signrpc.SignMessageRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * VerifyMessage verifies a signature over a message using the public key
   * provided. The signature must be fixed-size LN wire format encoded.
   *
   * The main difference to VerifyMessage in the main RPC is that the public key
   * used to sign the message does not have to be a node known to the network.
   *
   * @param [VerifyMessageReq]
   * @returns [VerifyMessageResp]
   *
   */
export async function signerVerifyMessage(request) {
  const message = create(signrpc.VerifyMessageReqSchema, request);
  const b64 = await TurboLnd.signerVerifyMessage(base64Encode(toBinary(signrpc.VerifyMessageReqSchema, message)));
  const response = fromBinary(signrpc.VerifyMessageRespSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeriveSharedKey returns a shared secret key by performing Diffie-Hellman key
   * derivation between the ephemeral public key in the request and the node's
   * key specified in the key_desc parameter. Either a key locator or a raw
   * public key is expected in the key_desc, if neither is supplied, defaults to
   * the node's identity private key:
   * P_shared = privKeyNode * ephemeralPubkey
   * The resulting shared public key is serialized in the compressed format and
   * hashed with sha256, resulting in the final key length of 256bit.
   *
   * @param [SharedKeyRequest]
   * @returns [SharedKeyResponse]
   *
   */
export async function signerDeriveSharedKey(request) {
  const message = create(signrpc.SharedKeyRequestSchema, request);
  const b64 = await TurboLnd.signerDeriveSharedKey(base64Encode(toBinary(signrpc.SharedKeyRequestSchema, message)));
  const response = fromBinary(signrpc.SharedKeyResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * MuSig2CombineKeys (experimental!) is a stateless helper RPC that can be used
   * to calculate the combined MuSig2 public key from a list of all participating
   * signers' public keys. This RPC is completely stateless and deterministic and
   * does not create any signing session. It can be used to determine the Taproot
   * public key that should be put in an on-chain output once all public keys are
   * known. A signing session is only needed later when that output should be
   * _spent_ again.
   *
   * NOTE: The MuSig2 BIP is not final yet and therefore this API must be
   * considered to be HIGHLY EXPERIMENTAL and subject to change in upcoming
   * releases. Backward compatibility is not guaranteed!
   *
   * @param [MuSig2CombineKeysRequest]
   * @returns [MuSig2CombineKeysResponse]
   *
   */
export async function signerMuSig2CombineKeys(request) {
  const message = create(signrpc.MuSig2CombineKeysRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2CombineKeys(base64Encode(toBinary(signrpc.MuSig2CombineKeysRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2CombineKeysResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * MuSig2CreateSession (experimental!) creates a new MuSig2 signing session
   * using the local key identified by the key locator. The complete list of all
   * public keys of all signing parties must be provided, including the public
   * key of the local signing key. If nonces of other parties are already known,
   * they can be submitted as well to reduce the number of RPC calls necessary
   * later on.
   *
   * NOTE: The MuSig2 BIP is not final yet and therefore this API must be
   * considered to be HIGHLY EXPERIMENTAL and subject to change in upcoming
   * releases. Backward compatibility is not guaranteed!
   *
   * @param [MuSig2SessionRequest]
   * @returns [MuSig2SessionResponse]
   *
   */
export async function signerMuSig2CreateSession(request) {
  const message = create(signrpc.MuSig2SessionRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2CreateSession(base64Encode(toBinary(signrpc.MuSig2SessionRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2SessionResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * MuSig2RegisterNonces (experimental!) registers one or more public nonces of
   * other signing participants for a session identified by its ID. This RPC can
   * be called multiple times until all nonces are registered.
   *
   * NOTE: The MuSig2 BIP is not final yet and therefore this API must be
   * considered to be HIGHLY EXPERIMENTAL and subject to change in upcoming
   * releases. Backward compatibility is not guaranteed!
   *
   * @param [MuSig2RegisterNoncesRequest]
   * @returns [MuSig2RegisterNoncesResponse]
   *
   */
export async function signerMuSig2RegisterNonces(request) {
  const message = create(signrpc.MuSig2RegisterNoncesRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2RegisterNonces(base64Encode(toBinary(signrpc.MuSig2RegisterNoncesRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2RegisterNoncesResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * MuSig2Sign (experimental!) creates a partial signature using the local
   * signing key that was specified when the session was created. This can only
   * be called when all public nonces of all participants are known and have been
   * registered with the session. If this node isn't responsible for combining
   * all the partial signatures, then the cleanup flag should be set, indicating
   * that the session can be removed from memory once the signature was produced.
   *
   * NOTE: The MuSig2 BIP is not final yet and therefore this API must be
   * considered to be HIGHLY EXPERIMENTAL and subject to change in upcoming
   * releases. Backward compatibility is not guaranteed!
   *
   * @param [MuSig2SignRequest]
   * @returns [MuSig2SignResponse]
   *
   */
export async function signerMuSig2Sign(request) {
  const message = create(signrpc.MuSig2SignRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2Sign(base64Encode(toBinary(signrpc.MuSig2SignRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2SignResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * MuSig2CombineSig (experimental!) combines the given partial signature(s)
   * with the local one, if it already exists. Once a partial signature of all
   * participants is registered, the final signature will be combined and
   * returned.
   *
   * NOTE: The MuSig2 BIP is not final yet and therefore this API must be
   * considered to be HIGHLY EXPERIMENTAL and subject to change in upcoming
   * releases. Backward compatibility is not guaranteed!
   *
   * @param [MuSig2CombineSigRequest]
   * @returns [MuSig2CombineSigResponse]
   *
   */
export async function signerMuSig2CombineSig(request) {
  const message = create(signrpc.MuSig2CombineSigRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2CombineSig(base64Encode(toBinary(signrpc.MuSig2CombineSigRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2CombineSigResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * The unique ID of the signing session that should be removed/cleaned up.
   *
   * @param [MuSig2CleanupRequest]
   * @returns [MuSig2CleanupResponse]
   *
   */
export async function signerMuSig2Cleanup(request) {
  const message = create(signrpc.MuSig2CleanupRequestSchema, request);
  const b64 = await TurboLnd.signerMuSig2Cleanup(base64Encode(toBinary(signrpc.MuSig2CleanupRequestSchema, message)));
  const response = fromBinary(signrpc.MuSig2CleanupResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetVersion returns the current version and build information of the running
   * daemon.
   *
   * @param [VersionRequest]
   * @returns [Version]
   *
   */
export async function versionerGetVersion(request) {
  const message = create(verrpc.VersionRequestSchema, request);
  const b64 = await TurboLnd.versionerGetVersion(base64Encode(toBinary(verrpc.VersionRequestSchema, message)));
  const response = fromBinary(verrpc.VersionSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListUnspent returns a list of all utxos spendable by the wallet with a
   * number of confirmations between the specified minimum and maximum. By
   * default, all utxos are listed. To list only the unconfirmed utxos, set
   * the unconfirmed_only to true.
   *
   * @param [ListUnspentRequest]
   * @returns [ListUnspentResponse]
   *
   */
export async function walletKitListUnspent(request) {
  const message = create(walletrpc.ListUnspentRequestSchema, request);
  const b64 = await TurboLnd.walletKitListUnspent(base64Encode(toBinary(walletrpc.ListUnspentRequestSchema, message)));
  const response = fromBinary(walletrpc.ListUnspentResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * LeaseOutput locks an output to the given ID, preventing it from being
   * available for any future coin selection attempts. The absolute time of the
   * lock's expiration is returned. The expiration of the lock can be extended by
   * successive invocations of this RPC. Outputs can be unlocked before their
   * expiration through `ReleaseOutput`.
   *
   * @param [LeaseOutputRequest]
   * @returns [LeaseOutputResponse]
   *
   */
export async function walletKitLeaseOutput(request) {
  const message = create(walletrpc.LeaseOutputRequestSchema, request);
  const b64 = await TurboLnd.walletKitLeaseOutput(base64Encode(toBinary(walletrpc.LeaseOutputRequestSchema, message)));
  const response = fromBinary(walletrpc.LeaseOutputResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ReleaseOutput unlocks an output, allowing it to be available for coin
   * selection if it remains unspent. The ID should match the one used to
   * originally lock the output.
   *
   * @param [ReleaseOutputRequest]
   * @returns [ReleaseOutputResponse]
   *
   */
export async function walletKitReleaseOutput(request) {
  const message = create(walletrpc.ReleaseOutputRequestSchema, request);
  const b64 = await TurboLnd.walletKitReleaseOutput(base64Encode(toBinary(walletrpc.ReleaseOutputRequestSchema, message)));
  const response = fromBinary(walletrpc.ReleaseOutputResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListLeases lists all currently locked utxos.
   *
   * @param [ListLeasesRequest]
   * @returns [ListLeasesResponse]
   *
   */
export async function walletKitListLeases(request) {
  const message = create(walletrpc.ListLeasesRequestSchema, request);
  const b64 = await TurboLnd.walletKitListLeases(base64Encode(toBinary(walletrpc.ListLeasesRequestSchema, message)));
  const response = fromBinary(walletrpc.ListLeasesResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeriveNextKey attempts to derive the *next* key within the key family
   * (account in BIP43) specified. This method should return the next external
   * child within this branch.
   *
   * @param [KeyReq]
   * @returns [KeyDescriptor]
   *
   */
export async function walletKitDeriveNextKey(request) {
  const message = create(walletrpc.KeyReqSchema, request);
  const b64 = await TurboLnd.walletKitDeriveNextKey(base64Encode(toBinary(walletrpc.KeyReqSchema, message)));
  const response = fromBinary(signrpc.KeyDescriptorSchema, base64Decode(b64));
  return response;
}

/**
   *
   * DeriveKey attempts to derive an arbitrary key specified by the passed
   * KeyLocator.
   *
   * @param [KeyLocator]
   * @returns [KeyDescriptor]
   *
   */
export async function walletKitDeriveKey(request) {
  const message = create(signrpc.KeyLocatorSchema, request);
  const b64 = await TurboLnd.walletKitDeriveKey(base64Encode(toBinary(signrpc.KeyLocatorSchema, message)));
  const response = fromBinary(signrpc.KeyDescriptorSchema, base64Decode(b64));
  return response;
}

/**
   *
   * NextAddr returns the next unused address within the wallet.
   *
   * @param [AddrRequest]
   * @returns [AddrResponse]
   *
   */
export async function walletKitNextAddr(request) {
  const message = create(walletrpc.AddrRequestSchema, request);
  const b64 = await TurboLnd.walletKitNextAddr(base64Encode(toBinary(walletrpc.AddrRequestSchema, message)));
  const response = fromBinary(walletrpc.AddrResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListAccounts retrieves all accounts belonging to the wallet by default. A
   * name and key scope filter can be provided to filter through all of the
   * wallet accounts and return only those matching.
   *
   * @param [ListAccountsRequest]
   * @returns [ListAccountsResponse]
   *
   */
export async function walletKitListAccounts(request) {
  const message = create(walletrpc.ListAccountsRequestSchema, request);
  const b64 = await TurboLnd.walletKitListAccounts(base64Encode(toBinary(walletrpc.ListAccountsRequestSchema, message)));
  const response = fromBinary(walletrpc.ListAccountsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * RequiredReserve returns the minimum amount of satoshis that should be kept
   * in the wallet in order to fee bump anchor channels if necessary. The value
   * scales with the number of public anchor channels but is capped at a maximum.
   *
   * @param [RequiredReserveRequest]
   * @returns [RequiredReserveResponse]
   *
   */
export async function walletKitRequiredReserve(request) {
  const message = create(walletrpc.RequiredReserveRequestSchema, request);
  const b64 = await TurboLnd.walletKitRequiredReserve(base64Encode(toBinary(walletrpc.RequiredReserveRequestSchema, message)));
  const response = fromBinary(walletrpc.RequiredReserveResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListAddresses retrieves all the addresses along with their balance. An
   * account name filter can be provided to filter through all of the
   * wallet accounts and return the addresses of only those matching.
   *
   * @param [ListAddressesRequest]
   * @returns [ListAddressesResponse]
   *
   */
export async function walletKitListAddresses(request) {
  const message = create(walletrpc.ListAddressesRequestSchema, request);
  const b64 = await TurboLnd.walletKitListAddresses(base64Encode(toBinary(walletrpc.ListAddressesRequestSchema, message)));
  const response = fromBinary(walletrpc.ListAddressesResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SignMessageWithAddr returns the compact signature (base64 encoded) created
   * with the private key of the provided address. This requires the address
   * to be solely based on a public key lock (no scripts). Obviously the internal
   * lnd wallet has to possess the private key of the address otherwise
   * an error is returned.
   *
   * This method aims to provide full compatibility with the bitcoin-core and
   * btcd implementation. Bitcoin-core's algorithm is not specified in a
   * BIP and only applicable for legacy addresses. This method enhances the
   * signing for additional address types: P2WKH, NP2WKH, P2TR.
   * For P2TR addresses this represents a special case. ECDSA is used to create
   * a compact signature which makes the public key of the signature recoverable.
   *
   * @param [SignMessageWithAddrRequest]
   * @returns [SignMessageWithAddrResponse]
   *
   */
export async function walletKitSignMessageWithAddr(request) {
  const message = create(walletrpc.SignMessageWithAddrRequestSchema, request);
  const b64 = await TurboLnd.walletKitSignMessageWithAddr(base64Encode(toBinary(walletrpc.SignMessageWithAddrRequestSchema, message)));
  const response = fromBinary(walletrpc.SignMessageWithAddrResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * VerifyMessageWithAddr returns the validity and the recovered public key of
   * the provided compact signature (base64 encoded). The verification is
   * twofold. First the validity of the signature itself is checked and then
   * it is verified that the recovered public key of the signature equals
   * the public key of the provided address. There is no dependence on the
   * private key of the address therefore also external addresses are allowed
   * to verify signatures.
   * Supported address types are P2PKH, P2WKH, NP2WKH, P2TR.
   *
   * This method is the counterpart of the related signing method
   * (SignMessageWithAddr) and aims to provide full compatibility to
   * bitcoin-core's implementation. Although bitcoin-core/btcd only provide
   * this functionality for legacy addresses this function enhances it to
   * the address types: P2PKH, P2WKH, NP2WKH, P2TR.
   *
   * The verification for P2TR addresses is a special case and requires the
   * ECDSA compact signature to compare the reovered public key to the internal
   * taproot key. The compact ECDSA signature format was used because there
   * are still no known compact signature schemes for schnorr signatures.
   *
   * @param [VerifyMessageWithAddrRequest]
   * @returns [VerifyMessageWithAddrResponse]
   *
   */
export async function walletKitVerifyMessageWithAddr(request) {
  const message = create(walletrpc.VerifyMessageWithAddrRequestSchema, request);
  const b64 = await TurboLnd.walletKitVerifyMessageWithAddr(base64Encode(toBinary(walletrpc.VerifyMessageWithAddrRequestSchema, message)));
  const response = fromBinary(walletrpc.VerifyMessageWithAddrResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ImportAccount imports an account backed by an account extended public key.
   * The master key fingerprint denotes the fingerprint of the root key
   * corresponding to the account public key (also known as the key with
   * derivation path m/). This may be required by some hardware wallets for
   * proper identification and signing.
   *
   * The address type can usually be inferred from the key's version, but may be
   * required for certain keys to map them into the proper scope.
   *
   * For BIP-0044 keys, an address type must be specified as we intend to not
   * support importing BIP-0044 keys into the wallet using the legacy
   * pay-to-pubkey-hash (P2PKH) scheme. A nested witness address type will force
   * the standard BIP-0049 derivation scheme, while a witness address type will
   * force the standard BIP-0084 derivation scheme.
   *
   * For BIP-0049 keys, an address type must also be specified to make a
   * distinction between the standard BIP-0049 address schema (nested witness
   * pubkeys everywhere) and our own BIP-0049Plus address schema (nested pubkeys
   * externally, witness pubkeys internally).
   *
   * NOTE: Events (deposits/spends) for keys derived from an account will only be
   * detected by lnd if they happen after the import. Rescans to detect past
   * events will be supported later on.
   *
   * @param [ImportAccountRequest]
   * @returns [ImportAccountResponse]
   *
   */
export async function walletKitImportAccount(request) {
  const message = create(walletrpc.ImportAccountRequestSchema, request);
  const b64 = await TurboLnd.walletKitImportAccount(base64Encode(toBinary(walletrpc.ImportAccountRequestSchema, message)));
  const response = fromBinary(walletrpc.ImportAccountResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ImportPublicKey imports a public key as watch-only into the wallet. The
   * public key is converted into a simple address of the given type and that
   * address script is watched on chain. For Taproot keys, this will only watch
   * the BIP-0086 style output script. Use ImportTapscript for more advanced key
   * spend or script spend outputs.
   *
   * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
   * they happen after the import. Rescans to detect past events will be
   * supported later on.
   *
   * @param [ImportPublicKeyRequest]
   * @returns [ImportPublicKeyResponse]
   *
   */
export async function walletKitImportPublicKey(request) {
  const message = create(walletrpc.ImportPublicKeyRequestSchema, request);
  const b64 = await TurboLnd.walletKitImportPublicKey(base64Encode(toBinary(walletrpc.ImportPublicKeyRequestSchema, message)));
  const response = fromBinary(walletrpc.ImportPublicKeyResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ImportTapscript imports a Taproot script and internal key and adds the
   * resulting Taproot output key as a watch-only output script into the wallet.
   * For BIP-0086 style Taproot keys (no root hash commitment and no script spend
   * path) use ImportPublicKey.
   *
   * NOTE: Events (deposits/spends) for a key will only be detected by lnd if
   * they happen after the import. Rescans to detect past events will be
   * supported later on.
   *
   * NOTE: Taproot keys imported through this RPC currently _cannot_ be used for
   * funding PSBTs. Only tracking the balance and UTXOs is currently supported.
   *
   * @param [ImportTapscriptRequest]
   * @returns [ImportTapscriptResponse]
   *
   */
export async function walletKitImportTapscript(request) {
  const message = create(walletrpc.ImportTapscriptRequestSchema, request);
  const b64 = await TurboLnd.walletKitImportTapscript(base64Encode(toBinary(walletrpc.ImportTapscriptRequestSchema, message)));
  const response = fromBinary(walletrpc.ImportTapscriptResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * PublishTransaction attempts to publish the passed transaction to the
   * network. Once this returns without an error, the wallet will continually
   * attempt to re-broadcast the transaction on start up, until it enters the
   * chain.
   *
   * @param [Transaction]
   * @returns [PublishResponse]
   *
   */
export async function walletKitPublishTransaction(request) {
  const message = create(walletrpc.TransactionSchema, request);
  const b64 = await TurboLnd.walletKitPublishTransaction(base64Encode(toBinary(walletrpc.TransactionSchema, message)));
  const response = fromBinary(walletrpc.PublishResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SendOutputs is similar to the existing sendmany call in Bitcoind, and
   * allows the caller to create a transaction that sends to several outputs at
   * once. This is ideal when wanting to batch create a set of transactions.
   *
   * @param [SendOutputsRequest]
   * @returns [SendOutputsResponse]
   *
   */
export async function walletKitSendOutputs(request) {
  const message = create(walletrpc.SendOutputsRequestSchema, request);
  const b64 = await TurboLnd.walletKitSendOutputs(base64Encode(toBinary(walletrpc.SendOutputsRequestSchema, message)));
  const response = fromBinary(walletrpc.SendOutputsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * EstimateFee attempts to query the internal fee estimator of the wallet to
   * determine the fee (in sat/kw) to attach to a transaction in order to
   * achieve the confirmation target.
   *
   * @param [EstimateFeeRequest]
   * @returns [EstimateFeeResponse]
   *
   */
export async function walletKitEstimateFee(request) {
  const message = create(walletrpc.EstimateFeeRequestSchema, request);
  const b64 = await TurboLnd.walletKitEstimateFee(base64Encode(toBinary(walletrpc.EstimateFeeRequestSchema, message)));
  const response = fromBinary(walletrpc.EstimateFeeResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * PendingSweeps returns lists of on-chain outputs that lnd is currently
   * attempting to sweep within its central batching engine. Outputs with similar
   * fee rates are batched together in order to sweep them within a single
   * transaction.
   *
   * NOTE: Some of the fields within PendingSweepsRequest are not guaranteed to
   * remain supported. This is an advanced API that depends on the internals of
   * the UtxoSweeper, so things may change.
   *
   * @param [PendingSweepsRequest]
   * @returns [PendingSweepsResponse]
   *
   */
export async function walletKitPendingSweeps(request) {
  const message = create(walletrpc.PendingSweepsRequestSchema, request);
  const b64 = await TurboLnd.walletKitPendingSweeps(base64Encode(toBinary(walletrpc.PendingSweepsRequestSchema, message)));
  const response = fromBinary(walletrpc.PendingSweepsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * BumpFee bumps the fee of an arbitrary input within a transaction. This RPC
   * takes a different approach than bitcoind's bumpfee command. lnd has a
   * central batching engine in which inputs with similar fee rates are batched
   * together to save on transaction fees. Due to this, we cannot rely on
   * bumping the fee on a specific transaction, since transactions can change at
   * any point with the addition of new inputs. The list of inputs that
   * currently exist within lnd's central batching engine can be retrieved
   * through the PendingSweeps RPC.
   *
   * When bumping the fee of an input that currently exists within lnd's central
   * batching engine, a higher fee transaction will be created that replaces the
   * lower fee transaction through the Replace-By-Fee (RBF) policy. If it
   *
   * This RPC also serves useful when wanting to perform a Child-Pays-For-Parent
   * (CPFP), where the child transaction pays for its parent's fee. This can be
   * done by specifying an outpoint within the low fee transaction that is under
   * the control of the wallet.
   *
   * The fee preference can be expressed either as a specific fee rate or a delta
   * of blocks in which the output should be swept on-chain within. If a fee
   * preference is not explicitly specified, then an error is returned.
   *
   * Note that this RPC currently doesn't perform any validation checks on the
   * fee preference being provided. For now, the responsibility of ensuring that
   * the new fee preference is sufficient is delegated to the user.
   *
   * @param [BumpFeeRequest]
   * @returns [BumpFeeResponse]
   *
   */
export async function walletKitBumpFee(request) {
  const message = create(walletrpc.BumpFeeRequestSchema, request);
  const b64 = await TurboLnd.walletKitBumpFee(base64Encode(toBinary(walletrpc.BumpFeeRequestSchema, message)));
  const response = fromBinary(walletrpc.BumpFeeResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * ListSweeps returns a list of the sweep transactions our node has produced.
   * Note that these sweeps may not be confirmed yet, as we record sweeps on
   * broadcast, not confirmation.
   *
   * @param [ListSweepsRequest]
   * @returns [ListSweepsResponse]
   *
   */
export async function walletKitListSweeps(request) {
  const message = create(walletrpc.ListSweepsRequestSchema, request);
  const b64 = await TurboLnd.walletKitListSweeps(base64Encode(toBinary(walletrpc.ListSweepsRequestSchema, message)));
  const response = fromBinary(walletrpc.ListSweepsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * LabelTransaction adds a label to a transaction. If the transaction already
   * has a label the call will fail unless the overwrite bool is set. This will
   * overwrite the exiting transaction label. Labels must not be empty, and
   * cannot exceed 500 characters.
   *
   * @param [LabelTransactionRequest]
   * @returns [LabelTransactionResponse]
   *
   */
export async function walletKitLabelTransaction(request) {
  const message = create(walletrpc.LabelTransactionRequestSchema, request);
  const b64 = await TurboLnd.walletKitLabelTransaction(base64Encode(toBinary(walletrpc.LabelTransactionRequestSchema, message)));
  const response = fromBinary(walletrpc.LabelTransactionResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * FundPsbt creates a fully populated PSBT that contains enough inputs to fund
   * the outputs specified in the template. There are two ways of specifying a
   * template: Either by passing in a PSBT with at least one output declared or
   * by passing in a raw TxTemplate message.
   *
   * If there are no inputs specified in the template, coin selection is
   * performed automatically. If the template does contain any inputs, it is
   * assumed that full coin selection happened externally and no additional
   * inputs are added. If the specified inputs aren't enough to fund the outputs
   * with the given fee rate, an error is returned.
   *
   * After either selecting or verifying the inputs, all input UTXOs are locked
   * with an internal app ID.
   *
   * NOTE: If this method returns without an error, it is the caller's
   * responsibility to either spend the locked UTXOs (by finalizing and then
   * publishing the transaction) or to unlock/release the locked UTXOs in case of
   * an error on the caller's side.
   *
   * @param [FundPsbtRequest]
   * @returns [FundPsbtResponse]
   *
   */
export async function walletKitFundPsbt(request) {
  const message = create(walletrpc.FundPsbtRequestSchema, request);
  const b64 = await TurboLnd.walletKitFundPsbt(base64Encode(toBinary(walletrpc.FundPsbtRequestSchema, message)));
  const response = fromBinary(walletrpc.FundPsbtResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * SignPsbt expects a partial transaction with all inputs and outputs fully
   * declared and tries to sign all unsigned inputs that have all required fields
   * (UTXO information, BIP32 derivation information, witness or sig scripts)
   * set.
   * If no error is returned, the PSBT is ready to be given to the next signer or
   * to be finalized if lnd was the last signer.
   *
   * NOTE: This RPC only signs inputs (and only those it can sign), it does not
   * perform any other tasks (such as coin selection, UTXO locking or
   * input/output/fee value validation, PSBT finalization). Any input that is
   * incomplete will be skipped.
   *
   * @param [SignPsbtRequest]
   * @returns [SignPsbtResponse]
   *
   */
export async function walletKitSignPsbt(request) {
  const message = create(walletrpc.SignPsbtRequestSchema, request);
  const b64 = await TurboLnd.walletKitSignPsbt(base64Encode(toBinary(walletrpc.SignPsbtRequestSchema, message)));
  const response = fromBinary(walletrpc.SignPsbtResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * The name of the account to finalize the PSBT with. If empty, the default
   * wallet account is used.
   *
   * @param [FinalizePsbtRequest]
   * @returns [FinalizePsbtResponse]
   *
   */
export async function walletKitFinalizePsbt(request) {
  const message = create(walletrpc.FinalizePsbtRequestSchema, request);
  const b64 = await TurboLnd.walletKitFinalizePsbt(base64Encode(toBinary(walletrpc.FinalizePsbtRequestSchema, message)));
  const response = fromBinary(walletrpc.FinalizePsbtResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * GetInfo returns general information concerning the companion watchtower
   * including its public key and URIs where the server is currently
   * listening for clients.
   *
   * @param [GetInfoRequest]
   * @returns [GetInfoResponse]
   *
   */
export async function watchtowerGetInfo(request) {
  const message = create(watchtowerrpc.GetInfoRequestSchema, request);
  const b64 = await TurboLnd.watchtowerGetInfo(base64Encode(toBinary(watchtowerrpc.GetInfoRequestSchema, message)));
  const response = fromBinary(watchtowerrpc.GetInfoResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * AddTower adds a new watchtower reachable at the given address and
   * considers it for new sessions. If the watchtower already exists, then
   * any new addresses included will be considered when dialing it for
   * session negotiations and backups.
   *
   * @param [AddTowerRequest]
   * @returns [AddTowerResponse]
   *
   */
export async function watchtowerClientAddTower(request) {
  const message = create(wtclientrpc.AddTowerRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientAddTower(base64Encode(toBinary(wtclientrpc.AddTowerRequestSchema, message)));
  const response = fromBinary(wtclientrpc.AddTowerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   * The fee rate, in satoshis per vbyte, that will be used by watchtowers for
   * justice transactions in response to channel breaches.
   *
   * @param [RemoveTowerRequest]
   * @returns [RemoveTowerResponse]
   *
   */
export async function watchtowerClientRemoveTower(request) {
  const message = create(wtclientrpc.RemoveTowerRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientRemoveTower(base64Encode(toBinary(wtclientrpc.RemoveTowerRequestSchema, message)));
  const response = fromBinary(wtclientrpc.RemoveTowerResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   *
   * @param [ListTowersRequest]
   * @returns [ListTowersResponse]
   */
export async function watchtowerClientListTowers(request) {
  const message = create(wtclientrpc.ListTowersRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientListTowers(base64Encode(toBinary(wtclientrpc.ListTowersRequestSchema, message)));
  const response = fromBinary(wtclientrpc.ListTowersResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   *
   * @param [GetTowerInfoRequest]
   * @returns [Tower]
   */
export async function watchtowerClientGetTowerInfo(request) {
  const message = create(wtclientrpc.GetTowerInfoRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientGetTowerInfo(base64Encode(toBinary(wtclientrpc.GetTowerInfoRequestSchema, message)));
  const response = fromBinary(wtclientrpc.TowerSchema, base64Decode(b64));
  return response;
}

/**
   *
   *
   * @param [StatsRequest]
   * @returns [StatsResponse]
   */
export async function watchtowerClientStats(request) {
  const message = create(wtclientrpc.StatsRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientStats(base64Encode(toBinary(wtclientrpc.StatsRequestSchema, message)));
  const response = fromBinary(wtclientrpc.StatsResponseSchema, base64Decode(b64));
  return response;
}

/**
   *
   *
   * @param [PolicyRequest]
   * @returns [PolicyResponse]
   */
export async function watchtowerClientPolicy(request) {
  const message = create(wtclientrpc.PolicyRequestSchema, request);
  const b64 = await TurboLnd.watchtowerClientPolicy(base64Encode(toBinary(wtclientrpc.PolicyRequestSchema, message)));
  const response = fromBinary(wtclientrpc.PolicyResponseSchema, base64Decode(b64));
  return response;
}
//# sourceMappingURL=index.js.map