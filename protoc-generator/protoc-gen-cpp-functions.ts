#!/usr/bin/env -S deno run --allow-read --allow-write
/* eslint-disable */
import * as path from "https://deno.land/std/path/mod.ts";
import protobuf from "npm:protobufjs@7.4.0";

interface ProtoFile {
  name: string;
  package: string;
  messageType: any[];
  enumType: any[];
  service: Service[];
  options: any;
}

interface Service {
  name: string;
  method: Method[];
}

interface Method {
  name: string;
  input_type: string;
  output_type: string;
  client_streaming: boolean;
  server_streaming: boolean;
  options: any;
}

const contributorNotice = `// Note to react-native-turbo-lnd contributors:
// This file is automatically generated by the protoc plugin inside the
// protoc-generator folder.
// Any changes to this file should be made there instead.`;

const lowercaseFirst = (str: string): string => str.charAt(0).toLowerCase() + str.slice(1);

async function loadProtoFiles() {
  const protoDir = path.resolve(Deno.cwd(), "protos");
  const descriptorPath = path.resolve(protoDir, "google", "protobuf", "descriptor.proto");
  const pluginPath = path.resolve(protoDir, "plugin.proto");

  const root = new protobuf.Root();
  await root.load(descriptorPath, { keepCase: true });
  await root.load(pluginPath, { keepCase: true });
  return root;
}

function extractComments(filePath: string): Record<string, string> {
  const content = Deno.readTextFileSync(path.join("..", "proto", filePath));
  const lines = content.split("\n");
  const comments: Record<string, string> = {};
  let currentComment: string[] = [];
  let isInComment = false;
  let currentMethod: string | null = null;

  lines.forEach((line, index) => {
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith("/*")) {
      isInComment = true;
      currentComment = [];
    } else if (trimmedLine.endsWith("*/")) {
      isInComment = false;
      // Look ahead for the method name
      for (let i = index + 1; i < lines.length; i++) {
        const nextLine = lines[i].trim();
        if (nextLine.startsWith("rpc ")) {
          currentMethod = nextLine.split(" ")[1];
          break;
        }
      }
      if (currentMethod) {
        comments[currentMethod] = currentComment.join("\n");
      }
    } else if (isInComment) {
      // Remove leading "*"" if present, but keep the space after it
      const commentLine = trimmedLine.startsWith("*") ? " " + trimmedLine.slice(1) : trimmedLine;
      currentComment.push(commentLine);
    }
  });

  return comments;
}

function formatComment(comment: string, method: Method): string {
  const lines = comment.split("\n");
  let formattedLines = ["   *"]; // Start with an empty line
  let lastLineWasEmpty = true;

  lines.forEach((line) => {
    const trimmedLine = line.trim();
    if (trimmedLine === "") {
      if (!lastLineWasEmpty) {
        formattedLines.push("   *");
        lastLineWasEmpty = true;
      }
    } else {
      formattedLines.push(`   * ${trimmedLine}`);
      lastLineWasEmpty = false;
    }
  });

  // Add input and output types
  const inputType = method.input_type.split(".").pop();
  const outputType = method.output_type.split(".").pop();
  formattedLines.push("   *");
  formattedLines.push(`   * @param [${inputType}]`);
  formattedLines.push(`   * @returns [${outputType}]`);

  // Add an empty line at the end if it doesn't already exist
  if (!lastLineWasEmpty) {
    formattedLines.push("   *");
  }

  return `/**\n${formattedLines.join("\n")}\n   */`;
}

function generateCode(request: any): { cppContent: string; cppHeaderContent: string; turboSpec: string, protobufEsWrapper: string } {
  const cppHeaderResult: string[] = [];
  const cppResult: string[] = [];
  const turboSpecResult: string[] = [];
  const protobufEsWrapperResult: string[] = [];

  const comments: Record<string, string> = {};
  request.proto_file.forEach((protoFile: ProtoFile) => {
    const filePath = protoFile.name;
    Object.assign(comments, extractComments(filePath));
  });

  request.proto_file.forEach((protoFile: ProtoFile) => {
    // console.log("protoFile",protoFile);Deno.exit(0);
    // console.log(protoFile,"protoFile");return;
    if (protoFile.service && Array.isArray(protoFile.service)) {
      protoFile.service.forEach((service: Service) => {
        // console.log("protoFile.name",protoFile.name,"\n");
        // console.log("service.name",service.name,"\n");
        const serviceName = service.name;

        if (service.method && Array.isArray(service.method)) {
          service.method.forEach((method: Method) => {
            let methodName = method.name;
            if (serviceName === "Lightning" || serviceName === "WalletUnlocker" || serviceName === "State") {
              methodName = lowercaseFirst(methodName);
            } else {
              methodName = lowercaseFirst(serviceName + methodName);
            }

            const [_, inputTypeService, inputType] = method.input_type.split(".");
            const [_2, outputTypeService, outputType] = method.output_type.split(".");
            const isServerStreaming = method.server_streaming;
            const isClientStreaming = method.client_streaming;

            // Get comment from extracted comments
            const comment = comments[method.name]
              ? formatComment(comments[method.name]!, method)
              : formatComment("", method); // If no comment, still include input/output types

            // Generate C++ and React Native code (implementation omitted for brevity)
            let cppMethodDeclaration;
            let cppMethodImplementation;
            let rnMethodSpec;
            let protobufEsWrapperMethod;

            if (!isServerStreaming && !isClientStreaming) {
              // Unary RPC
              cppMethodDeclaration = `  facebook::react::AsyncPromise<std::string> ${methodName}(jsi::Runtime &rt, jsi::String data);`;
              cppMethodImplementation = `
facebook::react::AsyncPromise<std::string> TurboLndModule::${methodName}(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::${methodName}(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}`;
              rnMethodSpec = `  ${comment}\n  ${methodName}(data: ProtobufBase64): Promise<ProtobufBase64>;`;


              protobufEsWrapperMethod = `${comment}
export async function ${methodName}(
  request: MessageInitShape<typeof ${inputTypeService}.${inputType}Schema>
): Promise<${outputTypeService}.${outputType}> {
  const message = create(
    ${inputTypeService}.${inputType}Schema,
    request
  );
  const b64 = await TurboLnd.${methodName}(
    base64Encode(
      toBinary(${inputTypeService}.${inputType}Schema, message)
    )
  );
  const response = fromBinary(
    ${outputTypeService}.${outputType}Schema,
    base64Decode(b64)
  );
  return response;
}
`;
            } else if (isServerStreaming && !isClientStreaming) {
              // Server streaming RPC
              cppMethodDeclaration = `  facebook::jsi::Function ${methodName}(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError);`;
              cppMethodImplementation = `
facebook::jsi::Function TurboLndModule::${methodName}(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::${methodName}(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}`;
              rnMethodSpec = `  ${comment}\n  ${methodName}(data: ProtobufBase64, onResponse: OnResponseCallback, onError: OnErrorCallback): UnsubscribeFromStream;`;

              protobufEsWrapperMethod = `${comment}
export function ${methodName}(
  request: MessageInitShape<typeof ${inputTypeService}.${inputType}Schema>,
  onResponse: (response: ${outputTypeService}.${outputType}) => void,
  onError: (error: string) => void
): UnsubscribeFromStream {
  const message = create(
    ${inputTypeService}.${inputType}Schema,
    request
  );
  const requestB64 = base64Encode(
    toBinary(${inputTypeService}.${inputType}Schema, message)
  );

  const onResponseWrapper: OnResponseCallback = (responseB64) => {
    onResponse(fromBinary(
      ${outputTypeService}.${outputType}Schema,
      base64Decode(responseB64)
    ));
  }
  const onErrorWrapper: OnErrorCallback = (error: string) => onError(error);


  return TurboLnd.${methodName}(requestB64, onResponseWrapper, onErrorWrapper);
}
`
            } else if (isClientStreaming && isServerStreaming) {
              // Bidirectional streaming RPC
              cppMethodDeclaration = `  jsi::Object ${methodName}(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError);`;
              cppMethodImplementation = `
jsi::Object TurboLndModule::${methodName}(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::${methodName}(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start ${methodName}");
    }
}`;
              rnMethodSpec = `  ${comment}\n  ${methodName}(onResponse: OnResponseCallback, onError: OnErrorCallback): WriteableStream;`;

              protobufEsWrapperMethod = `${comment}
export function ${methodName}(
  onResponse: (response: ${outputTypeService}.${outputType}) => void,
  onError: (error: string) => void
) {
  const onResponseWrapper: OnResponseCallback = (responseB64) => {
    onResponse(fromBinary(
      ${outputTypeService}.${outputType}Schema,
      base64Decode(responseB64)
    ));
  }
  const onErrorWrapper: OnErrorCallback = (error: string) => onError(error);

  const writeableStream = TurboLnd.${methodName}(onResponseWrapper, onErrorWrapper);

  return {
    send: (response: MessageInitShape<typeof ${inputTypeService}.${inputType}Schema>) => {
      const message = create(
        ${inputTypeService}.${inputType}Schema,
        response
      );
      const responseB64 = base64Encode(
        toBinary(${inputTypeService}.${inputType}Schema, message)
      );
      writeableStream.send(responseB64);
    },
    close: () => {
      writeableStream.stop();
    }
  }
}`
            }

            if (cppMethodDeclaration) {
              cppHeaderResult.push(cppMethodDeclaration);
            }
            if (cppMethodImplementation) {
              cppResult.push(cppMethodImplementation);
            }
            if (rnMethodSpec) {
              turboSpecResult.push(rnMethodSpec);
            }
            if (protobufEsWrapperMethod) {
              protobufEsWrapperResult.push(protobufEsWrapperMethod);
            }
          });
        }
      });
    }
  });

  // Combine results into final content strings
  const cppHeaderContent =
`${contributorNotice}
#pragma once

// Apple
#if __has_include(<React-Codegen/RNTurboLndSpecJSI.h>)
#include <React-Codegen/RNTurboLndSpecJSI.h>
// Android
#elif __has_include("RNTurboLndSpecJSI.h")
#include "RNTurboLndSpecJSI.h"
#endif

#include <memory>
#include <string>

#include <react/bridging/Promise.h>

namespace facebook::react {

class TurboLndModule : public NativeTurboLndCxxSpec<TurboLndModule> {
 public:
  explicit TurboLndModule(std::shared_ptr<CallInvoker> jsInvoker);

  static void promiseOnResponseStatic(void* context, const char* data, int length);
  static void promiseOnErrorStatic(void* context, const char* error);
  static void callbackOnResponseStatic(void* context, const char* data, int length);
  static void callbackOnErrorStatic(void* context, const char* error);


  facebook::react::AsyncPromise<std::string> start(jsi::Runtime &rt, jsi::String args);

${cppHeaderResult.join("\n\n")}


};

} // namespace facebook::react
`;

  const cppContent =
`${contributorNotice}
#include "TurboLndModule.h"

#include "liblnd.h"

#include "utils/PromiseKeeper.h"
#include "utils/CallbackKeeper.h"
#include "utils/WritableStreamHostObject.h"
#include "utils/base64.hpp"
#include "utils/log.h"

namespace facebook::react {

TurboLndModule::TurboLndModule(std::shared_ptr<CallInvoker> jsInvoker)
    : NativeTurboLndCxxSpec(std::move(jsInvoker)) {}

void TurboLndModule::promiseOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
}

void TurboLndModule::promiseOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
}

void TurboLndModule::callbackOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    CallbackKeeper::getInstance().invokeResponseCallback(id, std::move(encoded));
}

void TurboLndModule::callbackOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    CallbackKeeper::getInstance().invokeErrorCallback(id, std::string(error));
}

facebook::react::AsyncPromise<std::string> TurboLndModule::start(jsi::Runtime &rt, jsi::String args) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = [](void* context, const char* data, int length) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            std::string encoded = base64::to_base64(std::string_view(data, length));
            PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
        },
        .onError = [](void* context, const char* error) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
        },
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string argsStr = args.utf8(rt);
    char* mutableArgs = const_cast<char*>(argsStr.c_str());

    ::start(mutableArgs, callback);

    return *promise;
}


${cppResult.join("\n\n")}


} // namespace facebook::react
`;

  const turboSpec =
`${contributorNotice}
/* eslint-disable */
import type { TurboModule } from "react-native";
import { TurboModuleRegistry } from "react-native";

// Protobufs will be encoded as base64 strings.
// Use a protobuf utility like protobufjs or protobuf-es to encode/decode them.
export type ProtobufBase64 = string;

// Bidi streams will return this interface for where can send data to the
// stream.
export interface WriteableStream {
  send: (data: ProtobufBase64) => boolean;
  stop: () => boolean;
}

// Read streams will call OnResponseCallback when data is available.
// UnsubscribeFromStream can be used to stop the stream.
export type OnResponseCallback = (data: ProtobufBase64) => void;
export type OnErrorCallback = (error: string) => void;
export type UnsubscribeFromStream = () => void;

export interface Spec extends TurboModule {
  /**
   *
   * Starts up lnd.
   * You need to provide path to the app's local dir to lnd via \`--lnddir\` arg.
   * Use \`subscribeState\` to know when lnd is ready for wallet unlock/creation.
   *
   */
  start: (args: string) => Promise<string>;

${turboSpecResult.join("\n\n")}
}

export default TurboModuleRegistry.getEnforcing<Spec>("TurboLndModuleCxx");
`;

  const protobufEsWrapper =
`${contributorNotice}
/* eslint-disable */
import "./setup-text-encoding";

import TurboLnd, { type OnResponseCallback, type OnErrorCallback, type UnsubscribeFromStream } from "./core/NativeTurboLnd";
import { create, toBinary, fromBinary, type MessageInitShape } from "@bufbuild/protobuf";
import { base64Encode, base64Decode } from "@bufbuild/protobuf/wire";

import * as lnrpc from "./proto/lightning_pb";
// import * as walletunlocker from "./proto/walletunlocker_pb";
// import * as state from "./proto/stateservice_pb";
import * as autopilotrpc from "./proto/autopilotrpc/autopilot_pb";
// import * as chainrpc from "./proto/chainrpc/chainkit_pb";
import * as chainrpc from "./proto/chainrpc/chainnotifier_pb";
// import * as dev from "./proto/devrpc/dev_pb";
import * as invoicesrpc from "./proto/invoicesrpc/invoices_pb";
// import * as versionresponse from "./proto/lnclipb/lncli_pb";
import * as neutrinorpc from "./proto/neutrinorpc/neutrino_pb";
import * as peersrpc from "./proto/peersrpc/peers_pb";
import * as routerrpc from "./proto/routerrpc/router_pb";
import * as signrpc from "./proto/signrpc/signer_pb";
import * as verrpc from "./proto/verrpc/verrpc_pb";
import * as walletrpc from "./proto/walletrpc/walletkit_pb";
import * as watchtowerrpc from "./proto/watchtowerrpc/watchtower_pb";
import * as wtclientrpc from "./proto/wtclientrpc/wtclient_pb";

/**
 *
 * Starts up lnd.
 * You need to provide path to the app's local dir to lnd via \`--lnddir\` arg.
 * Use \`subscribeState\` to know when lnd is ready for wallet unlock/creation.
 *
 */
export const start = TurboLnd.start;

${protobufEsWrapperResult.join("\n\n")}
`

  return { cppContent, cppHeaderContent, turboSpec, protobufEsWrapper };
}

async function main() {
  try {
    const root = await loadProtoFiles();
    const PluginRequest = root.lookupType("google.protobuf.compiler.CodeGeneratorRequest");
    const PluginResponse = root.lookupType("google.protobuf.compiler.CodeGeneratorResponse");

    const inputBuffer = await Deno.readAll(Deno.stdin);
    const uint8Array = new Uint8Array(inputBuffer);
    const request = PluginRequest.decode(uint8Array);
    const { cppContent, cppHeaderContent, turboSpec, protobufEsWrapper } = generateCode(request);

    const response = PluginResponse.create({
      file: [
        {
          name: "TurboLndModule.cpp",
          content: cppContent,
        },
        {
          name: "TurboLndModule.h",
          content: cppHeaderContent,
        },
        {
          name: "core/NativeTurboLnd.ts",
          content: turboSpec,
        },
        {
          name: "index.ts",
          content: protobufEsWrapper,
        },
      ],
    });

    const responseBuffer = PluginResponse.encode(response).finish();
    await Deno.writeAll(Deno.stdout, responseBuffer);
  } catch (error) {
    console.error("Error in plugin:", error.stack);
    Deno.exit(1);
  }
}

main();
