// Note to react-native-turbo-lnd contributors:
// This file is automatically generated by the protoc plugin inside the
// protoc-generator folder.
// Any changes to this file should be made there instead.
#include "TurboLndModule.h"

#include "liblnd.h"

#include "utils/PromiseKeeper.h"
#include "utils/CallbackKeeper.h"
#include "utils/WritableStreamHostObject.h"
#include "utils/base64.hpp"
#include "utils/log.h"

namespace facebook::react {

TurboLndModule::TurboLndModule(std::shared_ptr<CallInvoker> jsInvoker)
    : NativeTurboLndCxxSpec(std::move(jsInvoker)) {}

void TurboLndModule::promiseOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
}

void TurboLndModule::promiseOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
}

void TurboLndModule::callbackOnResponseStatic(void* context, const char* data, int length) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    std::string encoded = base64::to_base64(std::string_view(data, length));
    CallbackKeeper::getInstance().invokeResponseCallback(id, std::move(encoded));
}

void TurboLndModule::callbackOnErrorStatic(void* context, const char* error) {
    uint64_t id = reinterpret_cast<uint64_t>(context);
    CallbackKeeper::getInstance().invokeErrorCallback(id, std::string(error));
}

facebook::react::AsyncPromise<std::string> TurboLndModule::start(jsi::Runtime &rt, jsi::String args) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = [](void* context, const char* data, int length) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            std::string encoded = base64::to_base64(std::string_view(data, length));
            PromiseKeeper::getInstance().resolvePromise(id, std::move(encoded));
        },
        .onError = [](void* context, const char* error) {
            uint64_t id = reinterpret_cast<uint64_t>(context);
            PromiseKeeper::getInstance().rejectPromise(id, std::string(error));
        },
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string argsStr = args.utf8(rt);
    char* mutableArgs = const_cast<char*>(argsStr.c_str());

    ::start(mutableArgs, callback);

    return *promise;
}



facebook::react::AsyncPromise<std::string> TurboLndModule::walletBalance(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletBalance(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::channelBalance(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::channelBalance(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getTransactions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getTransactions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::estimateFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::estimateFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::sendCoins(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendCoins(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listUnspent(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listUnspent(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeTransactions(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeTransactions(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::sendMany(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendMany(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::newAddress(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::newAddress(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::verifyMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::verifyMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::connectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::connectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::disconnectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::disconnectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listPeers(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPeers(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribePeerEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribePeerEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getRecoveryInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getRecoveryInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::pendingChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::pendingChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeChannelEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::closedChannels(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::closedChannels(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::openChannelSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::openChannelSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::openChannel(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::openChannel(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::batchOpenChannel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::batchOpenChannel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::fundingStateStep(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::fundingStateStep(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object TurboLndModule::channelAcceptor(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::channelAcceptor(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start channelAcceptor");
    }
}


facebook::jsi::Function TurboLndModule::closeChannel(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::closeChannel(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::abandonChannel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::abandonChannel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object TurboLndModule::sendPayment(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::sendPayment(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start sendPayment");
    }
}


facebook::react::AsyncPromise<std::string> TurboLndModule::sendPaymentSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendPaymentSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object TurboLndModule::sendToRoute(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::sendToRoute(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start sendToRoute");
    }
}


facebook::react::AsyncPromise<std::string> TurboLndModule::sendToRouteSync(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendToRouteSync(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::addInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::addInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listInvoices(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listInvoices(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::lookupInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::lookupInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeInvoices(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeInvoices(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::decodePayReq(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::decodePayReq(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listPayments(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPayments(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::deletePayment(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deletePayment(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::deleteAllPayments(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deleteAllPayments(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::describeGraph(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::describeGraph(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getNodeMetrics(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNodeMetrics(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getChanInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getChanInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getNodeInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNodeInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::queryRoutes(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::queryRoutes(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getNetworkInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getNetworkInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::stopDaemon(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::stopDaemon(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeChannelGraph(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelGraph(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::debugLevel(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::debugLevel(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::feeReport(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::feeReport(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::updateChannelPolicy(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::updateChannelPolicy(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::forwardingHistory(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::forwardingHistory(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::exportChannelBackup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::exportChannelBackup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::exportAllChannelBackups(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::exportAllChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::verifyChanBackup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::verifyChanBackup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::restoreChannelBackups(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::restoreChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeChannelBackups(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeChannelBackups(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::bakeMacaroon(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::bakeMacaroon(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listMacaroonIDs(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listMacaroonIDs(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::deleteMacaroonID(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::deleteMacaroonID(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listPermissions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listPermissions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::checkMacaroonPermissions(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::checkMacaroonPermissions(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


jsi::Object TurboLndModule::registerRPCMiddleware(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::registerRPCMiddleware(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start registerRPCMiddleware");
    }
}


facebook::react::AsyncPromise<std::string> TurboLndModule::sendCustomMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::sendCustomMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeCustomMessages(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeCustomMessages(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::listAliases(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::listAliases(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::lookupHtlcResolution(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::lookupHtlcResolution(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::genSeed(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::genSeed(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::initWallet(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::initWallet(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::unlockWallet(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::unlockWallet(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::changePassword(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::changePassword(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::subscribeState(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::subscribeState(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::getState(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::getState(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::autopilotStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::autopilotModifyStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotModifyStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::autopilotQueryScores(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotQueryScores(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::autopilotSetScores(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::autopilotSetScores(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::chainNotifierRegisterConfirmationsNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterConfirmationsNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::chainNotifierRegisterSpendNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterSpendNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::chainNotifierRegisterBlockEpochNtfn(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::chainNotifierRegisterBlockEpochNtfn(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::invoicesSubscribeSingleInvoice(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesSubscribeSingleInvoice(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::invoicesCancelInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesCancelInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::invoicesAddHoldInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesAddHoldInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::invoicesSettleInvoice(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesSettleInvoice(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::invoicesLookupInvoiceV2(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::invoicesLookupInvoiceV2(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitAddPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitAddPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitDisconnectPeer(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitDisconnectPeer(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitIsBanned(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitIsBanned(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitGetBlockHeader(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlockHeader(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitGetBlock(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlock(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitGetCFilter(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetCFilter(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::neutrinoKitGetBlockHash(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::neutrinoKitGetBlockHash(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::peersUpdateNodeAnnouncement(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::peersUpdateNodeAnnouncement(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::routerSendPaymentV2(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendPaymentV2(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::routerTrackPaymentV2(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPaymentV2(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::routerTrackPayments(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPayments(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerEstimateRouteFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerEstimateRouteFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerSendToRoute(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendToRoute(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerSendToRouteV2(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendToRouteV2(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerResetMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerResetMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerQueryMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerQueryMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerXImportMissionControl(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerXImportMissionControl(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerGetMissionControlConfig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerGetMissionControlConfig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerSetMissionControlConfig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSetMissionControlConfig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerQueryProbability(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerQueryProbability(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerBuildRoute(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerBuildRoute(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::jsi::Function TurboLndModule::routerSubscribeHtlcEvents(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSubscribeHtlcEvents(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::routerSendPayment(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerSendPayment(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


facebook::jsi::Function TurboLndModule::routerTrackPayment(jsi::Runtime &rt, jsi::String data, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerTrackPayment(decodedData.data(), static_cast<int>(decodedData.size()), recvStream);

    auto unsubscribeFunc = jsi::Function::createFromHostFunction(
        rt,
        jsi::PropNameID::forAscii(rt, "unsubscribe"),
        0,
        [callbackId](jsi::Runtime& rt, const jsi::Value& thisValue, const jsi::Value* arguments, size_t count) -> jsi::Value {
            CallbackKeeper::getInstance().removeCallbacks(callbackId);
            return jsi::Value::undefined();
        }
    );

    return unsubscribeFunc;
}


jsi::Object TurboLndModule::routerHtlcInterceptor(jsi::Runtime &rt, AsyncCallback<std::string> onResponse, AsyncCallback<std::string> onError) {
    auto sharedOnResponse = std::make_shared<AsyncCallback<std::string>>(std::move(onResponse));
    auto sharedOnError = std::make_shared<AsyncCallback<std::string>>(std::move(onError));
    uint64_t callbackId = CallbackKeeper::getInstance().addCallbacks(sharedOnResponse, sharedOnError);

    CRecvStream recvStream = {
        .onResponse = &callbackOnResponseStatic,
        .onError = &callbackOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(callbackId),
        .errorContext = reinterpret_cast<void*>(callbackId),
    };

    uintptr_t streamPtr = ::routerHtlcInterceptor(recvStream);

    if (streamPtr != 0) {
        auto hostObject = std::make_shared<WritableStreamHostObject>(streamPtr, callbackId);
        return jsi::Object::createFromHostObject(rt, hostObject);
    } else {
        throw jsi::JSError(rt, "Failed to start routerHtlcInterceptor");
    }
}


facebook::react::AsyncPromise<std::string> TurboLndModule::routerUpdateChanStatus(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::routerUpdateChanStatus(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerSignOutputRaw(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerSignOutputRaw(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerComputeInputScript(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerComputeInputScript(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerSignMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerSignMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerVerifyMessage(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerVerifyMessage(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerDeriveSharedKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerDeriveSharedKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2CombineKeys(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CombineKeys(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2CreateSession(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CreateSession(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2RegisterNonces(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2RegisterNonces(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2Sign(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2Sign(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2CombineSig(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2CombineSig(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::signerMuSig2Cleanup(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::signerMuSig2Cleanup(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::versionerGetVersion(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::versionerGetVersion(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitListUnspent(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListUnspent(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitLeaseOutput(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitLeaseOutput(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitReleaseOutput(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitReleaseOutput(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitListLeases(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListLeases(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitDeriveNextKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitDeriveNextKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitDeriveKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitDeriveKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitNextAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitNextAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitListAccounts(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListAccounts(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitRequiredReserve(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitRequiredReserve(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitListAddresses(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListAddresses(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitSignMessageWithAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSignMessageWithAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitVerifyMessageWithAddr(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitVerifyMessageWithAddr(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitImportAccount(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportAccount(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitImportPublicKey(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportPublicKey(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitImportTapscript(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitImportTapscript(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitPublishTransaction(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitPublishTransaction(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitSendOutputs(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSendOutputs(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitEstimateFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitEstimateFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitPendingSweeps(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitPendingSweeps(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitBumpFee(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitBumpFee(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitListSweeps(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitListSweeps(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitLabelTransaction(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitLabelTransaction(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitFundPsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitFundPsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitSignPsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitSignPsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::walletKitFinalizePsbt(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::walletKitFinalizePsbt(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerGetInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerGetInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientAddTower(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientAddTower(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientRemoveTower(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientRemoveTower(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientListTowers(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientListTowers(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientGetTowerInfo(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientGetTowerInfo(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientStats(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientStats(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


facebook::react::AsyncPromise<std::string> TurboLndModule::watchtowerClientPolicy(jsi::Runtime &rt, jsi::String data) {
    auto promise = std::make_shared<facebook::react::AsyncPromise<std::string>>(rt, jsInvoker_);
    uint64_t promiseId = PromiseKeeper::getInstance().addPromise(promise);

    CCallback callback = {
        .onResponse = &promiseOnResponseStatic,
        .onError = &promiseOnErrorStatic,
        .responseContext = reinterpret_cast<void*>(promiseId),
        .errorContext = reinterpret_cast<void*>(promiseId)
    };

    std::string decodedData = base64::from_base64(data.utf8(rt));
    ::watchtowerClientPolicy(decodedData.data(), static_cast<int>(decodedData.size()), callback);

    return *promise;
}


} // namespace facebook::react
