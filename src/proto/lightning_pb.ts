// @generated by protoc-gen-es v2.0.0 with parameter "target=ts"
// @generated from file lightning.proto (package lnrpc, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file lightning.proto.
 */
export const file_lightning: GenFile = /*@__PURE__*/
  fileDesc("Cg9saWdodG5pbmcucHJvdG8SBWxucnBjIkIKG0xvb2t1cEh0bGNSZXNvbHV0aW9uUmVxdWVzdBIPCgdjaGFuX2lkGAEgASgEEhIKCmh0bGNfaW5kZXgYAiABKAQiQQocTG9va3VwSHRsY1Jlc29sdXRpb25SZXNwb25zZRIPCgdzZXR0bGVkGAEgASgIEhAKCG9mZmNoYWluGAIgASgIIiAKHlN1YnNjcmliZUN1c3RvbU1lc3NhZ2VzUmVxdWVzdCI5Cg1DdXN0b21NZXNzYWdlEgwKBHBlZXIYASABKAwSDAoEdHlwZRgCIAEoDRIMCgRkYXRhGAMgASgMIkQKGFNlbmRDdXN0b21NZXNzYWdlUmVxdWVzdBIMCgRwZWVyGAEgASgMEgwKBHR5cGUYAiABKA0SDAoEZGF0YRgDIAEoDCIbChlTZW5kQ3VzdG9tTWVzc2FnZVJlc3BvbnNlIqIBCgRVdHhvEigKDGFkZHJlc3NfdHlwZRgBIAEoDjISLmxucnBjLkFkZHJlc3NUeXBlEg8KB2FkZHJlc3MYAiABKAkSEgoKYW1vdW50X3NhdBgDIAEoAxIRCglwa19zY3JpcHQYBCABKAkSIQoIb3V0cG9pbnQYBSABKAsyDy5sbnJwYy5PdXRQb2ludBIVCg1jb25maXJtYXRpb25zGAYgASgDIp4BCgxPdXRwdXREZXRhaWwSLAoLb3V0cHV0X3R5cGUYASABKA4yFy5sbnJwYy5PdXRwdXRTY3JpcHRUeXBlEg8KB2FkZHJlc3MYAiABKAkSEQoJcGtfc2NyaXB0GAMgASgJEhQKDG91dHB1dF9pbmRleBgEIAEoAxIOCgZhbW91bnQYBSABKAMSFgoOaXNfb3VyX2FkZHJlc3MYBiABKAgivAIKC1RyYW5zYWN0aW9uEg8KB3R4X2hhc2gYASABKAkSDgoGYW1vdW50GAIgASgDEhkKEW51bV9jb25maXJtYXRpb25zGAMgASgFEhIKCmJsb2NrX2hhc2gYBCABKAkSFAoMYmxvY2tfaGVpZ2h0GAUgASgFEhIKCnRpbWVfc3RhbXAYBiABKAMSEgoKdG90YWxfZmVlcxgHIAEoAxIaCg5kZXN0X2FkZHJlc3NlcxgIIAMoCUICGAESKwoOb3V0cHV0X2RldGFpbHMYCyADKAsyEy5sbnJwYy5PdXRwdXREZXRhaWwSEgoKcmF3X3R4X2hleBgJIAEoCRINCgVsYWJlbBgKIAEoCRIzChJwcmV2aW91c19vdXRwb2ludHMYDCADKAsyFy5sbnJwYy5QcmV2aW91c091dFBvaW50IlMKFkdldFRyYW5zYWN0aW9uc1JlcXVlc3QSFAoMc3RhcnRfaGVpZ2h0GAEgASgFEhIKCmVuZF9oZWlnaHQYAiABKAUSDwoHYWNjb3VudBgDIAEoCSI+ChJUcmFuc2FjdGlvbkRldGFpbHMSKAoMdHJhbnNhY3Rpb25zGAEgAygLMhIubG5ycGMuVHJhbnNhY3Rpb24iTQoIRmVlTGltaXQSDwoFZml4ZWQYASABKANIABIUCgpmaXhlZF9tc2F0GAMgASgDSAASEQoHcGVyY2VudBgCIAEoA0gAQgcKBWxpbWl0IooECgtTZW5kUmVxdWVzdBIMCgRkZXN0GAEgASgMEhcKC2Rlc3Rfc3RyaW5nGAIgASgJQgIYARILCgNhbXQYAyABKAMSEAoIYW10X21zYXQYDCABKAMSFAoMcGF5bWVudF9oYXNoGAQgASgMEh8KE3BheW1lbnRfaGFzaF9zdHJpbmcYBSABKAlCAhgBEhcKD3BheW1lbnRfcmVxdWVzdBgGIAEoCRIYChBmaW5hbF9jbHR2X2RlbHRhGAcgASgFEiIKCWZlZV9saW1pdBgIIAEoCzIPLmxucnBjLkZlZUxpbWl0EhwKEG91dGdvaW5nX2NoYW5faWQYCSABKARCAjABEhcKD2xhc3RfaG9wX3B1YmtleRgNIAEoDBISCgpjbHR2X2xpbWl0GAogASgNEkYKE2Rlc3RfY3VzdG9tX3JlY29yZHMYCyADKAsyKS5sbnJwYy5TZW5kUmVxdWVzdC5EZXN0Q3VzdG9tUmVjb3Jkc0VudHJ5EhoKEmFsbG93X3NlbGZfcGF5bWVudBgOIAEoCBIoCg1kZXN0X2ZlYXR1cmVzGA8gAygOMhEubG5ycGMuRmVhdHVyZUJpdBIUCgxwYXltZW50X2FkZHIYECABKAwaOAoWRGVzdEN1c3RvbVJlY29yZHNFbnRyeRILCgNrZXkYASABKAQSDQoFdmFsdWUYAiABKAw6AjgBInoKDFNlbmRSZXNwb25zZRIVCg1wYXltZW50X2Vycm9yGAEgASgJEhgKEHBheW1lbnRfcHJlaW1hZ2UYAiABKAwSIwoNcGF5bWVudF9yb3V0ZRgDIAEoCzIMLmxucnBjLlJvdXRlEhQKDHBheW1lbnRfaGFzaBgEIAEoDCJuChJTZW5kVG9Sb3V0ZVJlcXVlc3QSFAoMcGF5bWVudF9oYXNoGAEgASgMEh8KE3BheW1lbnRfaGFzaF9zdHJpbmcYAiABKAlCAhgBEhsKBXJvdXRlGAQgASgLMgwubG5ycGMuUm91dGVKBAgDEAQimAMKFENoYW5uZWxBY2NlcHRSZXF1ZXN0EhMKC25vZGVfcHVia2V5GAEgASgMEhIKCmNoYWluX2hhc2gYAiABKAwSFwoPcGVuZGluZ19jaGFuX2lkGAMgASgMEhMKC2Z1bmRpbmdfYW10GAQgASgEEhAKCHB1c2hfYW10GAUgASgEEhIKCmR1c3RfbGltaXQYBiABKAQSGwoTbWF4X3ZhbHVlX2luX2ZsaWdodBgHIAEoBBIXCg9jaGFubmVsX3Jlc2VydmUYCCABKAQSEAoIbWluX2h0bGMYCSABKAQSEgoKZmVlX3Blcl9rdxgKIAEoBBIRCgljc3ZfZGVsYXkYCyABKA0SGgoSbWF4X2FjY2VwdGVkX2h0bGNzGAwgASgNEhUKDWNoYW5uZWxfZmxhZ3MYDSABKA0SLgoPY29tbWl0bWVudF90eXBlGA4gASgOMhUubG5ycGMuQ29tbWl0bWVudFR5cGUSFwoPd2FudHNfemVyb19jb25mGA8gASgIEhgKEHdhbnRzX3NjaWRfYWxpYXMYECABKAgihwIKFUNoYW5uZWxBY2NlcHRSZXNwb25zZRIOCgZhY2NlcHQYASABKAgSFwoPcGVuZGluZ19jaGFuX2lkGAIgASgMEg0KBWVycm9yGAMgASgJEhgKEHVwZnJvbnRfc2h1dGRvd24YBCABKAkSEQoJY3N2X2RlbGF5GAUgASgNEhMKC3Jlc2VydmVfc2F0GAYgASgEEhoKEmluX2ZsaWdodF9tYXhfbXNhdBgHIAEoBBIWCg5tYXhfaHRsY19jb3VudBgIIAEoDRITCgttaW5faHRsY19pbhgJIAEoBBIYChBtaW5fYWNjZXB0X2RlcHRoGAogASgNEhEKCXplcm9fY29uZhgLIAEoCCJuCgxDaGFubmVsUG9pbnQSHAoSZnVuZGluZ190eGlkX2J5dGVzGAEgASgMSAASGgoQZnVuZGluZ190eGlkX3N0chgCIAEoCUgAEhQKDG91dHB1dF9pbmRleBgDIAEoDUIOCgxmdW5kaW5nX3R4aWQiRgoIT3V0UG9pbnQSEgoKdHhpZF9ieXRlcxgBIAEoDBIQCgh0eGlkX3N0chgCIAEoCRIUCgxvdXRwdXRfaW5kZXgYAyABKA0iOwoQUHJldmlvdXNPdXRQb2ludBIQCghvdXRwb2ludBgBIAEoCRIVCg1pc19vdXJfb3V0cHV0GAIgASgIIjAKEExpZ2h0bmluZ0FkZHJlc3MSDgoGcHVia2V5GAEgASgJEgwKBGhvc3QYAiABKAkizwEKEkVzdGltYXRlRmVlUmVxdWVzdBJBCgxBZGRyVG9BbW91bnQYASADKAsyKy5sbnJwYy5Fc3RpbWF0ZUZlZVJlcXVlc3QuQWRkclRvQW1vdW50RW50cnkSEwoLdGFyZ2V0X2NvbmYYAiABKAUSEQoJbWluX2NvbmZzGAMgASgFEhkKEXNwZW5kX3VuY29uZmlybWVkGAQgASgIGjMKEUFkZHJUb0Ftb3VudEVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoAzoCOAEiXwoTRXN0aW1hdGVGZWVSZXNwb25zZRIPCgdmZWVfc2F0GAEgASgDEiAKFGZlZXJhdGVfc2F0X3Blcl9ieXRlGAIgASgDQgIYARIVCg1zYXRfcGVyX3ZieXRlGAMgASgEIokCCg9TZW5kTWFueVJlcXVlc3QSPgoMQWRkclRvQW1vdW50GAEgAygLMigubG5ycGMuU2VuZE1hbnlSZXF1ZXN0LkFkZHJUb0Ftb3VudEVudHJ5EhMKC3RhcmdldF9jb25mGAMgASgFEhUKDXNhdF9wZXJfdmJ5dGUYBCABKAQSGAoMc2F0X3Blcl9ieXRlGAUgASgDQgIYARINCgVsYWJlbBgGIAEoCRIRCgltaW5fY29uZnMYByABKAUSGQoRc3BlbmRfdW5jb25maXJtZWQYCCABKAgaMwoRQWRkclRvQW1vdW50RW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgDOgI4ASIgChBTZW5kTWFueVJlc3BvbnNlEgwKBHR4aWQYASABKAkixQEKEFNlbmRDb2luc1JlcXVlc3QSDAoEYWRkchgBIAEoCRIOCgZhbW91bnQYAiABKAMSEwoLdGFyZ2V0X2NvbmYYAyABKAUSFQoNc2F0X3Blcl92Ynl0ZRgEIAEoBBIYCgxzYXRfcGVyX2J5dGUYBSABKANCAhgBEhAKCHNlbmRfYWxsGAYgASgIEg0KBWxhYmVsGAcgASgJEhEKCW1pbl9jb25mcxgIIAEoBRIZChFzcGVuZF91bmNvbmZpcm1lZBgJIAEoCCIhChFTZW5kQ29pbnNSZXNwb25zZRIMCgR0eGlkGAEgASgJIksKEkxpc3RVbnNwZW50UmVxdWVzdBIRCgltaW5fY29uZnMYASABKAUSEQoJbWF4X2NvbmZzGAIgASgFEg8KB2FjY291bnQYAyABKAkiMQoTTGlzdFVuc3BlbnRSZXNwb25zZRIaCgV1dHhvcxgBIAMoCzILLmxucnBjLlV0eG8iRgoRTmV3QWRkcmVzc1JlcXVlc3QSIAoEdHlwZRgBIAEoDjISLmxucnBjLkFkZHJlc3NUeXBlEg8KB2FjY291bnQYAiABKAkiJQoSTmV3QWRkcmVzc1Jlc3BvbnNlEg8KB2FkZHJlc3MYASABKAkiNgoSU2lnbk1lc3NhZ2VSZXF1ZXN0EgsKA21zZxgBIAEoDBITCgtzaW5nbGVfaGFzaBgCIAEoCCIoChNTaWduTWVzc2FnZVJlc3BvbnNlEhEKCXNpZ25hdHVyZRgBIAEoCSI2ChRWZXJpZnlNZXNzYWdlUmVxdWVzdBILCgNtc2cYASABKAwSEQoJc2lnbmF0dXJlGAIgASgJIjYKFVZlcmlmeU1lc3NhZ2VSZXNwb25zZRINCgV2YWxpZBgBIAEoCBIOCgZwdWJrZXkYAiABKAkiWgoSQ29ubmVjdFBlZXJSZXF1ZXN0EiUKBGFkZHIYASABKAsyFy5sbnJwYy5MaWdodG5pbmdBZGRyZXNzEgwKBHBlcm0YAiABKAgSDwoHdGltZW91dBgDIAEoBCIVChNDb25uZWN0UGVlclJlc3BvbnNlIigKFURpc2Nvbm5lY3RQZWVyUmVxdWVzdBIPCgdwdWJfa2V5GAEgASgJIhgKFkRpc2Nvbm5lY3RQZWVyUmVzcG9uc2UipQEKBEhUTEMSEAoIaW5jb21pbmcYASABKAgSDgoGYW1vdW50GAIgASgDEhEKCWhhc2hfbG9jaxgDIAEoDBIZChFleHBpcmF0aW9uX2hlaWdodBgEIAEoDRISCgpodGxjX2luZGV4GAUgASgEEhoKEmZvcndhcmRpbmdfY2hhbm5lbBgGIAEoBBIdChVmb3J3YXJkaW5nX2h0bGNfaW5kZXgYByABKAQiqgEKEkNoYW5uZWxDb25zdHJhaW50cxIRCgljc3ZfZGVsYXkYASABKA0SGAoQY2hhbl9yZXNlcnZlX3NhdBgCIAEoBBIWCg5kdXN0X2xpbWl0X3NhdBgDIAEoBBIcChRtYXhfcGVuZGluZ19hbXRfbXNhdBgEIAEoBBIVCg1taW5faHRsY19tc2F0GAUgASgEEhoKEm1heF9hY2NlcHRlZF9odGxjcxgGIAEoDSK5BwoHQ2hhbm5lbBIOCgZhY3RpdmUYASABKAgSFQoNcmVtb3RlX3B1YmtleRgCIAEoCRIVCg1jaGFubmVsX3BvaW50GAMgASgJEhMKB2NoYW5faWQYBCABKARCAjABEhAKCGNhcGFjaXR5GAUgASgDEhUKDWxvY2FsX2JhbGFuY2UYBiABKAMSFgoOcmVtb3RlX2JhbGFuY2UYByABKAMSEgoKY29tbWl0X2ZlZRgIIAEoAxIVCg1jb21taXRfd2VpZ2h0GAkgASgDEhIKCmZlZV9wZXJfa3cYCiABKAMSGQoRdW5zZXR0bGVkX2JhbGFuY2UYCyABKAMSGwoTdG90YWxfc2F0b3NoaXNfc2VudBgMIAEoAxIfChd0b3RhbF9zYXRvc2hpc19yZWNlaXZlZBgNIAEoAxITCgtudW1fdXBkYXRlcxgOIAEoBBIiCg1wZW5kaW5nX2h0bGNzGA8gAygLMgsubG5ycGMuSFRMQxIVCgljc3ZfZGVsYXkYECABKA1CAhgBEg8KB3ByaXZhdGUYESABKAgSEQoJaW5pdGlhdG9yGBIgASgIEhkKEWNoYW5fc3RhdHVzX2ZsYWdzGBMgASgJEiIKFmxvY2FsX2NoYW5fcmVzZXJ2ZV9zYXQYFCABKANCAhgBEiMKF3JlbW90ZV9jaGFuX3Jlc2VydmVfc2F0GBUgASgDQgIYARIdChFzdGF0aWNfcmVtb3RlX2tleRgWIAEoCEICGAESLgoPY29tbWl0bWVudF90eXBlGBogASgOMhUubG5ycGMuQ29tbWl0bWVudFR5cGUSEAoIbGlmZXRpbWUYFyABKAMSDgoGdXB0aW1lGBggASgDEhUKDWNsb3NlX2FkZHJlc3MYGSABKAkSFwoPcHVzaF9hbW91bnRfc2F0GBsgASgEEhMKC3RoYXdfaGVpZ2h0GBwgASgNEjQKEWxvY2FsX2NvbnN0cmFpbnRzGB0gASgLMhkubG5ycGMuQ2hhbm5lbENvbnN0cmFpbnRzEjUKEnJlbW90ZV9jb25zdHJhaW50cxgeIAEoCzIZLmxucnBjLkNoYW5uZWxDb25zdHJhaW50cxITCgthbGlhc19zY2lkcxgfIAMoBBIRCgl6ZXJvX2NvbmYYICABKAgSIAoYemVyb19jb25mX2NvbmZpcm1lZF9zY2lkGCEgASgEEhIKCnBlZXJfYWxpYXMYIiABKAkSGwoPcGVlcl9zY2lkX2FsaWFzGCMgASgEQgIwARIMCgRtZW1vGCQgASgJIpUBChNMaXN0Q2hhbm5lbHNSZXF1ZXN0EhMKC2FjdGl2ZV9vbmx5GAEgASgIEhUKDWluYWN0aXZlX29ubHkYAiABKAgSEwoLcHVibGljX29ubHkYAyABKAgSFAoMcHJpdmF0ZV9vbmx5GAQgASgIEgwKBHBlZXIYBSABKAwSGQoRcGVlcl9hbGlhc19sb29rdXAYBiABKAgiOAoUTGlzdENoYW5uZWxzUmVzcG9uc2USIAoIY2hhbm5lbHMYCyADKAsyDi5sbnJwYy5DaGFubmVsIi4KCEFsaWFzTWFwEhEKCWJhc2Vfc2NpZBgBIAEoBBIPCgdhbGlhc2VzGAIgAygEIhQKEkxpc3RBbGlhc2VzUmVxdWVzdCI6ChNMaXN0QWxpYXNlc1Jlc3BvbnNlEiMKCmFsaWFzX21hcHMYASADKAsyDy5sbnJwYy5BbGlhc01hcCLkBAoTQ2hhbm5lbENsb3NlU3VtbWFyeRIVCg1jaGFubmVsX3BvaW50GAEgASgJEhMKB2NoYW5faWQYAiABKARCAjABEhIKCmNoYWluX2hhc2gYAyABKAkSFwoPY2xvc2luZ190eF9oYXNoGAQgASgJEhUKDXJlbW90ZV9wdWJrZXkYBSABKAkSEAoIY2FwYWNpdHkYBiABKAMSFAoMY2xvc2VfaGVpZ2h0GAcgASgNEhcKD3NldHRsZWRfYmFsYW5jZRgIIAEoAxIbChN0aW1lX2xvY2tlZF9iYWxhbmNlGAkgASgDEjoKCmNsb3NlX3R5cGUYCiABKA4yJi5sbnJwYy5DaGFubmVsQ2xvc2VTdW1tYXJ5LkNsb3N1cmVUeXBlEigKDm9wZW5faW5pdGlhdG9yGAsgASgOMhAubG5ycGMuSW5pdGlhdG9yEikKD2Nsb3NlX2luaXRpYXRvchgMIAEoDjIQLmxucnBjLkluaXRpYXRvchImCgtyZXNvbHV0aW9ucxgNIAMoCzIRLmxucnBjLlJlc29sdXRpb24SEwoLYWxpYXNfc2NpZHMYDiADKAQSJAoYemVyb19jb25mX2NvbmZpcm1lZF9zY2lkGA8gASgEQgIwASKKAQoLQ2xvc3VyZVR5cGUSFQoRQ09PUEVSQVRJVkVfQ0xPU0UQABIVChFMT0NBTF9GT1JDRV9DTE9TRRABEhYKElJFTU9URV9GT1JDRV9DTE9TRRACEhAKDEJSRUFDSF9DTE9TRRADEhQKEEZVTkRJTkdfQ0FOQ0VMRUQQBBINCglBQkFORE9ORUQQBSKyAQoKUmVzb2x1dGlvbhIuCg9yZXNvbHV0aW9uX3R5cGUYASABKA4yFS5sbnJwYy5SZXNvbHV0aW9uVHlwZRIpCgdvdXRjb21lGAIgASgOMhgubG5ycGMuUmVzb2x1dGlvbk91dGNvbWUSIQoIb3V0cG9pbnQYAyABKAsyDy5sbnJwYy5PdXRQb2ludBISCgphbW91bnRfc2F0GAQgASgEEhIKCnN3ZWVwX3R4aWQYBSABKAkilAEKFUNsb3NlZENoYW5uZWxzUmVxdWVzdBITCgtjb29wZXJhdGl2ZRgBIAEoCBITCgtsb2NhbF9mb3JjZRgCIAEoCBIUCgxyZW1vdGVfZm9yY2UYAyABKAgSDgoGYnJlYWNoGAQgASgIEhgKEGZ1bmRpbmdfY2FuY2VsZWQYBSABKAgSEQoJYWJhbmRvbmVkGAYgASgIIkYKFkNsb3NlZENoYW5uZWxzUmVzcG9uc2USLAoIY2hhbm5lbHMYASADKAsyGi5sbnJwYy5DaGFubmVsQ2xvc2VTdW1tYXJ5Iu8DCgRQZWVyEg8KB3B1Yl9rZXkYASABKAkSDwoHYWRkcmVzcxgDIAEoCRISCgpieXRlc19zZW50GAQgASgEEhIKCmJ5dGVzX3JlY3YYBSABKAQSEAoIc2F0X3NlbnQYBiABKAMSEAoIc2F0X3JlY3YYByABKAMSDwoHaW5ib3VuZBgIIAEoCBIRCglwaW5nX3RpbWUYCSABKAMSJwoJc3luY190eXBlGAogASgOMhQubG5ycGMuUGVlci5TeW5jVHlwZRIrCghmZWF0dXJlcxgLIAMoCzIZLmxucnBjLlBlZXIuRmVhdHVyZXNFbnRyeRInCgZlcnJvcnMYDCADKAsyFy5sbnJwYy5UaW1lc3RhbXBlZEVycm9yEhIKCmZsYXBfY291bnQYDSABKAUSFAoMbGFzdF9mbGFwX25zGA4gASgDEhkKEWxhc3RfcGluZ19wYXlsb2FkGA8gASgMGj8KDUZlYXR1cmVzRW50cnkSCwoDa2V5GAEgASgNEh0KBXZhbHVlGAIgASgLMg4ubG5ycGMuRmVhdHVyZToCOAEiUAoIU3luY1R5cGUSEAoMVU5LTk9XTl9TWU5DEAASDwoLQUNUSVZFX1NZTkMQARIQCgxQQVNTSVZFX1NZTkMQAhIPCgtQSU5ORURfU1lOQxADIjQKEFRpbWVzdGFtcGVkRXJyb3ISEQoJdGltZXN0YW1wGAEgASgEEg0KBWVycm9yGAIgASgJIigKEExpc3RQZWVyc1JlcXVlc3QSFAoMbGF0ZXN0X2Vycm9yGAEgASgIIi8KEUxpc3RQZWVyc1Jlc3BvbnNlEhoKBXBlZXJzGAEgAygLMgsubG5ycGMuUGVlciIXChVQZWVyRXZlbnRTdWJzY3JpcHRpb24idgoJUGVlckV2ZW50Eg8KB3B1Yl9rZXkYASABKAkSKAoEdHlwZRgCIAEoDjIaLmxucnBjLlBlZXJFdmVudC5FdmVudFR5cGUiLgoJRXZlbnRUeXBlEg8KC1BFRVJfT05MSU5FEAASEAoMUEVFUl9PRkZMSU5FEAEiEAoOR2V0SW5mb1JlcXVlc3Qi3gQKD0dldEluZm9SZXNwb25zZRIPCgd2ZXJzaW9uGA4gASgJEhMKC2NvbW1pdF9oYXNoGBQgASgJEhcKD2lkZW50aXR5X3B1YmtleRgBIAEoCRINCgVhbGlhcxgCIAEoCRINCgVjb2xvchgRIAEoCRIcChRudW1fcGVuZGluZ19jaGFubmVscxgDIAEoDRIbChNudW1fYWN0aXZlX2NoYW5uZWxzGAQgASgNEh0KFW51bV9pbmFjdGl2ZV9jaGFubmVscxgPIAEoDRIRCgludW1fcGVlcnMYBSABKA0SFAoMYmxvY2tfaGVpZ2h0GAYgASgNEhIKCmJsb2NrX2hhc2gYCCABKAkSHQoVYmVzdF9oZWFkZXJfdGltZXN0YW1wGA0gASgDEhcKD3N5bmNlZF90b19jaGFpbhgJIAEoCBIXCg9zeW5jZWRfdG9fZ3JhcGgYEiABKAgSEwoHdGVzdG5ldBgKIAEoCEICGAESHAoGY2hhaW5zGBAgAygLMgwubG5ycGMuQ2hhaW4SDAoEdXJpcxgMIAMoCRI2CghmZWF0dXJlcxgTIAMoCzIkLmxucnBjLkdldEluZm9SZXNwb25zZS5GZWF0dXJlc0VudHJ5EiAKGHJlcXVpcmVfaHRsY19pbnRlcmNlcHRvchgVIAEoCBIkChxzdG9yZV9maW5hbF9odGxjX3Jlc29sdXRpb25zGBYgASgIGj8KDUZlYXR1cmVzRW50cnkSCwoDa2V5GAEgASgNEh0KBXZhbHVlGAIgASgLMg4ubG5ycGMuRmVhdHVyZToCOAFKBAgLEAwiGAoWR2V0UmVjb3ZlcnlJbmZvUmVxdWVzdCJdChdHZXRSZWNvdmVyeUluZm9SZXNwb25zZRIVCg1yZWNvdmVyeV9tb2RlGAEgASgIEhkKEXJlY292ZXJ5X2ZpbmlzaGVkGAIgASgIEhAKCHByb2dyZXNzGAMgASgBIicKBUNoYWluEg0KBWNoYWluGAEgASgJEg8KB25ldHdvcmsYAiABKAkiVQoSQ29uZmlybWF0aW9uVXBkYXRlEhEKCWJsb2NrX3NoYRgBIAEoDBIUCgxibG9ja19oZWlnaHQYAiABKAUSFgoObnVtX2NvbmZzX2xlZnQYAyABKA0iPwoRQ2hhbm5lbE9wZW5VcGRhdGUSKgoNY2hhbm5lbF9wb2ludBgBIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludCI7ChJDaGFubmVsQ2xvc2VVcGRhdGUSFAoMY2xvc2luZ190eGlkGAEgASgMEg8KB3N1Y2Nlc3MYAiABKAgiywEKE0Nsb3NlQ2hhbm5lbFJlcXVlc3QSKgoNY2hhbm5lbF9wb2ludBgBIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludBINCgVmb3JjZRgCIAEoCBITCgt0YXJnZXRfY29uZhgDIAEoBRIYCgxzYXRfcGVyX2J5dGUYBCABKANCAhgBEhgKEGRlbGl2ZXJ5X2FkZHJlc3MYBSABKAkSFQoNc2F0X3Blcl92Ynl0ZRgGIAEoBBIZChFtYXhfZmVlX3Blcl92Ynl0ZRgHIAEoBCJ9ChFDbG9zZVN0YXR1c1VwZGF0ZRItCg1jbG9zZV9wZW5kaW5nGAEgASgLMhQubG5ycGMuUGVuZGluZ1VwZGF0ZUgAEi8KCmNoYW5fY2xvc2UYAyABKAsyGS5sbnJwYy5DaGFubmVsQ2xvc2VVcGRhdGVIAEIICgZ1cGRhdGUiMwoNUGVuZGluZ1VwZGF0ZRIMCgR0eGlkGAEgASgMEhQKDG91dHB1dF9pbmRleBgCIAEoDSJUChNSZWFkeUZvclBzYnRGdW5kaW5nEhcKD2Z1bmRpbmdfYWRkcmVzcxgBIAEoCRIWCg5mdW5kaW5nX2Ftb3VudBgCIAEoAxIMCgRwc2J0GAMgASgMIq0BChdCYXRjaE9wZW5DaGFubmVsUmVxdWVzdBIpCghjaGFubmVscxgBIAMoCzIXLmxucnBjLkJhdGNoT3BlbkNoYW5uZWwSEwoLdGFyZ2V0X2NvbmYYAiABKAUSFQoNc2F0X3Blcl92Ynl0ZRgDIAEoAxIRCgltaW5fY29uZnMYBCABKAUSGQoRc3BlbmRfdW5jb25maXJtZWQYBSABKAgSDQoFbGFiZWwYBiABKAki+QMKEEJhdGNoT3BlbkNoYW5uZWwSEwoLbm9kZV9wdWJrZXkYASABKAwSHAoUbG9jYWxfZnVuZGluZ19hbW91bnQYAiABKAMSEAoIcHVzaF9zYXQYAyABKAMSDwoHcHJpdmF0ZRgEIAEoCBIVCg1taW5faHRsY19tc2F0GAUgASgDEhgKEHJlbW90ZV9jc3ZfZGVsYXkYBiABKA0SFQoNY2xvc2VfYWRkcmVzcxgHIAEoCRIXCg9wZW5kaW5nX2NoYW5faWQYCCABKAwSLgoPY29tbWl0bWVudF90eXBlGAkgASgOMhUubG5ycGMuQ29tbWl0bWVudFR5cGUSJwofcmVtb3RlX21heF92YWx1ZV9pbl9mbGlnaHRfbXNhdBgKIAEoBBIYChByZW1vdGVfbWF4X2h0bGNzGAsgASgNEhUKDW1heF9sb2NhbF9jc3YYDCABKA0SEQoJemVyb19jb25mGA0gASgIEhIKCnNjaWRfYWxpYXMYDiABKAgSEAoIYmFzZV9mZWUYDyABKAQSEAoIZmVlX3JhdGUYECABKAQSFAoMdXNlX2Jhc2VfZmVlGBEgASgIEhQKDHVzZV9mZWVfcmF0ZRgSIAEoCBIfChdyZW1vdGVfY2hhbl9yZXNlcnZlX3NhdBgTIAEoBBIMCgRtZW1vGBQgASgJIkoKGEJhdGNoT3BlbkNoYW5uZWxSZXNwb25zZRIuChBwZW5kaW5nX2NoYW5uZWxzGAEgAygLMhQubG5ycGMuUGVuZGluZ1VwZGF0ZSLWBQoST3BlbkNoYW5uZWxSZXF1ZXN0EhUKDXNhdF9wZXJfdmJ5dGUYASABKAQSEwoLbm9kZV9wdWJrZXkYAiABKAwSHgoSbm9kZV9wdWJrZXlfc3RyaW5nGAMgASgJQgIYARIcChRsb2NhbF9mdW5kaW5nX2Ftb3VudBgEIAEoAxIQCghwdXNoX3NhdBgFIAEoAxITCgt0YXJnZXRfY29uZhgGIAEoBRIYCgxzYXRfcGVyX2J5dGUYByABKANCAhgBEg8KB3ByaXZhdGUYCCABKAgSFQoNbWluX2h0bGNfbXNhdBgJIAEoAxIYChByZW1vdGVfY3N2X2RlbGF5GAogASgNEhEKCW1pbl9jb25mcxgLIAEoBRIZChFzcGVuZF91bmNvbmZpcm1lZBgMIAEoCBIVCg1jbG9zZV9hZGRyZXNzGA0gASgJEigKDGZ1bmRpbmdfc2hpbRgOIAEoCzISLmxucnBjLkZ1bmRpbmdTaGltEicKH3JlbW90ZV9tYXhfdmFsdWVfaW5fZmxpZ2h0X21zYXQYDyABKAQSGAoQcmVtb3RlX21heF9odGxjcxgQIAEoDRIVCg1tYXhfbG9jYWxfY3N2GBEgASgNEi4KD2NvbW1pdG1lbnRfdHlwZRgSIAEoDjIVLmxucnBjLkNvbW1pdG1lbnRUeXBlEhEKCXplcm9fY29uZhgTIAEoCBISCgpzY2lkX2FsaWFzGBQgASgIEhAKCGJhc2VfZmVlGBUgASgEEhAKCGZlZV9yYXRlGBYgASgEEhQKDHVzZV9iYXNlX2ZlZRgXIAEoCBIUCgx1c2VfZmVlX3JhdGUYGCABKAgSHwoXcmVtb3RlX2NoYW5fcmVzZXJ2ZV9zYXQYGSABKAQSEAoIZnVuZF9tYXgYGiABKAgSDAoEbWVtbxgbIAEoCRIiCglvdXRwb2ludHMYHCADKAsyDy5sbnJwYy5PdXRQb2ludCLDAQoQT3BlblN0YXR1c1VwZGF0ZRIsCgxjaGFuX3BlbmRpbmcYASABKAsyFC5sbnJwYy5QZW5kaW5nVXBkYXRlSAASLQoJY2hhbl9vcGVuGAMgASgLMhgubG5ycGMuQ2hhbm5lbE9wZW5VcGRhdGVIABIvCglwc2J0X2Z1bmQYBSABKAsyGi5sbnJwYy5SZWFkeUZvclBzYnRGdW5kaW5nSAASFwoPcGVuZGluZ19jaGFuX2lkGAQgASgMQggKBnVwZGF0ZSIzCgpLZXlMb2NhdG9yEhIKCmtleV9mYW1pbHkYASABKAUSEQoJa2V5X2luZGV4GAIgASgFIkoKDUtleURlc2NyaXB0b3ISFQoNcmF3X2tleV9ieXRlcxgBIAEoDBIiCgdrZXlfbG9jGAIgASgLMhEubG5ycGMuS2V5TG9jYXRvciLAAQoNQ2hhblBvaW50U2hpbRILCgNhbXQYASABKAMSJwoKY2hhbl9wb2ludBgCIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludBInCglsb2NhbF9rZXkYAyABKAsyFC5sbnJwYy5LZXlEZXNjcmlwdG9yEhIKCnJlbW90ZV9rZXkYBCABKAwSFwoPcGVuZGluZ19jaGFuX2lkGAUgASgMEhMKC3RoYXdfaGVpZ2h0GAYgASgNEg4KBm11c2lnMhgHIAEoCCJKCghQc2J0U2hpbRIXCg9wZW5kaW5nX2NoYW5faWQYASABKAwSEQoJYmFzZV9wc2J0GAIgASgMEhIKCm5vX3B1Ymxpc2gYAyABKAgibAoLRnVuZGluZ1NoaW0SLwoPY2hhbl9wb2ludF9zaGltGAEgASgLMhQubG5ycGMuQ2hhblBvaW50U2hpbUgAEiQKCXBzYnRfc2hpbRgCIAEoCzIPLmxucnBjLlBzYnRTaGltSABCBgoEc2hpbSIsChFGdW5kaW5nU2hpbUNhbmNlbBIXCg9wZW5kaW5nX2NoYW5faWQYASABKAwiWAoRRnVuZGluZ1BzYnRWZXJpZnkSEwoLZnVuZGVkX3BzYnQYASABKAwSFwoPcGVuZGluZ19jaGFuX2lkGAIgASgMEhUKDXNraXBfZmluYWxpemUYAyABKAgiWQoTRnVuZGluZ1BzYnRGaW5hbGl6ZRITCgtzaWduZWRfcHNidBgBIAEoDBIXCg9wZW5kaW5nX2NoYW5faWQYAiABKAwSFAoMZmluYWxfcmF3X3R4GAMgASgMIuUBChRGdW5kaW5nVHJhbnNpdGlvbk1zZxIrCg1zaGltX3JlZ2lzdGVyGAEgASgLMhIubG5ycGMuRnVuZGluZ1NoaW1IABIvCgtzaGltX2NhbmNlbBgCIAEoCzIYLmxucnBjLkZ1bmRpbmdTaGltQ2FuY2VsSAASLwoLcHNidF92ZXJpZnkYAyABKAsyGC5sbnJwYy5GdW5kaW5nUHNidFZlcmlmeUgAEjMKDXBzYnRfZmluYWxpemUYBCABKAsyGi5sbnJwYy5GdW5kaW5nUHNidEZpbmFsaXplSABCCQoHdHJpZ2dlciIWChRGdW5kaW5nU3RhdGVTdGVwUmVzcCKGAQoLUGVuZGluZ0hUTEMSEAoIaW5jb21pbmcYASABKAgSDgoGYW1vdW50GAIgASgDEhAKCG91dHBvaW50GAMgASgJEhcKD21hdHVyaXR5X2hlaWdodBgEIAEoDRIbChNibG9ja3NfdGlsX21hdHVyaXR5GAUgASgFEg0KBXN0YWdlGAYgASgNIhgKFlBlbmRpbmdDaGFubmVsc1JlcXVlc3QipA4KF1BlbmRpbmdDaGFubmVsc1Jlc3BvbnNlEhsKE3RvdGFsX2xpbWJvX2JhbGFuY2UYASABKAMSUAoVcGVuZGluZ19vcGVuX2NoYW5uZWxzGAIgAygLMjEubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2UuUGVuZGluZ09wZW5DaGFubmVsElIKGHBlbmRpbmdfY2xvc2luZ19jaGFubmVscxgDIAMoCzIsLmxucnBjLlBlbmRpbmdDaGFubmVsc1Jlc3BvbnNlLkNsb3NlZENoYW5uZWxCAhgBElkKHnBlbmRpbmdfZm9yY2VfY2xvc2luZ19jaGFubmVscxgEIAMoCzIxLmxucnBjLlBlbmRpbmdDaGFubmVsc1Jlc3BvbnNlLkZvcmNlQ2xvc2VkQ2hhbm5lbBJSChZ3YWl0aW5nX2Nsb3NlX2NoYW5uZWxzGAUgAygLMjIubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2UuV2FpdGluZ0Nsb3NlQ2hhbm5lbBryAgoOUGVuZGluZ0NoYW5uZWwSFwoPcmVtb3RlX25vZGVfcHViGAEgASgJEhUKDWNoYW5uZWxfcG9pbnQYAiABKAkSEAoIY2FwYWNpdHkYAyABKAMSFQoNbG9jYWxfYmFsYW5jZRgEIAEoAxIWCg5yZW1vdGVfYmFsYW5jZRgFIAEoAxIeChZsb2NhbF9jaGFuX3Jlc2VydmVfc2F0GAYgASgDEh8KF3JlbW90ZV9jaGFuX3Jlc2VydmVfc2F0GAcgASgDEiMKCWluaXRpYXRvchgIIAEoDjIQLmxucnBjLkluaXRpYXRvchIuCg9jb21taXRtZW50X3R5cGUYCSABKA4yFS5sbnJwYy5Db21taXRtZW50VHlwZRIfChdudW1fZm9yd2FyZGluZ19wYWNrYWdlcxgKIAEoAxIZChFjaGFuX3N0YXR1c19mbGFncxgLIAEoCRIPCgdwcml2YXRlGAwgASgIEgwKBG1lbW8YDSABKAkauAEKElBlbmRpbmdPcGVuQ2hhbm5lbBI+CgdjaGFubmVsGAEgASgLMi0ubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2UuUGVuZGluZ0NoYW5uZWwSEgoKY29tbWl0X2ZlZRgEIAEoAxIVCg1jb21taXRfd2VpZ2h0GAUgASgDEhIKCmZlZV9wZXJfa3cYBiABKAMSHQoVZnVuZGluZ19leHBpcnlfYmxvY2tzGAMgASgFSgQIAhADGsMBChNXYWl0aW5nQ2xvc2VDaGFubmVsEj4KB2NoYW5uZWwYASABKAsyLS5sbnJwYy5QZW5kaW5nQ2hhbm5lbHNSZXNwb25zZS5QZW5kaW5nQ2hhbm5lbBIVCg1saW1ib19iYWxhbmNlGAIgASgDEj8KC2NvbW1pdG1lbnRzGAMgASgLMioubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2UuQ29tbWl0bWVudHMSFAoMY2xvc2luZ190eGlkGAQgASgJGrcBCgtDb21taXRtZW50cxISCgpsb2NhbF90eGlkGAEgASgJEhMKC3JlbW90ZV90eGlkGAIgASgJEhsKE3JlbW90ZV9wZW5kaW5nX3R4aWQYAyABKAkSHAoUbG9jYWxfY29tbWl0X2ZlZV9zYXQYBCABKAQSHQoVcmVtb3RlX2NvbW1pdF9mZWVfc2F0GAUgASgEEiUKHXJlbW90ZV9wZW5kaW5nX2NvbW1pdF9mZWVfc2F0GAYgASgEGmUKDUNsb3NlZENoYW5uZWwSPgoHY2hhbm5lbBgBIAEoCzItLmxucnBjLlBlbmRpbmdDaGFubmVsc1Jlc3BvbnNlLlBlbmRpbmdDaGFubmVsEhQKDGNsb3NpbmdfdHhpZBgCIAEoCRr/AgoSRm9yY2VDbG9zZWRDaGFubmVsEj4KB2NoYW5uZWwYASABKAsyLS5sbnJwYy5QZW5kaW5nQ2hhbm5lbHNSZXNwb25zZS5QZW5kaW5nQ2hhbm5lbBIUCgxjbG9zaW5nX3R4aWQYAiABKAkSFQoNbGltYm9fYmFsYW5jZRgDIAEoAxIXCg9tYXR1cml0eV9oZWlnaHQYBCABKA0SGwoTYmxvY2tzX3RpbF9tYXR1cml0eRgFIAEoBRIZChFyZWNvdmVyZWRfYmFsYW5jZRgGIAEoAxIpCg1wZW5kaW5nX2h0bGNzGAggAygLMhIubG5ycGMuUGVuZGluZ0hUTEMSTQoGYW5jaG9yGAkgASgOMj0ubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2UuRm9yY2VDbG9zZWRDaGFubmVsLkFuY2hvclN0YXRlIjEKC0FuY2hvclN0YXRlEgkKBUxJTUJPEAASDQoJUkVDT1ZFUkVEEAESCAoETE9TVBACIhoKGENoYW5uZWxFdmVudFN1YnNjcmlwdGlvbiKTBAoSQ2hhbm5lbEV2ZW50VXBkYXRlEiYKDG9wZW5fY2hhbm5lbBgBIAEoCzIOLmxucnBjLkNoYW5uZWxIABI0Cg5jbG9zZWRfY2hhbm5lbBgCIAEoCzIaLmxucnBjLkNoYW5uZWxDbG9zZVN1bW1hcnlIABItCg5hY3RpdmVfY2hhbm5lbBgDIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludEgAEi8KEGluYWN0aXZlX2NoYW5uZWwYBCABKAsyEy5sbnJwYy5DaGFubmVsUG9pbnRIABI0ChRwZW5kaW5nX29wZW5fY2hhbm5lbBgGIAEoCzIULmxucnBjLlBlbmRpbmdVcGRhdGVIABI1ChZmdWxseV9yZXNvbHZlZF9jaGFubmVsGAcgASgLMhMubG5ycGMuQ2hhbm5lbFBvaW50SAASMgoEdHlwZRgFIAEoDjIkLmxucnBjLkNoYW5uZWxFdmVudFVwZGF0ZS5VcGRhdGVUeXBlIpIBCgpVcGRhdGVUeXBlEhAKDE9QRU5fQ0hBTk5FTBAAEhIKDkNMT1NFRF9DSEFOTkVMEAESEgoOQUNUSVZFX0NIQU5ORUwQAhIUChBJTkFDVElWRV9DSEFOTkVMEAMSGAoUUEVORElOR19PUEVOX0NIQU5ORUwQBBIaChZGVUxMWV9SRVNPTFZFRF9DSEFOTkVMEAVCCQoHY2hhbm5lbCJOChRXYWxsZXRBY2NvdW50QmFsYW5jZRIZChFjb25maXJtZWRfYmFsYW5jZRgBIAEoAxIbChN1bmNvbmZpcm1lZF9iYWxhbmNlGAIgASgDIicKFFdhbGxldEJhbGFuY2VSZXF1ZXN0Eg8KB2FjY291bnQYASABKAkiwwIKFVdhbGxldEJhbGFuY2VSZXNwb25zZRIVCg10b3RhbF9iYWxhbmNlGAEgASgDEhkKEWNvbmZpcm1lZF9iYWxhbmNlGAIgASgDEhsKE3VuY29uZmlybWVkX2JhbGFuY2UYAyABKAMSFgoObG9ja2VkX2JhbGFuY2UYBSABKAMSJAoccmVzZXJ2ZWRfYmFsYW5jZV9hbmNob3JfY2hhbhgGIAEoAxJJCg9hY2NvdW50X2JhbGFuY2UYBCADKAsyMC5sbnJwYy5XYWxsZXRCYWxhbmNlUmVzcG9uc2UuQWNjb3VudEJhbGFuY2VFbnRyeRpSChNBY2NvdW50QmFsYW5jZUVudHJ5EgsKA2tleRgBIAEoCRIqCgV2YWx1ZRgCIAEoCzIbLmxucnBjLldhbGxldEFjY291bnRCYWxhbmNlOgI4ASIjCgZBbW91bnQSCwoDc2F0GAEgASgEEgwKBG1zYXQYAiABKAQiFwoVQ2hhbm5lbEJhbGFuY2VSZXF1ZXN0IuQCChZDaGFubmVsQmFsYW5jZVJlc3BvbnNlEhMKB2JhbGFuY2UYASABKANCAhgBEiAKFHBlbmRpbmdfb3Blbl9iYWxhbmNlGAIgASgDQgIYARIkCg1sb2NhbF9iYWxhbmNlGAMgASgLMg0ubG5ycGMuQW1vdW50EiUKDnJlbW90ZV9iYWxhbmNlGAQgASgLMg0ubG5ycGMuQW1vdW50Ei4KF3Vuc2V0dGxlZF9sb2NhbF9iYWxhbmNlGAUgASgLMg0ubG5ycGMuQW1vdW50Ei8KGHVuc2V0dGxlZF9yZW1vdGVfYmFsYW5jZRgGIAEoCzINLmxucnBjLkFtb3VudBIxChpwZW5kaW5nX29wZW5fbG9jYWxfYmFsYW5jZRgHIAEoCzINLmxucnBjLkFtb3VudBIyChtwZW5kaW5nX29wZW5fcmVtb3RlX2JhbGFuY2UYCCABKAsyDS5sbnJwYy5BbW91bnQi4wQKElF1ZXJ5Um91dGVzUmVxdWVzdBIPCgdwdWJfa2V5GAEgASgJEgsKA2FtdBgCIAEoAxIQCghhbXRfbXNhdBgMIAEoAxIYChBmaW5hbF9jbHR2X2RlbHRhGAQgASgFEiIKCWZlZV9saW1pdBgFIAEoCzIPLmxucnBjLkZlZUxpbWl0EhUKDWlnbm9yZWRfbm9kZXMYBiADKAwSLQoNaWdub3JlZF9lZGdlcxgHIAMoCzISLmxucnBjLkVkZ2VMb2NhdG9yQgIYARIWCg5zb3VyY2VfcHViX2tleRgIIAEoCRIbChN1c2VfbWlzc2lvbl9jb250cm9sGAkgASgIEiYKDWlnbm9yZWRfcGFpcnMYCiADKAsyDy5sbnJwYy5Ob2RlUGFpchISCgpjbHR2X2xpbWl0GAsgASgNEk0KE2Rlc3RfY3VzdG9tX3JlY29yZHMYDSADKAsyMC5sbnJwYy5RdWVyeVJvdXRlc1JlcXVlc3QuRGVzdEN1c3RvbVJlY29yZHNFbnRyeRIcChBvdXRnb2luZ19jaGFuX2lkGA4gASgEQgIwARIXCg9sYXN0X2hvcF9wdWJrZXkYDyABKAwSJQoLcm91dGVfaGludHMYECADKAsyEC5sbnJwYy5Sb3V0ZUhpbnQSKAoNZGVzdF9mZWF0dXJlcxgRIAMoDjIRLmxucnBjLkZlYXR1cmVCaXQSEQoJdGltZV9wcmVmGBIgASgBGjgKFkRlc3RDdXN0b21SZWNvcmRzRW50cnkSCwoDa2V5GAEgASgEEg0KBXZhbHVlGAIgASgMOgI4AUoECAMQBCIkCghOb2RlUGFpchIMCgRmcm9tGAEgASgMEgoKAnRvGAIgASgMIkAKC0VkZ2VMb2NhdG9yEhYKCmNoYW5uZWxfaWQYASABKARCAjABEhkKEWRpcmVjdGlvbl9yZXZlcnNlGAIgASgIIkkKE1F1ZXJ5Um91dGVzUmVzcG9uc2USHAoGcm91dGVzGAEgAygLMgwubG5ycGMuUm91dGUSFAoMc3VjY2Vzc19wcm9iGAIgASgBIpYDCgNIb3ASEwoHY2hhbl9pZBgBIAEoBEICMAESGQoNY2hhbl9jYXBhY2l0eRgCIAEoA0ICGAESGgoOYW10X3RvX2ZvcndhcmQYAyABKANCAhgBEg8KA2ZlZRgEIAEoA0ICGAESDgoGZXhwaXJ5GAUgASgNEhsKE2FtdF90b19mb3J3YXJkX21zYXQYBiABKAMSEAoIZmVlX21zYXQYByABKAMSDwoHcHViX2tleRgIIAEoCRIXCgt0bHZfcGF5bG9hZBgJIAEoCEICGAESJAoKbXBwX3JlY29yZBgKIAEoCzIQLmxucnBjLk1QUFJlY29yZBIkCgphbXBfcmVjb3JkGAwgASgLMhAubG5ycGMuQU1QUmVjb3JkEjUKDmN1c3RvbV9yZWNvcmRzGAsgAygLMh0ubG5ycGMuSG9wLkN1c3RvbVJlY29yZHNFbnRyeRIQCghtZXRhZGF0YRgNIAEoDBo0ChJDdXN0b21SZWNvcmRzRW50cnkSCwoDa2V5GAEgASgEEg0KBXZhbHVlGAIgASgMOgI4ASI5CglNUFBSZWNvcmQSFAoMcGF5bWVudF9hZGRyGAsgASgMEhYKDnRvdGFsX2FtdF9tc2F0GAogASgDIkQKCUFNUFJlY29yZBISCgpyb290X3NoYXJlGAEgASgMEg4KBnNldF9pZBgCIAEoDBITCgtjaGlsZF9pbmRleBgDIAEoDSKaAQoFUm91dGUSFwoPdG90YWxfdGltZV9sb2NrGAEgASgNEhYKCnRvdGFsX2ZlZXMYAiABKANCAhgBEhUKCXRvdGFsX2FtdBgDIAEoA0ICGAESGAoEaG9wcxgEIAMoCzIKLmxucnBjLkhvcBIXCg90b3RhbF9mZWVzX21zYXQYBSABKAMSFgoOdG90YWxfYW10X21zYXQYBiABKAMiPAoPTm9kZUluZm9SZXF1ZXN0Eg8KB3B1Yl9rZXkYASABKAkSGAoQaW5jbHVkZV9jaGFubmVscxgCIAEoCCKCAQoITm9kZUluZm8SIgoEbm9kZRgBIAEoCzIULmxucnBjLkxpZ2h0bmluZ05vZGUSFAoMbnVtX2NoYW5uZWxzGAIgASgNEhYKDnRvdGFsX2NhcGFjaXR5GAMgASgDEiQKCGNoYW5uZWxzGAQgAygLMhIubG5ycGMuQ2hhbm5lbEVkZ2Ui6AIKDUxpZ2h0bmluZ05vZGUSEwoLbGFzdF91cGRhdGUYASABKA0SDwoHcHViX2tleRgCIAEoCRINCgVhbGlhcxgDIAEoCRIlCglhZGRyZXNzZXMYBCADKAsyEi5sbnJwYy5Ob2RlQWRkcmVzcxINCgVjb2xvchgFIAEoCRI0CghmZWF0dXJlcxgGIAMoCzIiLmxucnBjLkxpZ2h0bmluZ05vZGUuRmVhdHVyZXNFbnRyeRI/Cg5jdXN0b21fcmVjb3JkcxgHIAMoCzInLmxucnBjLkxpZ2h0bmluZ05vZGUuQ3VzdG9tUmVjb3Jkc0VudHJ5Gj8KDUZlYXR1cmVzRW50cnkSCwoDa2V5GAEgASgNEh0KBXZhbHVlGAIgASgLMg4ubG5ycGMuRmVhdHVyZToCOAEaNAoSQ3VzdG9tUmVjb3Jkc0VudHJ5EgsKA2tleRgBIAEoBBINCgV2YWx1ZRgCIAEoDDoCOAEiLAoLTm9kZUFkZHJlc3MSDwoHbmV0d29yaxgBIAEoCRIMCgRhZGRyGAIgASgJIqMCCg1Sb3V0aW5nUG9saWN5EhcKD3RpbWVfbG9ja19kZWx0YRgBIAEoDRIQCghtaW5faHRsYxgCIAEoAxIVCg1mZWVfYmFzZV9tc2F0GAMgASgDEhsKE2ZlZV9yYXRlX21pbGxpX21zYXQYBCABKAMSEAoIZGlzYWJsZWQYBSABKAgSFQoNbWF4X2h0bGNfbXNhdBgGIAEoBBITCgtsYXN0X3VwZGF0ZRgHIAEoDRI/Cg5jdXN0b21fcmVjb3JkcxgIIAMoCzInLmxucnBjLlJvdXRpbmdQb2xpY3kuQ3VzdG9tUmVjb3Jkc0VudHJ5GjQKEkN1c3RvbVJlY29yZHNFbnRyeRILCgNrZXkYASABKAQSDQoFdmFsdWUYAiABKAw6AjgBItcCCgtDaGFubmVsRWRnZRIWCgpjaGFubmVsX2lkGAEgASgEQgIwARISCgpjaGFuX3BvaW50GAIgASgJEhcKC2xhc3RfdXBkYXRlGAMgASgNQgIYARIRCglub2RlMV9wdWIYBCABKAkSEQoJbm9kZTJfcHViGAUgASgJEhAKCGNhcGFjaXR5GAYgASgDEioKDG5vZGUxX3BvbGljeRgHIAEoCzIULmxucnBjLlJvdXRpbmdQb2xpY3kSKgoMbm9kZTJfcG9saWN5GAggASgLMhQubG5ycGMuUm91dGluZ1BvbGljeRI9Cg5jdXN0b21fcmVjb3JkcxgJIAMoCzIlLmxucnBjLkNoYW5uZWxFZGdlLkN1c3RvbVJlY29yZHNFbnRyeRo0ChJDdXN0b21SZWNvcmRzRW50cnkSCwoDa2V5GAEgASgEEg0KBXZhbHVlGAIgASgMOgI4ASIyChNDaGFubmVsR3JhcGhSZXF1ZXN0EhsKE2luY2x1ZGVfdW5hbm5vdW5jZWQYASABKAgiVgoMQ2hhbm5lbEdyYXBoEiMKBW5vZGVzGAEgAygLMhQubG5ycGMuTGlnaHRuaW5nTm9kZRIhCgVlZGdlcxgCIAMoCzISLmxucnBjLkNoYW5uZWxFZGdlIjoKEk5vZGVNZXRyaWNzUmVxdWVzdBIkCgV0eXBlcxgBIAMoDjIVLmxucnBjLk5vZGVNZXRyaWNUeXBlIr4BChNOb2RlTWV0cmljc1Jlc3BvbnNlElUKFmJldHdlZW5uZXNzX2NlbnRyYWxpdHkYASADKAsyNS5sbnJwYy5Ob2RlTWV0cmljc1Jlc3BvbnNlLkJldHdlZW5uZXNzQ2VudHJhbGl0eUVudHJ5GlAKGkJldHdlZW5uZXNzQ2VudHJhbGl0eUVudHJ5EgsKA2tleRgBIAEoCRIhCgV2YWx1ZRgCIAEoCzISLmxucnBjLkZsb2F0TWV0cmljOgI4ASI2CgtGbG9hdE1ldHJpYxINCgV2YWx1ZRgBIAEoARIYChBub3JtYWxpemVkX3ZhbHVlGAIgASgBIiYKD0NoYW5JbmZvUmVxdWVzdBITCgdjaGFuX2lkGAEgASgEQgIwASIUChJOZXR3b3JrSW5mb1JlcXVlc3QipwIKC05ldHdvcmtJbmZvEhYKDmdyYXBoX2RpYW1ldGVyGAEgASgNEhYKDmF2Z19vdXRfZGVncmVlGAIgASgBEhYKDm1heF9vdXRfZGVncmVlGAMgASgNEhEKCW51bV9ub2RlcxgEIAEoDRIUCgxudW1fY2hhbm5lbHMYBSABKA0SHgoWdG90YWxfbmV0d29ya19jYXBhY2l0eRgGIAEoAxIYChBhdmdfY2hhbm5lbF9zaXplGAcgASgBEhgKEG1pbl9jaGFubmVsX3NpemUYCCABKAMSGAoQbWF4X2NoYW5uZWxfc2l6ZRgJIAEoAxIfChdtZWRpYW5fY2hhbm5lbF9zaXplX3NhdBgKIAEoAxIYChBudW1fem9tYmllX2NoYW5zGAsgASgEIg0KC1N0b3BSZXF1ZXN0Ig4KDFN0b3BSZXNwb25zZSIbChlHcmFwaFRvcG9sb2d5U3Vic2NyaXB0aW9uIqMBChNHcmFwaFRvcG9sb2d5VXBkYXRlEicKDG5vZGVfdXBkYXRlcxgBIAMoCzIRLmxucnBjLk5vZGVVcGRhdGUSMQoPY2hhbm5lbF91cGRhdGVzGAIgAygLMhgubG5ycGMuQ2hhbm5lbEVkZ2VVcGRhdGUSMAoMY2xvc2VkX2NoYW5zGAMgAygLMhoubG5ycGMuQ2xvc2VkQ2hhbm5lbFVwZGF0ZSKUAgoKTm9kZVVwZGF0ZRIVCglhZGRyZXNzZXMYASADKAlCAhgBEhQKDGlkZW50aXR5X2tleRgCIAEoCRIbCg9nbG9iYWxfZmVhdHVyZXMYAyABKAxCAhgBEg0KBWFsaWFzGAQgASgJEg0KBWNvbG9yGAUgASgJEioKDm5vZGVfYWRkcmVzc2VzGAcgAygLMhIubG5ycGMuTm9kZUFkZHJlc3MSMQoIZmVhdHVyZXMYBiADKAsyHy5sbnJwYy5Ob2RlVXBkYXRlLkZlYXR1cmVzRW50cnkaPwoNRmVhdHVyZXNFbnRyeRILCgNrZXkYASABKA0SHQoFdmFsdWUYAiABKAsyDi5sbnJwYy5GZWF0dXJlOgI4ASLEAQoRQ2hhbm5lbEVkZ2VVcGRhdGUSEwoHY2hhbl9pZBgBIAEoBEICMAESJwoKY2hhbl9wb2ludBgCIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludBIQCghjYXBhY2l0eRgDIAEoAxIsCg5yb3V0aW5nX3BvbGljeRgEIAEoCzIULmxucnBjLlJvdXRpbmdQb2xpY3kSGAoQYWR2ZXJ0aXNpbmdfbm9kZRgFIAEoCRIXCg9jb25uZWN0aW5nX25vZGUYBiABKAkifAoTQ2xvc2VkQ2hhbm5lbFVwZGF0ZRITCgdjaGFuX2lkGAEgASgEQgIwARIQCghjYXBhY2l0eRgCIAEoAxIVCg1jbG9zZWRfaGVpZ2h0GAMgASgNEicKCmNoYW5fcG9pbnQYBCABKAsyEy5sbnJwYy5DaGFubmVsUG9pbnQihgEKB0hvcEhpbnQSDwoHbm9kZV9pZBgBIAEoCRITCgdjaGFuX2lkGAIgASgEQgIwARIVCg1mZWVfYmFzZV9tc2F0GAMgASgNEiMKG2ZlZV9wcm9wb3J0aW9uYWxfbWlsbGlvbnRocxgEIAEoDRIZChFjbHR2X2V4cGlyeV9kZWx0YRgFIAEoDSIXCgVTZXRJRBIOCgZzZXRfaWQYASABKAwiLgoJUm91dGVIaW50EiEKCWhvcF9oaW50cxgBIAMoCzIOLmxucnBjLkhvcEhpbnQiewoPQU1QSW52b2ljZVN0YXRlEiYKBXN0YXRlGAEgASgOMhcubG5ycGMuSW52b2ljZUhUTENTdGF0ZRIUCgxzZXR0bGVfaW5kZXgYAiABKAQSEwoLc2V0dGxlX3RpbWUYAyABKAMSFQoNYW10X3BhaWRfbXNhdBgFIAEoAyKcBwoHSW52b2ljZRIMCgRtZW1vGAEgASgJEhIKCnJfcHJlaW1hZ2UYAyABKAwSDgoGcl9oYXNoGAQgASgMEg0KBXZhbHVlGAUgASgDEhIKCnZhbHVlX21zYXQYFyABKAMSEwoHc2V0dGxlZBgGIAEoCEICGAESFQoNY3JlYXRpb25fZGF0ZRgHIAEoAxITCgtzZXR0bGVfZGF0ZRgIIAEoAxIXCg9wYXltZW50X3JlcXVlc3QYCSABKAkSGAoQZGVzY3JpcHRpb25faGFzaBgKIAEoDBIOCgZleHBpcnkYCyABKAMSFQoNZmFsbGJhY2tfYWRkchgMIAEoCRITCgtjbHR2X2V4cGlyeRgNIAEoBBIlCgtyb3V0ZV9oaW50cxgOIAMoCzIQLmxucnBjLlJvdXRlSGludBIPCgdwcml2YXRlGA8gASgIEhEKCWFkZF9pbmRleBgQIAEoBBIUCgxzZXR0bGVfaW5kZXgYESABKAQSFAoIYW10X3BhaWQYEiABKANCAhgBEhQKDGFtdF9wYWlkX3NhdBgTIAEoAxIVCg1hbXRfcGFpZF9tc2F0GBQgASgDEioKBXN0YXRlGBUgASgOMhsubG5ycGMuSW52b2ljZS5JbnZvaWNlU3RhdGUSIQoFaHRsY3MYFiADKAsyEi5sbnJwYy5JbnZvaWNlSFRMQxIuCghmZWF0dXJlcxgYIAMoCzIcLmxucnBjLkludm9pY2UuRmVhdHVyZXNFbnRyeRISCgppc19rZXlzZW5kGBkgASgIEhQKDHBheW1lbnRfYWRkchgaIAEoDBIOCgZpc19hbXAYGyABKAgSPgoRYW1wX2ludm9pY2Vfc3RhdGUYHCADKAsyIy5sbnJwYy5JbnZvaWNlLkFtcEludm9pY2VTdGF0ZUVudHJ5EhUKDW1pbl9ob3BfaGludHMYHSABKAUaPwoNRmVhdHVyZXNFbnRyeRILCgNrZXkYASABKA0SHQoFdmFsdWUYAiABKAsyDi5sbnJwYy5GZWF0dXJlOgI4ARpOChRBbXBJbnZvaWNlU3RhdGVFbnRyeRILCgNrZXkYASABKAkSJQoFdmFsdWUYAiABKAsyFi5sbnJwYy5BTVBJbnZvaWNlU3RhdGU6AjgBIkEKDEludm9pY2VTdGF0ZRIICgRPUEVOEAASCwoHU0VUVExFRBABEgwKCENBTkNFTEVEEAISDAoIQUNDRVBURUQQA0oECAIQAyLzAgoLSW52b2ljZUhUTEMSEwoHY2hhbl9pZBgBIAEoBEICMAESEgoKaHRsY19pbmRleBgCIAEoBBIQCghhbXRfbXNhdBgDIAEoBBIVCg1hY2NlcHRfaGVpZ2h0GAQgASgFEhMKC2FjY2VwdF90aW1lGAUgASgDEhQKDHJlc29sdmVfdGltZRgGIAEoAxIVCg1leHBpcnlfaGVpZ2h0GAcgASgFEiYKBXN0YXRlGAggASgOMhcubG5ycGMuSW52b2ljZUhUTENTdGF0ZRI9Cg5jdXN0b21fcmVjb3JkcxgJIAMoCzIlLmxucnBjLkludm9pY2VIVExDLkN1c3RvbVJlY29yZHNFbnRyeRIaChJtcHBfdG90YWxfYW10X21zYXQYCiABKAQSFwoDYW1wGAsgASgLMgoubG5ycGMuQU1QGjQKEkN1c3RvbVJlY29yZHNFbnRyeRILCgNrZXkYASABKAQSDQoFdmFsdWUYAiABKAw6AjgBIl4KA0FNUBISCgpyb290X3NoYXJlGAEgASgMEg4KBnNldF9pZBgCIAEoDBITCgtjaGlsZF9pbmRleBgDIAEoDRIMCgRoYXNoGAQgASgMEhAKCHByZWltYWdlGAUgASgMImYKEkFkZEludm9pY2VSZXNwb25zZRIOCgZyX2hhc2gYASABKAwSFwoPcGF5bWVudF9yZXF1ZXN0GAIgASgJEhEKCWFkZF9pbmRleBgQIAEoBBIUCgxwYXltZW50X2FkZHIYESABKAwiNQoLUGF5bWVudEhhc2gSFgoKcl9oYXNoX3N0chgBIAEoCUICGAESDgoGcl9oYXNoGAIgASgMIqQBChJMaXN0SW52b2ljZVJlcXVlc3QSFAoMcGVuZGluZ19vbmx5GAEgASgIEhQKDGluZGV4X29mZnNldBgEIAEoBBIYChBudW1fbWF4X2ludm9pY2VzGAUgASgEEhAKCHJldmVyc2VkGAYgASgIEhsKE2NyZWF0aW9uX2RhdGVfc3RhcnQYByABKAQSGQoRY3JlYXRpb25fZGF0ZV9lbmQYCCABKAQibgoTTGlzdEludm9pY2VSZXNwb25zZRIgCghpbnZvaWNlcxgBIAMoCzIOLmxucnBjLkludm9pY2USGQoRbGFzdF9pbmRleF9vZmZzZXQYAiABKAQSGgoSZmlyc3RfaW5kZXhfb2Zmc2V0GAMgASgEIj4KE0ludm9pY2VTdWJzY3JpcHRpb24SEQoJYWRkX2luZGV4GAEgASgEEhQKDHNldHRsZV9pbmRleBgCIAEoBCLgAwoHUGF5bWVudBIUCgxwYXltZW50X2hhc2gYASABKAkSEQoFdmFsdWUYAiABKANCAhgBEhkKDWNyZWF0aW9uX2RhdGUYAyABKANCAhgBEg8KA2ZlZRgFIAEoA0ICGAESGAoQcGF5bWVudF9wcmVpbWFnZRgGIAEoCRIRCgl2YWx1ZV9zYXQYByABKAMSEgoKdmFsdWVfbXNhdBgIIAEoAxIXCg9wYXltZW50X3JlcXVlc3QYCSABKAkSLAoGc3RhdHVzGAogASgOMhwubG5ycGMuUGF5bWVudC5QYXltZW50U3RhdHVzEg8KB2ZlZV9zYXQYCyABKAMSEAoIZmVlX21zYXQYDCABKAMSGAoQY3JlYXRpb25fdGltZV9ucxgNIAEoAxIhCgVodGxjcxgOIAMoCzISLmxucnBjLkhUTENBdHRlbXB0EhUKDXBheW1lbnRfaW5kZXgYDyABKAQSMwoOZmFpbHVyZV9yZWFzb24YECABKA4yGy5sbnJwYy5QYXltZW50RmFpbHVyZVJlYXNvbiJGCg1QYXltZW50U3RhdHVzEgsKB1VOS05PV04QABINCglJTl9GTElHSFQQARINCglTVUNDRUVERUQQAhIKCgZGQUlMRUQQA0oECAQQBSKKAgoLSFRMQ0F0dGVtcHQSEgoKYXR0ZW1wdF9pZBgHIAEoBBItCgZzdGF0dXMYASABKA4yHS5sbnJwYy5IVExDQXR0ZW1wdC5IVExDU3RhdHVzEhsKBXJvdXRlGAIgASgLMgwubG5ycGMuUm91dGUSFwoPYXR0ZW1wdF90aW1lX25zGAMgASgDEhcKD3Jlc29sdmVfdGltZV9ucxgEIAEoAxIfCgdmYWlsdXJlGAUgASgLMg4ubG5ycGMuRmFpbHVyZRIQCghwcmVpbWFnZRgGIAEoDCI2CgpIVExDU3RhdHVzEg0KCUlOX0ZMSUdIVBAAEg0KCVNVQ0NFRURFRBABEgoKBkZBSUxFRBACIsUBChNMaXN0UGF5bWVudHNSZXF1ZXN0EhoKEmluY2x1ZGVfaW5jb21wbGV0ZRgBIAEoCBIUCgxpbmRleF9vZmZzZXQYAiABKAQSFAoMbWF4X3BheW1lbnRzGAMgASgEEhAKCHJldmVyc2VkGAQgASgIEhwKFGNvdW50X3RvdGFsX3BheW1lbnRzGAUgASgIEhsKE2NyZWF0aW9uX2RhdGVfc3RhcnQYBiABKAQSGQoRY3JlYXRpb25fZGF0ZV9lbmQYByABKAQiiwEKFExpc3RQYXltZW50c1Jlc3BvbnNlEiAKCHBheW1lbnRzGAEgAygLMg4ubG5ycGMuUGF5bWVudBIaChJmaXJzdF9pbmRleF9vZmZzZXQYAiABKAQSGQoRbGFzdF9pbmRleF9vZmZzZXQYAyABKAQSGgoSdG90YWxfbnVtX3BheW1lbnRzGAQgASgEIkcKFERlbGV0ZVBheW1lbnRSZXF1ZXN0EhQKDHBheW1lbnRfaGFzaBgBIAEoDBIZChFmYWlsZWRfaHRsY3Nfb25seRgCIAEoCCJTChhEZWxldGVBbGxQYXltZW50c1JlcXVlc3QSHAoUZmFpbGVkX3BheW1lbnRzX29ubHkYASABKAgSGQoRZmFpbGVkX2h0bGNzX29ubHkYAiABKAgiFwoVRGVsZXRlUGF5bWVudFJlc3BvbnNlIhsKGURlbGV0ZUFsbFBheW1lbnRzUmVzcG9uc2UihgEKFUFiYW5kb25DaGFubmVsUmVxdWVzdBIqCg1jaGFubmVsX3BvaW50GAEgASgLMhMubG5ycGMuQ2hhbm5lbFBvaW50EiEKGXBlbmRpbmdfZnVuZGluZ19zaGltX29ubHkYAiABKAgSHgoWaV9rbm93X3doYXRfaV9hbV9kb2luZxgDIAEoCCIYChZBYmFuZG9uQ2hhbm5lbFJlc3BvbnNlIjUKEURlYnVnTGV2ZWxSZXF1ZXN0EgwKBHNob3cYASABKAgSEgoKbGV2ZWxfc3BlYxgCIAEoCSIpChJEZWJ1Z0xldmVsUmVzcG9uc2USEwoLc3ViX3N5c3RlbXMYASABKAkiHwoMUGF5UmVxU3RyaW5nEg8KB3BheV9yZXEYASABKAkihgMKBlBheVJlcRITCgtkZXN0aW5hdGlvbhgBIAEoCRIUCgxwYXltZW50X2hhc2gYAiABKAkSFAoMbnVtX3NhdG9zaGlzGAMgASgDEhEKCXRpbWVzdGFtcBgEIAEoAxIOCgZleHBpcnkYBSABKAMSEwoLZGVzY3JpcHRpb24YBiABKAkSGAoQZGVzY3JpcHRpb25faGFzaBgHIAEoCRIVCg1mYWxsYmFja19hZGRyGAggASgJEhMKC2NsdHZfZXhwaXJ5GAkgASgDEiUKC3JvdXRlX2hpbnRzGAogAygLMhAubG5ycGMuUm91dGVIaW50EhQKDHBheW1lbnRfYWRkchgLIAEoDBIQCghudW1fbXNhdBgMIAEoAxItCghmZWF0dXJlcxgNIAMoCzIbLmxucnBjLlBheVJlcS5GZWF0dXJlc0VudHJ5Gj8KDUZlYXR1cmVzRW50cnkSCwoDa2V5GAEgASgNEh0KBXZhbHVlGAIgASgLMg4ubG5ycGMuRmVhdHVyZToCOAEiPgoHRmVhdHVyZRIMCgRuYW1lGAIgASgJEhMKC2lzX3JlcXVpcmVkGAMgASgIEhAKCGlzX2tub3duGAQgASgIIhIKEEZlZVJlcG9ydFJlcXVlc3QifAoQQ2hhbm5lbEZlZVJlcG9ydBITCgdjaGFuX2lkGAUgASgEQgIwARIVCg1jaGFubmVsX3BvaW50GAEgASgJEhUKDWJhc2VfZmVlX21zYXQYAiABKAMSEwoLZmVlX3Blcl9taWwYAyABKAMSEAoIZmVlX3JhdGUYBCABKAEihAEKEUZlZVJlcG9ydFJlc3BvbnNlEi0KDGNoYW5uZWxfZmVlcxgBIAMoCzIXLmxucnBjLkNoYW5uZWxGZWVSZXBvcnQSEwoLZGF5X2ZlZV9zdW0YAiABKAQSFAoMd2Vla19mZWVfc3VtGAMgASgEEhUKDW1vbnRoX2ZlZV9zdW0YBCABKAQiggIKE1BvbGljeVVwZGF0ZVJlcXVlc3QSEAoGZ2xvYmFsGAEgASgISAASKQoKY2hhbl9wb2ludBgCIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludEgAEhUKDWJhc2VfZmVlX21zYXQYAyABKAMSEAoIZmVlX3JhdGUYBCABKAESFAoMZmVlX3JhdGVfcHBtGAkgASgNEhcKD3RpbWVfbG9ja19kZWx0YRgFIAEoDRIVCg1tYXhfaHRsY19tc2F0GAYgASgEEhUKDW1pbl9odGxjX21zYXQYByABKAQSHwoXbWluX2h0bGNfbXNhdF9zcGVjaWZpZWQYCCABKAhCBwoFc2NvcGUibQoMRmFpbGVkVXBkYXRlEiEKCG91dHBvaW50GAEgASgLMg8ubG5ycGMuT3V0UG9pbnQSJAoGcmVhc29uGAIgASgOMhQubG5ycGMuVXBkYXRlRmFpbHVyZRIUCgx1cGRhdGVfZXJyb3IYAyABKAkiQwoUUG9saWN5VXBkYXRlUmVzcG9uc2USKwoOZmFpbGVkX3VwZGF0ZXMYASADKAsyEy5sbnJwYy5GYWlsZWRVcGRhdGUiiQEKGEZvcndhcmRpbmdIaXN0b3J5UmVxdWVzdBISCgpzdGFydF90aW1lGAEgASgEEhAKCGVuZF90aW1lGAIgASgEEhQKDGluZGV4X29mZnNldBgDIAEoDRIWCg5udW1fbWF4X2V2ZW50cxgEIAEoDRIZChFwZWVyX2FsaWFzX2xvb2t1cBgFIAEoCCKJAgoPRm9yd2FyZGluZ0V2ZW50EhUKCXRpbWVzdGFtcBgBIAEoBEICGAESFgoKY2hhbl9pZF9pbhgCIAEoBEICMAESFwoLY2hhbl9pZF9vdXQYBCABKARCAjABEg4KBmFtdF9pbhgFIAEoBBIPCgdhbXRfb3V0GAYgASgEEgsKA2ZlZRgHIAEoBBIQCghmZWVfbXNhdBgIIAEoBBITCgthbXRfaW5fbXNhdBgJIAEoBBIUCgxhbXRfb3V0X21zYXQYCiABKAQSFAoMdGltZXN0YW1wX25zGAsgASgEEhUKDXBlZXJfYWxpYXNfaW4YDCABKAkSFgoOcGVlcl9hbGlhc19vdXQYDSABKAkiaQoZRm9yd2FyZGluZ0hpc3RvcnlSZXNwb25zZRIxChFmb3J3YXJkaW5nX2V2ZW50cxgBIAMoCzIWLmxucnBjLkZvcndhcmRpbmdFdmVudBIZChFsYXN0X29mZnNldF9pbmRleBgCIAEoDSJFChpFeHBvcnRDaGFubmVsQmFja3VwUmVxdWVzdBInCgpjaGFuX3BvaW50GAEgASgLMhMubG5ycGMuQ2hhbm5lbFBvaW50Ik0KDUNoYW5uZWxCYWNrdXASJwoKY2hhbl9wb2ludBgBIAEoCzITLmxucnBjLkNoYW5uZWxQb2ludBITCgtjaGFuX2JhY2t1cBgCIAEoDCJWCg9NdWx0aUNoYW5CYWNrdXASKAoLY2hhbl9wb2ludHMYASADKAsyEy5sbnJwYy5DaGFubmVsUG9pbnQSGQoRbXVsdGlfY2hhbl9iYWNrdXAYAiABKAwiGQoXQ2hhbkJhY2t1cEV4cG9ydFJlcXVlc3QiewoSQ2hhbkJhY2t1cFNuYXBzaG90EjIKE3NpbmdsZV9jaGFuX2JhY2t1cHMYASABKAsyFS5sbnJwYy5DaGFubmVsQmFja3VwcxIxChFtdWx0aV9jaGFuX2JhY2t1cBgCIAEoCzIWLmxucnBjLk11bHRpQ2hhbkJhY2t1cCI8Cg5DaGFubmVsQmFja3VwcxIqCgxjaGFuX2JhY2t1cHMYASADKAsyFC5sbnJwYy5DaGFubmVsQmFja3VwInAKGFJlc3RvcmVDaGFuQmFja3VwUmVxdWVzdBItCgxjaGFuX2JhY2t1cHMYASABKAsyFS5sbnJwYy5DaGFubmVsQmFja3Vwc0gAEhsKEW11bHRpX2NoYW5fYmFja3VwGAIgASgMSABCCAoGYmFja3VwIhcKFVJlc3RvcmVCYWNrdXBSZXNwb25zZSIbChlDaGFubmVsQmFja3VwU3Vic2NyaXB0aW9uIhoKGFZlcmlmeUNoYW5CYWNrdXBSZXNwb25zZSI0ChJNYWNhcm9vblBlcm1pc3Npb24SDgoGZW50aXR5GAEgASgJEg4KBmFjdGlvbhgCIAEoCSJ+ChNCYWtlTWFjYXJvb25SZXF1ZXN0Ei4KC3Blcm1pc3Npb25zGAEgAygLMhkubG5ycGMuTWFjYXJvb25QZXJtaXNzaW9uEhMKC3Jvb3Rfa2V5X2lkGAIgASgEEiIKGmFsbG93X2V4dGVybmFsX3Blcm1pc3Npb25zGAMgASgIIigKFEJha2VNYWNhcm9vblJlc3BvbnNlEhAKCG1hY2Fyb29uGAEgASgJIhgKFkxpc3RNYWNhcm9vbklEc1JlcXVlc3QiLwoXTGlzdE1hY2Fyb29uSURzUmVzcG9uc2USFAoMcm9vdF9rZXlfaWRzGAEgAygEIi4KF0RlbGV0ZU1hY2Fyb29uSURSZXF1ZXN0EhMKC3Jvb3Rfa2V5X2lkGAEgASgEIisKGERlbGV0ZU1hY2Fyb29uSURSZXNwb25zZRIPCgdkZWxldGVkGAEgASgIIkgKFk1hY2Fyb29uUGVybWlzc2lvbkxpc3QSLgoLcGVybWlzc2lvbnMYASADKAsyGS5sbnJwYy5NYWNhcm9vblBlcm1pc3Npb24iGAoWTGlzdFBlcm1pc3Npb25zUmVxdWVzdCLFAQoXTGlzdFBlcm1pc3Npb25zUmVzcG9uc2USUQoSbWV0aG9kX3Blcm1pc3Npb25zGAEgAygLMjUubG5ycGMuTGlzdFBlcm1pc3Npb25zUmVzcG9uc2UuTWV0aG9kUGVybWlzc2lvbnNFbnRyeRpXChZNZXRob2RQZXJtaXNzaW9uc0VudHJ5EgsKA2tleRgBIAEoCRIsCgV2YWx1ZRgCIAEoCzIdLmxucnBjLk1hY2Fyb29uUGVybWlzc2lvbkxpc3Q6AjgBItUHCgdGYWlsdXJlEigKBGNvZGUYASABKA4yGi5sbnJwYy5GYWlsdXJlLkZhaWx1cmVDb2RlEiwKDmNoYW5uZWxfdXBkYXRlGAMgASgLMhQubG5ycGMuQ2hhbm5lbFVwZGF0ZRIRCglodGxjX21zYXQYBCABKAQSFQoNb25pb25fc2hhXzI1NhgFIAEoDBITCgtjbHR2X2V4cGlyeRgGIAEoDRINCgVmbGFncxgHIAEoDRIcChRmYWlsdXJlX3NvdXJjZV9pbmRleBgIIAEoDRIOCgZoZWlnaHQYCSABKA0i7wUKC0ZhaWx1cmVDb2RlEgwKCFJFU0VSVkVEEAASKAokSU5DT1JSRUNUX09SX1VOS05PV05fUEFZTUVOVF9ERVRBSUxTEAESHAoYSU5DT1JSRUNUX1BBWU1FTlRfQU1PVU5UEAISHwobRklOQUxfSU5DT1JSRUNUX0NMVFZfRVhQSVJZEAMSHwobRklOQUxfSU5DT1JSRUNUX0hUTENfQU1PVU5UEAQSGQoVRklOQUxfRVhQSVJZX1RPT19TT09OEAUSEQoNSU5WQUxJRF9SRUFMTRAGEhMKD0VYUElSWV9UT09fU09PThAHEhkKFUlOVkFMSURfT05JT05fVkVSU0lPThAIEhYKEklOVkFMSURfT05JT05fSE1BQxAJEhUKEUlOVkFMSURfT05JT05fS0VZEAoSGAoUQU1PVU5UX0JFTE9XX01JTklNVU0QCxIUChBGRUVfSU5TVUZGSUNJRU5UEAwSGQoVSU5DT1JSRUNUX0NMVFZfRVhQSVJZEA0SFAoQQ0hBTk5FTF9ESVNBQkxFRBAOEh0KGVRFTVBPUkFSWV9DSEFOTkVMX0ZBSUxVUkUQDxIhCh1SRVFVSVJFRF9OT0RFX0ZFQVRVUkVfTUlTU0lORxAQEiQKIFJFUVVJUkVEX0NIQU5ORUxfRkVBVFVSRV9NSVNTSU5HEBESFQoRVU5LTk9XTl9ORVhUX1BFRVIQEhIaChZURU1QT1JBUllfTk9ERV9GQUlMVVJFEBMSGgoWUEVSTUFORU5UX05PREVfRkFJTFVSRRAUEh0KGVBFUk1BTkVOVF9DSEFOTkVMX0ZBSUxVUkUQFRISCg5FWFBJUllfVE9PX0ZBUhAWEg8KC01QUF9USU1FT1VUEBcSGQoVSU5WQUxJRF9PTklPTl9QQVlMT0FEEBgSFQoQSU5URVJOQUxfRkFJTFVSRRDlBxIUCg9VTktOT1dOX0ZBSUxVUkUQ5gcSFwoSVU5SRUFEQUJMRV9GQUlMVVJFEOcHSgQIAhADIpoCCg1DaGFubmVsVXBkYXRlEhEKCXNpZ25hdHVyZRgBIAEoDBISCgpjaGFpbl9oYXNoGAIgASgMEhMKB2NoYW5faWQYAyABKARCAjABEhEKCXRpbWVzdGFtcBgEIAEoDRIVCg1tZXNzYWdlX2ZsYWdzGAogASgNEhUKDWNoYW5uZWxfZmxhZ3MYBSABKA0SFwoPdGltZV9sb2NrX2RlbHRhGAYgASgNEhkKEWh0bGNfbWluaW11bV9tc2F0GAcgASgEEhAKCGJhc2VfZmVlGAggASgNEhAKCGZlZV9yYXRlGAkgASgNEhkKEWh0bGNfbWF4aW11bV9tc2F0GAsgASgEEhkKEWV4dHJhX29wYXF1ZV9kYXRhGAwgASgMIkYKCk1hY2Fyb29uSWQSDQoFbm9uY2UYASABKAwSEQoJc3RvcmFnZUlkGAIgASgMEhYKA29wcxgDIAMoCzIJLmxucnBjLk9wIiUKAk9wEg4KBmVudGl0eRgBIAEoCRIPCgdhY3Rpb25zGAIgAygJImsKE0NoZWNrTWFjUGVybVJlcXVlc3QSEAoIbWFjYXJvb24YASABKAwSLgoLcGVybWlzc2lvbnMYAiADKAsyGS5sbnJwYy5NYWNhcm9vblBlcm1pc3Npb24SEgoKZnVsbE1ldGhvZBgDIAEoCSIlChRDaGVja01hY1Blcm1SZXNwb25zZRINCgV2YWxpZBgBIAEoCCKSAgoUUlBDTWlkZGxld2FyZVJlcXVlc3QSEgoKcmVxdWVzdF9pZBgBIAEoBBIUCgxyYXdfbWFjYXJvb24YAiABKAwSHwoXY3VzdG9tX2NhdmVhdF9jb25kaXRpb24YAyABKAkSKAoLc3RyZWFtX2F1dGgYBCABKAsyES5sbnJwYy5TdHJlYW1BdXRoSAASJAoHcmVxdWVzdBgFIAEoCzIRLmxucnBjLlJQQ01lc3NhZ2VIABIlCghyZXNwb25zZRgGIAEoCzIRLmxucnBjLlJQQ01lc3NhZ2VIABIWCgxyZWdfY29tcGxldGUYCCABKAhIABIOCgZtc2dfaWQYByABKARCEAoOaW50ZXJjZXB0X3R5cGUiJQoKU3RyZWFtQXV0aBIXCg9tZXRob2RfZnVsbF91cmkYASABKAkicgoKUlBDTWVzc2FnZRIXCg9tZXRob2RfZnVsbF91cmkYASABKAkSEgoKc3RyZWFtX3JwYxgCIAEoCBIRCgl0eXBlX25hbWUYAyABKAkSEgoKc2VyaWFsaXplZBgEIAEoDBIQCghpc19lcnJvchgFIAEoCCKiAQoVUlBDTWlkZGxld2FyZVJlc3BvbnNlEhIKCnJlZl9tc2dfaWQYASABKAQSMQoIcmVnaXN0ZXIYAiABKAsyHS5sbnJwYy5NaWRkbGV3YXJlUmVnaXN0cmF0aW9uSAASLAoIZmVlZGJhY2sYAyABKAsyGC5sbnJwYy5JbnRlcmNlcHRGZWVkYmFja0gAQhQKEm1pZGRsZXdhcmVfbWVzc2FnZSJuChZNaWRkbGV3YXJlUmVnaXN0cmF0aW9uEhcKD21pZGRsZXdhcmVfbmFtZRgBIAEoCRIjChtjdXN0b21fbWFjYXJvb25fY2F2ZWF0X25hbWUYAiABKAkSFgoOcmVhZF9vbmx5X21vZGUYAyABKAgiXAoRSW50ZXJjZXB0RmVlZGJhY2sSDQoFZXJyb3IYASABKAkSGAoQcmVwbGFjZV9yZXNwb25zZRgCIAEoCBIeChZyZXBsYWNlbWVudF9zZXJpYWxpemVkGAMgASgMKssCChBPdXRwdXRTY3JpcHRUeXBlEhsKF1NDUklQVF9UWVBFX1BVQktFWV9IQVNIEAASGwoXU0NSSVBUX1RZUEVfU0NSSVBUX0hBU0gQARImCiJTQ1JJUFRfVFlQRV9XSVRORVNTX1YwX1BVQktFWV9IQVNIEAISJgoiU0NSSVBUX1RZUEVfV0lUTkVTU19WMF9TQ1JJUFRfSEFTSBADEhYKElNDUklQVF9UWVBFX1BVQktFWRAEEhgKFFNDUklQVF9UWVBFX01VTFRJU0lHEAUSGAoUU0NSSVBUX1RZUEVfTlVMTERBVEEQBhIcChhTQ1JJUFRfVFlQRV9OT05fU1RBTkRBUkQQBxIfChtTQ1JJUFRfVFlQRV9XSVRORVNTX1VOS05PV04QCBIiCh5TQ1JJUFRfVFlQRV9XSVRORVNTX1YxX1RBUFJPT1QQCSqsAQoLQWRkcmVzc1R5cGUSFwoTV0lUTkVTU19QVUJLRVlfSEFTSBAAEhYKEk5FU1RFRF9QVUJLRVlfSEFTSBABEh4KGlVOVVNFRF9XSVRORVNTX1BVQktFWV9IQVNIEAISHQoZVU5VU0VEX05FU1RFRF9QVUJLRVlfSEFTSBADEhIKDlRBUFJPT1RfUFVCS0VZEAQSGQoVVU5VU0VEX1RBUFJPT1RfUFVCS0VZEAUqjAEKDkNvbW1pdG1lbnRUeXBlEhsKF1VOS05PV05fQ09NTUlUTUVOVF9UWVBFEAASCgoGTEVHQUNZEAESFQoRU1RBVElDX1JFTU9URV9LRVkQAhILCgdBTkNIT1JTEAMSGQoVU0NSSVBUX0VORk9SQ0VEX0xFQVNFEAQSEgoOU0lNUExFX1RBUFJPT1QQBSphCglJbml0aWF0b3ISFQoRSU5JVElBVE9SX1VOS05PV04QABITCg9JTklUSUFUT1JfTE9DQUwQARIUChBJTklUSUFUT1JfUkVNT1RFEAISEgoOSU5JVElBVE9SX0JPVEgQAypgCg5SZXNvbHV0aW9uVHlwZRIQCgxUWVBFX1VOS05PV04QABIKCgZBTkNIT1IQARIRCg1JTkNPTUlOR19IVExDEAISEQoNT1VUR09JTkdfSFRMQxADEgoKBkNPTU1JVBAEKnEKEVJlc29sdXRpb25PdXRjb21lEhMKD09VVENPTUVfVU5LTk9XThAAEgsKB0NMQUlNRUQQARINCglVTkNMQUlNRUQQAhINCglBQkFORE9ORUQQAxIPCgtGSVJTVF9TVEFHRRAEEgsKB1RJTUVPVVQQBSo5Cg5Ob2RlTWV0cmljVHlwZRILCgdVTktOT1dOEAASGgoWQkVUV0VFTk5FU1NfQ0VOVFJBTElUWRABKjsKEEludm9pY2VIVExDU3RhdGUSDAoIQUNDRVBURUQQABILCgdTRVRUTEVEEAESDAoIQ0FOQ0VMRUQQAirZAQoUUGF5bWVudEZhaWx1cmVSZWFzb24SFwoTRkFJTFVSRV9SRUFTT05fTk9ORRAAEhoKFkZBSUxVUkVfUkVBU09OX1RJTUVPVVQQARIbChdGQUlMVVJFX1JFQVNPTl9OT19ST1VURRACEhgKFEZBSUxVUkVfUkVBU09OX0VSUk9SEAMSLAooRkFJTFVSRV9SRUFTT05fSU5DT1JSRUNUX1BBWU1FTlRfREVUQUlMUxAEEicKI0ZBSUxVUkVfUkVBU09OX0lOU1VGRklDSUVOVF9CQUxBTkNFEAUqzwQKCkZlYXR1cmVCaXQSGAoUREFUQUxPU1NfUFJPVEVDVF9SRVEQABIYChREQVRBTE9TU19QUk9URUNUX09QVBABEhcKE0lOSVRJQUxfUk9VSU5HX1NZTkMQAxIfChtVUEZST05UX1NIVVRET1dOX1NDUklQVF9SRVEQBBIfChtVUEZST05UX1NIVVRET1dOX1NDUklQVF9PUFQQBRIWChJHT1NTSVBfUVVFUklFU19SRVEQBhIWChJHT1NTSVBfUVVFUklFU19PUFQQBxIRCg1UTFZfT05JT05fUkVREAgSEQoNVExWX09OSU9OX09QVBAJEhoKFkVYVF9HT1NTSVBfUVVFUklFU19SRVEQChIaChZFWFRfR09TU0lQX1FVRVJJRVNfT1BUEAsSGQoVU1RBVElDX1JFTU9URV9LRVlfUkVREAwSGQoVU1RBVElDX1JFTU9URV9LRVlfT1BUEA0SFAoQUEFZTUVOVF9BRERSX1JFURAOEhQKEFBBWU1FTlRfQUREUl9PUFQQDxILCgdNUFBfUkVREBASCwoHTVBQX09QVBAREhYKEldVTUJPX0NIQU5ORUxTX1JFURASEhYKEldVTUJPX0NIQU5ORUxTX09QVBATEg8KC0FOQ0hPUlNfUkVREBQSDwoLQU5DSE9SU19PUFQQFRIdChlBTkNIT1JTX1pFUk9fRkVFX0hUTENfUkVREBYSHQoZQU5DSE9SU19aRVJPX0ZFRV9IVExDX09QVBAXEgsKB0FNUF9SRVEQHhILCgdBTVBfT1BUEB8qrAEKDVVwZGF0ZUZhaWx1cmUSGgoWVVBEQVRFX0ZBSUxVUkVfVU5LTk9XThAAEhoKFlVQREFURV9GQUlMVVJFX1BFTkRJTkcQARIcChhVUERBVEVfRkFJTFVSRV9OT1RfRk9VTkQQAhIfChtVUERBVEVfRkFJTFVSRV9JTlRFUk5BTF9FUlIQAxIkCiBVUERBVEVfRkFJTFVSRV9JTlZBTElEX1BBUkFNRVRFUhAEMvAmCglMaWdodG5pbmcSSgoNV2FsbGV0QmFsYW5jZRIbLmxucnBjLldhbGxldEJhbGFuY2VSZXF1ZXN0GhwubG5ycGMuV2FsbGV0QmFsYW5jZVJlc3BvbnNlEk0KDkNoYW5uZWxCYWxhbmNlEhwubG5ycGMuQ2hhbm5lbEJhbGFuY2VSZXF1ZXN0Gh0ubG5ycGMuQ2hhbm5lbEJhbGFuY2VSZXNwb25zZRJLCg9HZXRUcmFuc2FjdGlvbnMSHS5sbnJwYy5HZXRUcmFuc2FjdGlvbnNSZXF1ZXN0GhkubG5ycGMuVHJhbnNhY3Rpb25EZXRhaWxzEkQKC0VzdGltYXRlRmVlEhkubG5ycGMuRXN0aW1hdGVGZWVSZXF1ZXN0GhoubG5ycGMuRXN0aW1hdGVGZWVSZXNwb25zZRI+CglTZW5kQ29pbnMSFy5sbnJwYy5TZW5kQ29pbnNSZXF1ZXN0GhgubG5ycGMuU2VuZENvaW5zUmVzcG9uc2USRAoLTGlzdFVuc3BlbnQSGS5sbnJwYy5MaXN0VW5zcGVudFJlcXVlc3QaGi5sbnJwYy5MaXN0VW5zcGVudFJlc3BvbnNlEkwKFVN1YnNjcmliZVRyYW5zYWN0aW9ucxIdLmxucnBjLkdldFRyYW5zYWN0aW9uc1JlcXVlc3QaEi5sbnJwYy5UcmFuc2FjdGlvbjABEjsKCFNlbmRNYW55EhYubG5ycGMuU2VuZE1hbnlSZXF1ZXN0GhcubG5ycGMuU2VuZE1hbnlSZXNwb25zZRJBCgpOZXdBZGRyZXNzEhgubG5ycGMuTmV3QWRkcmVzc1JlcXVlc3QaGS5sbnJwYy5OZXdBZGRyZXNzUmVzcG9uc2USRAoLU2lnbk1lc3NhZ2USGS5sbnJwYy5TaWduTWVzc2FnZVJlcXVlc3QaGi5sbnJwYy5TaWduTWVzc2FnZVJlc3BvbnNlEkoKDVZlcmlmeU1lc3NhZ2USGy5sbnJwYy5WZXJpZnlNZXNzYWdlUmVxdWVzdBocLmxucnBjLlZlcmlmeU1lc3NhZ2VSZXNwb25zZRJECgtDb25uZWN0UGVlchIZLmxucnBjLkNvbm5lY3RQZWVyUmVxdWVzdBoaLmxucnBjLkNvbm5lY3RQZWVyUmVzcG9uc2USTQoORGlzY29ubmVjdFBlZXISHC5sbnJwYy5EaXNjb25uZWN0UGVlclJlcXVlc3QaHS5sbnJwYy5EaXNjb25uZWN0UGVlclJlc3BvbnNlEj4KCUxpc3RQZWVycxIXLmxucnBjLkxpc3RQZWVyc1JlcXVlc3QaGC5sbnJwYy5MaXN0UGVlcnNSZXNwb25zZRJHChNTdWJzY3JpYmVQZWVyRXZlbnRzEhwubG5ycGMuUGVlckV2ZW50U3Vic2NyaXB0aW9uGhAubG5ycGMuUGVlckV2ZW50MAESOAoHR2V0SW5mbxIVLmxucnBjLkdldEluZm9SZXF1ZXN0GhYubG5ycGMuR2V0SW5mb1Jlc3BvbnNlElAKD0dldFJlY292ZXJ5SW5mbxIdLmxucnBjLkdldFJlY292ZXJ5SW5mb1JlcXVlc3QaHi5sbnJwYy5HZXRSZWNvdmVyeUluZm9SZXNwb25zZRJQCg9QZW5kaW5nQ2hhbm5lbHMSHS5sbnJwYy5QZW5kaW5nQ2hhbm5lbHNSZXF1ZXN0Gh4ubG5ycGMuUGVuZGluZ0NoYW5uZWxzUmVzcG9uc2USRwoMTGlzdENoYW5uZWxzEhoubG5ycGMuTGlzdENoYW5uZWxzUmVxdWVzdBobLmxucnBjLkxpc3RDaGFubmVsc1Jlc3BvbnNlElYKFlN1YnNjcmliZUNoYW5uZWxFdmVudHMSHy5sbnJwYy5DaGFubmVsRXZlbnRTdWJzY3JpcHRpb24aGS5sbnJwYy5DaGFubmVsRXZlbnRVcGRhdGUwARJNCg5DbG9zZWRDaGFubmVscxIcLmxucnBjLkNsb3NlZENoYW5uZWxzUmVxdWVzdBodLmxucnBjLkNsb3NlZENoYW5uZWxzUmVzcG9uc2USQQoPT3BlbkNoYW5uZWxTeW5jEhkubG5ycGMuT3BlbkNoYW5uZWxSZXF1ZXN0GhMubG5ycGMuQ2hhbm5lbFBvaW50EkMKC09wZW5DaGFubmVsEhkubG5ycGMuT3BlbkNoYW5uZWxSZXF1ZXN0GhcubG5ycGMuT3BlblN0YXR1c1VwZGF0ZTABElMKEEJhdGNoT3BlbkNoYW5uZWwSHi5sbnJwYy5CYXRjaE9wZW5DaGFubmVsUmVxdWVzdBofLmxucnBjLkJhdGNoT3BlbkNoYW5uZWxSZXNwb25zZRJMChBGdW5kaW5nU3RhdGVTdGVwEhsubG5ycGMuRnVuZGluZ1RyYW5zaXRpb25Nc2caGy5sbnJwYy5GdW5kaW5nU3RhdGVTdGVwUmVzcBJQCg9DaGFubmVsQWNjZXB0b3ISHC5sbnJwYy5DaGFubmVsQWNjZXB0UmVzcG9uc2UaGy5sbnJwYy5DaGFubmVsQWNjZXB0UmVxdWVzdCgBMAESRgoMQ2xvc2VDaGFubmVsEhoubG5ycGMuQ2xvc2VDaGFubmVsUmVxdWVzdBoYLmxucnBjLkNsb3NlU3RhdHVzVXBkYXRlMAESTQoOQWJhbmRvbkNoYW5uZWwSHC5sbnJwYy5BYmFuZG9uQ2hhbm5lbFJlcXVlc3QaHS5sbnJwYy5BYmFuZG9uQ2hhbm5lbFJlc3BvbnNlEj8KC1NlbmRQYXltZW50EhIubG5ycGMuU2VuZFJlcXVlc3QaEy5sbnJwYy5TZW5kUmVzcG9uc2UiA4gCASgBMAESOgoPU2VuZFBheW1lbnRTeW5jEhIubG5ycGMuU2VuZFJlcXVlc3QaEy5sbnJwYy5TZW5kUmVzcG9uc2USRgoLU2VuZFRvUm91dGUSGS5sbnJwYy5TZW5kVG9Sb3V0ZVJlcXVlc3QaEy5sbnJwYy5TZW5kUmVzcG9uc2UiA4gCASgBMAESQQoPU2VuZFRvUm91dGVTeW5jEhkubG5ycGMuU2VuZFRvUm91dGVSZXF1ZXN0GhMubG5ycGMuU2VuZFJlc3BvbnNlEjcKCkFkZEludm9pY2USDi5sbnJwYy5JbnZvaWNlGhkubG5ycGMuQWRkSW52b2ljZVJlc3BvbnNlEkUKDExpc3RJbnZvaWNlcxIZLmxucnBjLkxpc3RJbnZvaWNlUmVxdWVzdBoaLmxucnBjLkxpc3RJbnZvaWNlUmVzcG9uc2USMwoNTG9va3VwSW52b2ljZRISLmxucnBjLlBheW1lbnRIYXNoGg4ubG5ycGMuSW52b2ljZRJBChFTdWJzY3JpYmVJbnZvaWNlcxIaLmxucnBjLkludm9pY2VTdWJzY3JpcHRpb24aDi5sbnJwYy5JbnZvaWNlMAESMgoMRGVjb2RlUGF5UmVxEhMubG5ycGMuUGF5UmVxU3RyaW5nGg0ubG5ycGMuUGF5UmVxEkcKDExpc3RQYXltZW50cxIaLmxucnBjLkxpc3RQYXltZW50c1JlcXVlc3QaGy5sbnJwYy5MaXN0UGF5bWVudHNSZXNwb25zZRJKCg1EZWxldGVQYXltZW50EhsubG5ycGMuRGVsZXRlUGF5bWVudFJlcXVlc3QaHC5sbnJwYy5EZWxldGVQYXltZW50UmVzcG9uc2USVgoRRGVsZXRlQWxsUGF5bWVudHMSHy5sbnJwYy5EZWxldGVBbGxQYXltZW50c1JlcXVlc3QaIC5sbnJwYy5EZWxldGVBbGxQYXltZW50c1Jlc3BvbnNlEkAKDURlc2NyaWJlR3JhcGgSGi5sbnJwYy5DaGFubmVsR3JhcGhSZXF1ZXN0GhMubG5ycGMuQ2hhbm5lbEdyYXBoEkcKDkdldE5vZGVNZXRyaWNzEhkubG5ycGMuTm9kZU1ldHJpY3NSZXF1ZXN0GhoubG5ycGMuTm9kZU1ldHJpY3NSZXNwb25zZRI5CgtHZXRDaGFuSW5mbxIWLmxucnBjLkNoYW5JbmZvUmVxdWVzdBoSLmxucnBjLkNoYW5uZWxFZGdlEjYKC0dldE5vZGVJbmZvEhYubG5ycGMuTm9kZUluZm9SZXF1ZXN0Gg8ubG5ycGMuTm9kZUluZm8SRAoLUXVlcnlSb3V0ZXMSGS5sbnJwYy5RdWVyeVJvdXRlc1JlcXVlc3QaGi5sbnJwYy5RdWVyeVJvdXRlc1Jlc3BvbnNlEj8KDkdldE5ldHdvcmtJbmZvEhkubG5ycGMuTmV0d29ya0luZm9SZXF1ZXN0GhIubG5ycGMuTmV0d29ya0luZm8SNQoKU3RvcERhZW1vbhISLmxucnBjLlN0b3BSZXF1ZXN0GhMubG5ycGMuU3RvcFJlc3BvbnNlElcKFVN1YnNjcmliZUNoYW5uZWxHcmFwaBIgLmxucnBjLkdyYXBoVG9wb2xvZ3lTdWJzY3JpcHRpb24aGi5sbnJwYy5HcmFwaFRvcG9sb2d5VXBkYXRlMAESQQoKRGVidWdMZXZlbBIYLmxucnBjLkRlYnVnTGV2ZWxSZXF1ZXN0GhkubG5ycGMuRGVidWdMZXZlbFJlc3BvbnNlEj4KCUZlZVJlcG9ydBIXLmxucnBjLkZlZVJlcG9ydFJlcXVlc3QaGC5sbnJwYy5GZWVSZXBvcnRSZXNwb25zZRJOChNVcGRhdGVDaGFubmVsUG9saWN5EhoubG5ycGMuUG9saWN5VXBkYXRlUmVxdWVzdBobLmxucnBjLlBvbGljeVVwZGF0ZVJlc3BvbnNlElYKEUZvcndhcmRpbmdIaXN0b3J5Eh8ubG5ycGMuRm9yd2FyZGluZ0hpc3RvcnlSZXF1ZXN0GiAubG5ycGMuRm9yd2FyZGluZ0hpc3RvcnlSZXNwb25zZRJOChNFeHBvcnRDaGFubmVsQmFja3VwEiEubG5ycGMuRXhwb3J0Q2hhbm5lbEJhY2t1cFJlcXVlc3QaFC5sbnJwYy5DaGFubmVsQmFja3VwElQKF0V4cG9ydEFsbENoYW5uZWxCYWNrdXBzEh4ubG5ycGMuQ2hhbkJhY2t1cEV4cG9ydFJlcXVlc3QaGS5sbnJwYy5DaGFuQmFja3VwU25hcHNob3QSTgoQVmVyaWZ5Q2hhbkJhY2t1cBIZLmxucnBjLkNoYW5CYWNrdXBTbmFwc2hvdBofLmxucnBjLlZlcmlmeUNoYW5CYWNrdXBSZXNwb25zZRJWChVSZXN0b3JlQ2hhbm5lbEJhY2t1cHMSHy5sbnJwYy5SZXN0b3JlQ2hhbkJhY2t1cFJlcXVlc3QaHC5sbnJwYy5SZXN0b3JlQmFja3VwUmVzcG9uc2USWAoXU3Vic2NyaWJlQ2hhbm5lbEJhY2t1cHMSIC5sbnJwYy5DaGFubmVsQmFja3VwU3Vic2NyaXB0aW9uGhkubG5ycGMuQ2hhbkJhY2t1cFNuYXBzaG90MAESRwoMQmFrZU1hY2Fyb29uEhoubG5ycGMuQmFrZU1hY2Fyb29uUmVxdWVzdBobLmxucnBjLkJha2VNYWNhcm9vblJlc3BvbnNlElAKD0xpc3RNYWNhcm9vbklEcxIdLmxucnBjLkxpc3RNYWNhcm9vbklEc1JlcXVlc3QaHi5sbnJwYy5MaXN0TWFjYXJvb25JRHNSZXNwb25zZRJTChBEZWxldGVNYWNhcm9vbklEEh4ubG5ycGMuRGVsZXRlTWFjYXJvb25JRFJlcXVlc3QaHy5sbnJwYy5EZWxldGVNYWNhcm9vbklEUmVzcG9uc2USUAoPTGlzdFBlcm1pc3Npb25zEh0ubG5ycGMuTGlzdFBlcm1pc3Npb25zUmVxdWVzdBoeLmxucnBjLkxpc3RQZXJtaXNzaW9uc1Jlc3BvbnNlElMKGENoZWNrTWFjYXJvb25QZXJtaXNzaW9ucxIaLmxucnBjLkNoZWNrTWFjUGVybVJlcXVlc3QaGy5sbnJwYy5DaGVja01hY1Blcm1SZXNwb25zZRJWChVSZWdpc3RlclJQQ01pZGRsZXdhcmUSHC5sbnJwYy5SUENNaWRkbGV3YXJlUmVzcG9uc2UaGy5sbnJwYy5SUENNaWRkbGV3YXJlUmVxdWVzdCgBMAESVgoRU2VuZEN1c3RvbU1lc3NhZ2USHy5sbnJwYy5TZW5kQ3VzdG9tTWVzc2FnZVJlcXVlc3QaIC5sbnJwYy5TZW5kQ3VzdG9tTWVzc2FnZVJlc3BvbnNlElgKF1N1YnNjcmliZUN1c3RvbU1lc3NhZ2VzEiUubG5ycGMuU3Vic2NyaWJlQ3VzdG9tTWVzc2FnZXNSZXF1ZXN0GhQubG5ycGMuQ3VzdG9tTWVzc2FnZTABEkQKC0xpc3RBbGlhc2VzEhkubG5ycGMuTGlzdEFsaWFzZXNSZXF1ZXN0GhoubG5ycGMuTGlzdEFsaWFzZXNSZXNwb25zZRJfChRMb29rdXBIdGxjUmVzb2x1dGlvbhIiLmxucnBjLkxvb2t1cEh0bGNSZXNvbHV0aW9uUmVxdWVzdBojLmxucnBjLkxvb2t1cEh0bGNSZXNvbHV0aW9uUmVzcG9uc2VCJ1olZ2l0aHViLmNvbS9saWdodG5pbmduZXR3b3JrL2xuZC9sbnJwY2IGcHJvdG8z");

/**
 * @generated from message lnrpc.LookupHtlcResolutionRequest
 */
export type LookupHtlcResolutionRequest = Message<"lnrpc.LookupHtlcResolutionRequest"> & {
  /**
   * @generated from field: uint64 chan_id = 1;
   */
  chanId: bigint;

  /**
   * @generated from field: uint64 htlc_index = 2;
   */
  htlcIndex: bigint;
};

/**
 * Describes the message lnrpc.LookupHtlcResolutionRequest.
 * Use `create(LookupHtlcResolutionRequestSchema)` to create a new message.
 */
export const LookupHtlcResolutionRequestSchema: GenMessage<LookupHtlcResolutionRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 0);

/**
 * @generated from message lnrpc.LookupHtlcResolutionResponse
 */
export type LookupHtlcResolutionResponse = Message<"lnrpc.LookupHtlcResolutionResponse"> & {
  /**
   * Settled is true is the htlc was settled. If false, the htlc was failed.
   *
   * @generated from field: bool settled = 1;
   */
  settled: boolean;

  /**
   * Offchain indicates whether the htlc was resolved off-chain or on-chain.
   *
   * @generated from field: bool offchain = 2;
   */
  offchain: boolean;
};

/**
 * Describes the message lnrpc.LookupHtlcResolutionResponse.
 * Use `create(LookupHtlcResolutionResponseSchema)` to create a new message.
 */
export const LookupHtlcResolutionResponseSchema: GenMessage<LookupHtlcResolutionResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 1);

/**
 * @generated from message lnrpc.SubscribeCustomMessagesRequest
 */
export type SubscribeCustomMessagesRequest = Message<"lnrpc.SubscribeCustomMessagesRequest"> & {
};

/**
 * Describes the message lnrpc.SubscribeCustomMessagesRequest.
 * Use `create(SubscribeCustomMessagesRequestSchema)` to create a new message.
 */
export const SubscribeCustomMessagesRequestSchema: GenMessage<SubscribeCustomMessagesRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 2);

/**
 * @generated from message lnrpc.CustomMessage
 */
export type CustomMessage = Message<"lnrpc.CustomMessage"> & {
  /**
   * Peer from which the message originates
   *
   * @generated from field: bytes peer = 1;
   */
  peer: Uint8Array;

  /**
   * Message type. This value will be in the custom range (>= 32768).
   *
   * @generated from field: uint32 type = 2;
   */
  type: number;

  /**
   * Raw message data
   *
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;
};

/**
 * Describes the message lnrpc.CustomMessage.
 * Use `create(CustomMessageSchema)` to create a new message.
 */
export const CustomMessageSchema: GenMessage<CustomMessage> = /*@__PURE__*/
  messageDesc(file_lightning, 3);

/**
 * @generated from message lnrpc.SendCustomMessageRequest
 */
export type SendCustomMessageRequest = Message<"lnrpc.SendCustomMessageRequest"> & {
  /**
   * Peer to send the message to
   *
   * @generated from field: bytes peer = 1;
   */
  peer: Uint8Array;

  /**
   * Message type. This value needs to be in the custom range (>= 32768).
   * To send a type < custom range, lnd needs to be compiled with the `dev`
   * build tag, and the message type to override should be specified in lnd's
   * experimental protocol configuration.
   *
   * @generated from field: uint32 type = 2;
   */
  type: number;

  /**
   * Raw message data.
   *
   * @generated from field: bytes data = 3;
   */
  data: Uint8Array;
};

/**
 * Describes the message lnrpc.SendCustomMessageRequest.
 * Use `create(SendCustomMessageRequestSchema)` to create a new message.
 */
export const SendCustomMessageRequestSchema: GenMessage<SendCustomMessageRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 4);

/**
 * @generated from message lnrpc.SendCustomMessageResponse
 */
export type SendCustomMessageResponse = Message<"lnrpc.SendCustomMessageResponse"> & {
};

/**
 * Describes the message lnrpc.SendCustomMessageResponse.
 * Use `create(SendCustomMessageResponseSchema)` to create a new message.
 */
export const SendCustomMessageResponseSchema: GenMessage<SendCustomMessageResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 5);

/**
 * @generated from message lnrpc.Utxo
 */
export type Utxo = Message<"lnrpc.Utxo"> & {
  /**
   * The type of address
   *
   * @generated from field: lnrpc.AddressType address_type = 1;
   */
  addressType: AddressType;

  /**
   * The address
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * The value of the unspent coin in satoshis
   *
   * @generated from field: int64 amount_sat = 3;
   */
  amountSat: bigint;

  /**
   * The pkscript in hex
   *
   * @generated from field: string pk_script = 4;
   */
  pkScript: string;

  /**
   * The outpoint in format txid:n
   *
   * @generated from field: lnrpc.OutPoint outpoint = 5;
   */
  outpoint?: OutPoint;

  /**
   * The number of confirmations for the Utxo
   *
   * @generated from field: int64 confirmations = 6;
   */
  confirmations: bigint;
};

/**
 * Describes the message lnrpc.Utxo.
 * Use `create(UtxoSchema)` to create a new message.
 */
export const UtxoSchema: GenMessage<Utxo> = /*@__PURE__*/
  messageDesc(file_lightning, 6);

/**
 * @generated from message lnrpc.OutputDetail
 */
export type OutputDetail = Message<"lnrpc.OutputDetail"> & {
  /**
   * The type of the output
   *
   * @generated from field: lnrpc.OutputScriptType output_type = 1;
   */
  outputType: OutputScriptType;

  /**
   * The address
   *
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * The pkscript in hex
   *
   * @generated from field: string pk_script = 3;
   */
  pkScript: string;

  /**
   * The output index used in the raw transaction
   *
   * @generated from field: int64 output_index = 4;
   */
  outputIndex: bigint;

  /**
   * The value of the output coin in satoshis
   *
   * @generated from field: int64 amount = 5;
   */
  amount: bigint;

  /**
   * Denotes if the output is controlled by the internal wallet
   *
   * @generated from field: bool is_our_address = 6;
   */
  isOurAddress: boolean;
};

/**
 * Describes the message lnrpc.OutputDetail.
 * Use `create(OutputDetailSchema)` to create a new message.
 */
export const OutputDetailSchema: GenMessage<OutputDetail> = /*@__PURE__*/
  messageDesc(file_lightning, 7);

/**
 * @generated from message lnrpc.Transaction
 */
export type Transaction = Message<"lnrpc.Transaction"> & {
  /**
   * The transaction hash
   *
   * @generated from field: string tx_hash = 1;
   */
  txHash: string;

  /**
   * The transaction amount, denominated in satoshis
   *
   * @generated from field: int64 amount = 2;
   */
  amount: bigint;

  /**
   * The number of confirmations
   *
   * @generated from field: int32 num_confirmations = 3;
   */
  numConfirmations: number;

  /**
   * The hash of the block this transaction was included in
   *
   * @generated from field: string block_hash = 4;
   */
  blockHash: string;

  /**
   * The height of the block this transaction was included in
   *
   * @generated from field: int32 block_height = 5;
   */
  blockHeight: number;

  /**
   * Timestamp of this transaction
   *
   * @generated from field: int64 time_stamp = 6;
   */
  timeStamp: bigint;

  /**
   * Fees paid for this transaction
   *
   * @generated from field: int64 total_fees = 7;
   */
  totalFees: bigint;

  /**
   * Addresses that received funds for this transaction. Deprecated as it is
   * now incorporated in the output_details field.
   *
   * @generated from field: repeated string dest_addresses = 8 [deprecated = true];
   * @deprecated
   */
  destAddresses: string[];

  /**
   * Outputs that received funds for this transaction
   *
   * @generated from field: repeated lnrpc.OutputDetail output_details = 11;
   */
  outputDetails: OutputDetail[];

  /**
   * The raw transaction hex.
   *
   * @generated from field: string raw_tx_hex = 9;
   */
  rawTxHex: string;

  /**
   * A label that was optionally set on transaction broadcast.
   *
   * @generated from field: string label = 10;
   */
  label: string;

  /**
   * PreviousOutpoints/Inputs of this transaction.
   *
   * @generated from field: repeated lnrpc.PreviousOutPoint previous_outpoints = 12;
   */
  previousOutpoints: PreviousOutPoint[];
};

/**
 * Describes the message lnrpc.Transaction.
 * Use `create(TransactionSchema)` to create a new message.
 */
export const TransactionSchema: GenMessage<Transaction> = /*@__PURE__*/
  messageDesc(file_lightning, 8);

/**
 * @generated from message lnrpc.GetTransactionsRequest
 */
export type GetTransactionsRequest = Message<"lnrpc.GetTransactionsRequest"> & {
  /**
   * 
   * The height from which to list transactions, inclusive. If this value is
   * greater than end_height, transactions will be read in reverse.
   *
   * @generated from field: int32 start_height = 1;
   */
  startHeight: number;

  /**
   * 
   * The height until which to list transactions, inclusive. To include
   * unconfirmed transactions, this value should be set to -1, which will
   * return transactions from start_height until the current chain tip and
   * unconfirmed transactions. If no end_height is provided, the call will
   * default to this option.
   *
   * @generated from field: int32 end_height = 2;
   */
  endHeight: number;

  /**
   * An optional filter to only include transactions relevant to an account.
   *
   * @generated from field: string account = 3;
   */
  account: string;
};

/**
 * Describes the message lnrpc.GetTransactionsRequest.
 * Use `create(GetTransactionsRequestSchema)` to create a new message.
 */
export const GetTransactionsRequestSchema: GenMessage<GetTransactionsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 9);

/**
 * @generated from message lnrpc.TransactionDetails
 */
export type TransactionDetails = Message<"lnrpc.TransactionDetails"> & {
  /**
   * The list of transactions relevant to the wallet.
   *
   * @generated from field: repeated lnrpc.Transaction transactions = 1;
   */
  transactions: Transaction[];
};

/**
 * Describes the message lnrpc.TransactionDetails.
 * Use `create(TransactionDetailsSchema)` to create a new message.
 */
export const TransactionDetailsSchema: GenMessage<TransactionDetails> = /*@__PURE__*/
  messageDesc(file_lightning, 10);

/**
 * @generated from message lnrpc.FeeLimit
 */
export type FeeLimit = Message<"lnrpc.FeeLimit"> & {
  /**
   * @generated from oneof lnrpc.FeeLimit.limit
   */
  limit: {
    /**
     * 
     * The fee limit expressed as a fixed amount of satoshis.
     * 
     * The fields fixed and fixed_msat are mutually exclusive.
     *
     * @generated from field: int64 fixed = 1;
     */
    value: bigint;
    case: "fixed";
  } | {
    /**
     * 
     * The fee limit expressed as a fixed amount of millisatoshis.
     * 
     * The fields fixed and fixed_msat are mutually exclusive.
     *
     * @generated from field: int64 fixed_msat = 3;
     */
    value: bigint;
    case: "fixedMsat";
  } | {
    /**
     * The fee limit expressed as a percentage of the payment amount.
     *
     * @generated from field: int64 percent = 2;
     */
    value: bigint;
    case: "percent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.FeeLimit.
 * Use `create(FeeLimitSchema)` to create a new message.
 */
export const FeeLimitSchema: GenMessage<FeeLimit> = /*@__PURE__*/
  messageDesc(file_lightning, 11);

/**
 * @generated from message lnrpc.SendRequest
 */
export type SendRequest = Message<"lnrpc.SendRequest"> & {
  /**
   * 
   * The identity pubkey of the payment recipient. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes dest = 1;
   */
  dest: Uint8Array;

  /**
   * 
   * The hex-encoded identity pubkey of the payment recipient. Deprecated now
   * that the REST gateway supports base64 encoding of bytes fields.
   *
   * @generated from field: string dest_string = 2 [deprecated = true];
   * @deprecated
   */
  destString: string;

  /**
   * 
   * The amount to send expressed in satoshis.
   * 
   * The fields amt and amt_msat are mutually exclusive.
   *
   * @generated from field: int64 amt = 3;
   */
  amt: bigint;

  /**
   * 
   * The amount to send expressed in millisatoshis.
   * 
   * The fields amt and amt_msat are mutually exclusive.
   *
   * @generated from field: int64 amt_msat = 12;
   */
  amtMsat: bigint;

  /**
   * 
   * The hash to use within the payment's HTLC. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes payment_hash = 4;
   */
  paymentHash: Uint8Array;

  /**
   * 
   * The hex-encoded hash to use within the payment's HTLC. Deprecated now
   * that the REST gateway supports base64 encoding of bytes fields.
   *
   * @generated from field: string payment_hash_string = 5 [deprecated = true];
   * @deprecated
   */
  paymentHashString: string;

  /**
   * 
   * A bare-bones invoice for a payment within the Lightning Network. With the
   * details of the invoice, the sender has all the data necessary to send a
   * payment to the recipient.
   *
   * @generated from field: string payment_request = 6;
   */
  paymentRequest: string;

  /**
   * 
   * The CLTV delta from the current height that should be used to set the
   * timelock for the final hop.
   *
   * @generated from field: int32 final_cltv_delta = 7;
   */
  finalCltvDelta: number;

  /**
   * 
   * The maximum number of satoshis that will be paid as a fee of the payment.
   * This value can be represented either as a percentage of the amount being
   * sent, or as a fixed amount of the maximum fee the user is willing the pay to
   * send the payment. If not specified, lnd will use a default value of 100%
   * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
   *
   * @generated from field: lnrpc.FeeLimit fee_limit = 8;
   */
  feeLimit?: FeeLimit;

  /**
   * 
   * The channel id of the channel that must be taken to the first hop. If zero,
   * any channel may be used.
   *
   * @generated from field: uint64 outgoing_chan_id = 9 [jstype = JS_STRING];
   */
  outgoingChanId: string;

  /**
   * 
   * The pubkey of the last hop of the route. If empty, any hop may be used.
   *
   * @generated from field: bytes last_hop_pubkey = 13;
   */
  lastHopPubkey: Uint8Array;

  /**
   * 
   * An optional maximum total time lock for the route. This should not exceed
   * lnd's `--max-cltv-expiry` setting. If zero, then the value of
   * `--max-cltv-expiry` is enforced.
   *
   * @generated from field: uint32 cltv_limit = 10;
   */
  cltvLimit: number;

  /**
   * 
   * An optional field that can be used to pass an arbitrary set of TLV records
   * to a peer which understands the new records. This can be used to pass
   * application specific data during the payment attempt. Record types are
   * required to be in the custom range >= 65536. When using REST, the values
   * must be encoded as base64.
   *
   * @generated from field: map<uint64, bytes> dest_custom_records = 11;
   */
  destCustomRecords: { [key: string]: Uint8Array };

  /**
   * If set, circular payments to self are permitted.
   *
   * @generated from field: bool allow_self_payment = 14;
   */
  allowSelfPayment: boolean;

  /**
   * 
   * Features assumed to be supported by the final node. All transitive feature
   * dependencies must also be set properly. For a given feature bit pair, either
   * optional or remote may be set, but not both. If this field is nil or empty,
   * the router will try to load destination features from the graph as a
   * fallback.
   *
   * @generated from field: repeated lnrpc.FeatureBit dest_features = 15;
   */
  destFeatures: FeatureBit[];

  /**
   * 
   * The payment address of the generated invoice.
   *
   * @generated from field: bytes payment_addr = 16;
   */
  paymentAddr: Uint8Array;
};

/**
 * Describes the message lnrpc.SendRequest.
 * Use `create(SendRequestSchema)` to create a new message.
 */
export const SendRequestSchema: GenMessage<SendRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 12);

/**
 * @generated from message lnrpc.SendResponse
 */
export type SendResponse = Message<"lnrpc.SendResponse"> & {
  /**
   * @generated from field: string payment_error = 1;
   */
  paymentError: string;

  /**
   * @generated from field: bytes payment_preimage = 2;
   */
  paymentPreimage: Uint8Array;

  /**
   * @generated from field: lnrpc.Route payment_route = 3;
   */
  paymentRoute?: Route;

  /**
   * @generated from field: bytes payment_hash = 4;
   */
  paymentHash: Uint8Array;
};

/**
 * Describes the message lnrpc.SendResponse.
 * Use `create(SendResponseSchema)` to create a new message.
 */
export const SendResponseSchema: GenMessage<SendResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 13);

/**
 * @generated from message lnrpc.SendToRouteRequest
 */
export type SendToRouteRequest = Message<"lnrpc.SendToRouteRequest"> & {
  /**
   * 
   * The payment hash to use for the HTLC. When using REST, this field must be
   * encoded as base64.
   *
   * @generated from field: bytes payment_hash = 1;
   */
  paymentHash: Uint8Array;

  /**
   * 
   * An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
   * that the REST gateway supports base64 encoding of bytes fields.
   *
   * @generated from field: string payment_hash_string = 2 [deprecated = true];
   * @deprecated
   */
  paymentHashString: string;

  /**
   * Route that should be used to attempt to complete the payment.
   *
   * @generated from field: lnrpc.Route route = 4;
   */
  route?: Route;
};

/**
 * Describes the message lnrpc.SendToRouteRequest.
 * Use `create(SendToRouteRequestSchema)` to create a new message.
 */
export const SendToRouteRequestSchema: GenMessage<SendToRouteRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 14);

/**
 * @generated from message lnrpc.ChannelAcceptRequest
 */
export type ChannelAcceptRequest = Message<"lnrpc.ChannelAcceptRequest"> & {
  /**
   * The pubkey of the node that wishes to open an inbound channel.
   *
   * @generated from field: bytes node_pubkey = 1;
   */
  nodePubkey: Uint8Array;

  /**
   * The hash of the genesis block that the proposed channel resides in.
   *
   * @generated from field: bytes chain_hash = 2;
   */
  chainHash: Uint8Array;

  /**
   * The pending channel id.
   *
   * @generated from field: bytes pending_chan_id = 3;
   */
  pendingChanId: Uint8Array;

  /**
   * The funding amount in satoshis that initiator wishes to use in the
   * channel.
   *
   * @generated from field: uint64 funding_amt = 4;
   */
  fundingAmt: bigint;

  /**
   * The push amount of the proposed channel in millisatoshis.
   *
   * @generated from field: uint64 push_amt = 5;
   */
  pushAmt: bigint;

  /**
   * The dust limit of the initiator's commitment tx.
   *
   * @generated from field: uint64 dust_limit = 6;
   */
  dustLimit: bigint;

  /**
   * The maximum amount of coins in millisatoshis that can be pending in this
   * channel.
   *
   * @generated from field: uint64 max_value_in_flight = 7;
   */
  maxValueInFlight: bigint;

  /**
   * The minimum amount of satoshis the initiator requires us to have at all
   * times.
   *
   * @generated from field: uint64 channel_reserve = 8;
   */
  channelReserve: bigint;

  /**
   * The smallest HTLC in millisatoshis that the initiator will accept.
   *
   * @generated from field: uint64 min_htlc = 9;
   */
  minHtlc: bigint;

  /**
   * The initial fee rate that the initiator suggests for both commitment
   * transactions.
   *
   * @generated from field: uint64 fee_per_kw = 10;
   */
  feePerKw: bigint;

  /**
   * 
   * The number of blocks to use for the relative time lock in the pay-to-self
   * output of both commitment transactions.
   *
   * @generated from field: uint32 csv_delay = 11;
   */
  csvDelay: number;

  /**
   * The total number of incoming HTLC's that the initiator will accept.
   *
   * @generated from field: uint32 max_accepted_htlcs = 12;
   */
  maxAcceptedHtlcs: number;

  /**
   * A bit-field which the initiator uses to specify proposed channel
   * behavior.
   *
   * @generated from field: uint32 channel_flags = 13;
   */
  channelFlags: number;

  /**
   * The commitment type the initiator wishes to use for the proposed channel.
   *
   * @generated from field: lnrpc.CommitmentType commitment_type = 14;
   */
  commitmentType: CommitmentType;

  /**
   * Whether the initiator wants to open a zero-conf channel via the channel
   * type.
   *
   * @generated from field: bool wants_zero_conf = 15;
   */
  wantsZeroConf: boolean;

  /**
   * Whether the initiator wants to use the scid-alias channel type. This is
   * separate from the feature bit.
   *
   * @generated from field: bool wants_scid_alias = 16;
   */
  wantsScidAlias: boolean;
};

/**
 * Describes the message lnrpc.ChannelAcceptRequest.
 * Use `create(ChannelAcceptRequestSchema)` to create a new message.
 */
export const ChannelAcceptRequestSchema: GenMessage<ChannelAcceptRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 15);

/**
 * @generated from message lnrpc.ChannelAcceptResponse
 */
export type ChannelAcceptResponse = Message<"lnrpc.ChannelAcceptResponse"> & {
  /**
   * Whether or not the client accepts the channel.
   *
   * @generated from field: bool accept = 1;
   */
  accept: boolean;

  /**
   * The pending channel id to which this response applies.
   *
   * @generated from field: bytes pending_chan_id = 2;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * An optional error to send the initiating party to indicate why the channel
   * was rejected. This field *should not* contain sensitive information, it will
   * be sent to the initiating party. This field should only be set if accept is
   * false, the channel will be rejected if an error is set with accept=true
   * because the meaning of this response is ambiguous. Limited to 500
   * characters.
   *
   * @generated from field: string error = 3;
   */
  error: string;

  /**
   * 
   * The upfront shutdown address to use if the initiating peer supports option
   * upfront shutdown script (see ListPeers for the features supported). Note
   * that the channel open will fail if this value is set for a peer that does
   * not support this feature bit.
   *
   * @generated from field: string upfront_shutdown = 4;
   */
  upfrontShutdown: string;

  /**
   * 
   * The csv delay (in blocks) that we require for the remote party.
   *
   * @generated from field: uint32 csv_delay = 5;
   */
  csvDelay: number;

  /**
   * 
   * The reserve amount in satoshis that we require the remote peer to adhere to.
   * We require that the remote peer always have some reserve amount allocated to
   * them so that there is always a disincentive to broadcast old state (if they
   * hold 0 sats on their side of the channel, there is nothing to lose).
   *
   * @generated from field: uint64 reserve_sat = 6;
   */
  reserveSat: bigint;

  /**
   * 
   * The maximum amount of funds in millisatoshis that we allow the remote peer
   * to have in outstanding htlcs.
   *
   * @generated from field: uint64 in_flight_max_msat = 7;
   */
  inFlightMaxMsat: bigint;

  /**
   * 
   * The maximum number of htlcs that the remote peer can offer us.
   *
   * @generated from field: uint32 max_htlc_count = 8;
   */
  maxHtlcCount: number;

  /**
   * 
   * The minimum value in millisatoshis for incoming htlcs on the channel.
   *
   * @generated from field: uint64 min_htlc_in = 9;
   */
  minHtlcIn: bigint;

  /**
   * 
   * The number of confirmations we require before we consider the channel open.
   *
   * @generated from field: uint32 min_accept_depth = 10;
   */
  minAcceptDepth: number;

  /**
   * 
   * Whether the responder wants this to be a zero-conf channel. This will fail
   * if either side does not have the scid-alias feature bit set. The minimum
   * depth field must be zero if this is true.
   *
   * @generated from field: bool zero_conf = 11;
   */
  zeroConf: boolean;
};

/**
 * Describes the message lnrpc.ChannelAcceptResponse.
 * Use `create(ChannelAcceptResponseSchema)` to create a new message.
 */
export const ChannelAcceptResponseSchema: GenMessage<ChannelAcceptResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 16);

/**
 * @generated from message lnrpc.ChannelPoint
 */
export type ChannelPoint = Message<"lnrpc.ChannelPoint"> & {
  /**
   * @generated from oneof lnrpc.ChannelPoint.funding_txid
   */
  fundingTxid: {
    /**
     * 
     * Txid of the funding transaction. When using REST, this field must be
     * encoded as base64.
     *
     * @generated from field: bytes funding_txid_bytes = 1;
     */
    value: Uint8Array;
    case: "fundingTxidBytes";
  } | {
    /**
     * 
     * Hex-encoded string representing the byte-reversed hash of the funding
     * transaction.
     *
     * @generated from field: string funding_txid_str = 2;
     */
    value: string;
    case: "fundingTxidStr";
  } | { case: undefined; value?: undefined };

  /**
   * The index of the output of the funding transaction
   *
   * @generated from field: uint32 output_index = 3;
   */
  outputIndex: number;
};

/**
 * Describes the message lnrpc.ChannelPoint.
 * Use `create(ChannelPointSchema)` to create a new message.
 */
export const ChannelPointSchema: GenMessage<ChannelPoint> = /*@__PURE__*/
  messageDesc(file_lightning, 17);

/**
 * @generated from message lnrpc.OutPoint
 */
export type OutPoint = Message<"lnrpc.OutPoint"> & {
  /**
   * Raw bytes representing the transaction id.
   *
   * @generated from field: bytes txid_bytes = 1;
   */
  txidBytes: Uint8Array;

  /**
   * Reversed, hex-encoded string representing the transaction id.
   *
   * @generated from field: string txid_str = 2;
   */
  txidStr: string;

  /**
   * The index of the output on the transaction.
   *
   * @generated from field: uint32 output_index = 3;
   */
  outputIndex: number;
};

/**
 * Describes the message lnrpc.OutPoint.
 * Use `create(OutPointSchema)` to create a new message.
 */
export const OutPointSchema: GenMessage<OutPoint> = /*@__PURE__*/
  messageDesc(file_lightning, 18);

/**
 * @generated from message lnrpc.PreviousOutPoint
 */
export type PreviousOutPoint = Message<"lnrpc.PreviousOutPoint"> & {
  /**
   * The outpoint in format txid:n.
   *
   * @generated from field: string outpoint = 1;
   */
  outpoint: string;

  /**
   * Denotes if the outpoint is controlled by the internal wallet.
   * The flag will only detect p2wkh, np2wkh and p2tr inputs as its own.
   *
   * @generated from field: bool is_our_output = 2;
   */
  isOurOutput: boolean;
};

/**
 * Describes the message lnrpc.PreviousOutPoint.
 * Use `create(PreviousOutPointSchema)` to create a new message.
 */
export const PreviousOutPointSchema: GenMessage<PreviousOutPoint> = /*@__PURE__*/
  messageDesc(file_lightning, 19);

/**
 * @generated from message lnrpc.LightningAddress
 */
export type LightningAddress = Message<"lnrpc.LightningAddress"> & {
  /**
   * The identity pubkey of the Lightning node.
   *
   * @generated from field: string pubkey = 1;
   */
  pubkey: string;

  /**
   * The network location of the lightning node, e.g. `69.69.69.69:1337` or
   * `localhost:10011`.
   *
   * @generated from field: string host = 2;
   */
  host: string;
};

/**
 * Describes the message lnrpc.LightningAddress.
 * Use `create(LightningAddressSchema)` to create a new message.
 */
export const LightningAddressSchema: GenMessage<LightningAddress> = /*@__PURE__*/
  messageDesc(file_lightning, 20);

/**
 * @generated from message lnrpc.EstimateFeeRequest
 */
export type EstimateFeeRequest = Message<"lnrpc.EstimateFeeRequest"> & {
  /**
   * The map from addresses to amounts for the transaction.
   *
   * @generated from field: map<string, int64> AddrToAmount = 1;
   */
  AddrToAmount: { [key: string]: bigint };

  /**
   * The target number of blocks that this transaction should be confirmed
   * by.
   *
   * @generated from field: int32 target_conf = 2;
   */
  targetConf: number;

  /**
   * The minimum number of confirmations each one of your outputs used for
   * the transaction must satisfy.
   *
   * @generated from field: int32 min_confs = 3;
   */
  minConfs: number;

  /**
   * Whether unconfirmed outputs should be used as inputs for the transaction.
   *
   * @generated from field: bool spend_unconfirmed = 4;
   */
  spendUnconfirmed: boolean;
};

/**
 * Describes the message lnrpc.EstimateFeeRequest.
 * Use `create(EstimateFeeRequestSchema)` to create a new message.
 */
export const EstimateFeeRequestSchema: GenMessage<EstimateFeeRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 21);

/**
 * @generated from message lnrpc.EstimateFeeResponse
 */
export type EstimateFeeResponse = Message<"lnrpc.EstimateFeeResponse"> & {
  /**
   * The total fee in satoshis.
   *
   * @generated from field: int64 fee_sat = 1;
   */
  feeSat: bigint;

  /**
   * Deprecated, use sat_per_vbyte.
   * The fee rate in satoshi/vbyte.
   *
   * @generated from field: int64 feerate_sat_per_byte = 2 [deprecated = true];
   * @deprecated
   */
  feerateSatPerByte: bigint;

  /**
   * The fee rate in satoshi/vbyte.
   *
   * @generated from field: uint64 sat_per_vbyte = 3;
   */
  satPerVbyte: bigint;
};

/**
 * Describes the message lnrpc.EstimateFeeResponse.
 * Use `create(EstimateFeeResponseSchema)` to create a new message.
 */
export const EstimateFeeResponseSchema: GenMessage<EstimateFeeResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 22);

/**
 * @generated from message lnrpc.SendManyRequest
 */
export type SendManyRequest = Message<"lnrpc.SendManyRequest"> & {
  /**
   * The map from addresses to amounts
   *
   * @generated from field: map<string, int64> AddrToAmount = 1;
   */
  AddrToAmount: { [key: string]: bigint };

  /**
   * The target number of blocks that this transaction should be confirmed
   * by.
   *
   * @generated from field: int32 target_conf = 3;
   */
  targetConf: number;

  /**
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * transaction.
   *
   * @generated from field: uint64 sat_per_vbyte = 4;
   */
  satPerVbyte: bigint;

  /**
   * Deprecated, use sat_per_vbyte.
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * transaction.
   *
   * @generated from field: int64 sat_per_byte = 5 [deprecated = true];
   * @deprecated
   */
  satPerByte: bigint;

  /**
   * An optional label for the transaction, limited to 500 characters.
   *
   * @generated from field: string label = 6;
   */
  label: string;

  /**
   * The minimum number of confirmations each one of your outputs used for
   * the transaction must satisfy.
   *
   * @generated from field: int32 min_confs = 7;
   */
  minConfs: number;

  /**
   * Whether unconfirmed outputs should be used as inputs for the transaction.
   *
   * @generated from field: bool spend_unconfirmed = 8;
   */
  spendUnconfirmed: boolean;
};

/**
 * Describes the message lnrpc.SendManyRequest.
 * Use `create(SendManyRequestSchema)` to create a new message.
 */
export const SendManyRequestSchema: GenMessage<SendManyRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 23);

/**
 * @generated from message lnrpc.SendManyResponse
 */
export type SendManyResponse = Message<"lnrpc.SendManyResponse"> & {
  /**
   * The id of the transaction
   *
   * @generated from field: string txid = 1;
   */
  txid: string;
};

/**
 * Describes the message lnrpc.SendManyResponse.
 * Use `create(SendManyResponseSchema)` to create a new message.
 */
export const SendManyResponseSchema: GenMessage<SendManyResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 24);

/**
 * @generated from message lnrpc.SendCoinsRequest
 */
export type SendCoinsRequest = Message<"lnrpc.SendCoinsRequest"> & {
  /**
   * The address to send coins to
   *
   * @generated from field: string addr = 1;
   */
  addr: string;

  /**
   * The amount in satoshis to send
   *
   * @generated from field: int64 amount = 2;
   */
  amount: bigint;

  /**
   * The target number of blocks that this transaction should be confirmed
   * by.
   *
   * @generated from field: int32 target_conf = 3;
   */
  targetConf: number;

  /**
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * transaction.
   *
   * @generated from field: uint64 sat_per_vbyte = 4;
   */
  satPerVbyte: bigint;

  /**
   * Deprecated, use sat_per_vbyte.
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * transaction.
   *
   * @generated from field: int64 sat_per_byte = 5 [deprecated = true];
   * @deprecated
   */
  satPerByte: bigint;

  /**
   * 
   * If set, then the amount field will be ignored, and lnd will attempt to
   * send all the coins under control of the internal wallet to the specified
   * address.
   *
   * @generated from field: bool send_all = 6;
   */
  sendAll: boolean;

  /**
   * An optional label for the transaction, limited to 500 characters.
   *
   * @generated from field: string label = 7;
   */
  label: string;

  /**
   * The minimum number of confirmations each one of your outputs used for
   * the transaction must satisfy.
   *
   * @generated from field: int32 min_confs = 8;
   */
  minConfs: number;

  /**
   * Whether unconfirmed outputs should be used as inputs for the transaction.
   *
   * @generated from field: bool spend_unconfirmed = 9;
   */
  spendUnconfirmed: boolean;
};

/**
 * Describes the message lnrpc.SendCoinsRequest.
 * Use `create(SendCoinsRequestSchema)` to create a new message.
 */
export const SendCoinsRequestSchema: GenMessage<SendCoinsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 25);

/**
 * @generated from message lnrpc.SendCoinsResponse
 */
export type SendCoinsResponse = Message<"lnrpc.SendCoinsResponse"> & {
  /**
   * The transaction ID of the transaction
   *
   * @generated from field: string txid = 1;
   */
  txid: string;
};

/**
 * Describes the message lnrpc.SendCoinsResponse.
 * Use `create(SendCoinsResponseSchema)` to create a new message.
 */
export const SendCoinsResponseSchema: GenMessage<SendCoinsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 26);

/**
 * @generated from message lnrpc.ListUnspentRequest
 */
export type ListUnspentRequest = Message<"lnrpc.ListUnspentRequest"> & {
  /**
   * The minimum number of confirmations to be included.
   *
   * @generated from field: int32 min_confs = 1;
   */
  minConfs: number;

  /**
   * The maximum number of confirmations to be included.
   *
   * @generated from field: int32 max_confs = 2;
   */
  maxConfs: number;

  /**
   * An optional filter to only include outputs belonging to an account.
   *
   * @generated from field: string account = 3;
   */
  account: string;
};

/**
 * Describes the message lnrpc.ListUnspentRequest.
 * Use `create(ListUnspentRequestSchema)` to create a new message.
 */
export const ListUnspentRequestSchema: GenMessage<ListUnspentRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 27);

/**
 * @generated from message lnrpc.ListUnspentResponse
 */
export type ListUnspentResponse = Message<"lnrpc.ListUnspentResponse"> & {
  /**
   * A list of utxos
   *
   * @generated from field: repeated lnrpc.Utxo utxos = 1;
   */
  utxos: Utxo[];
};

/**
 * Describes the message lnrpc.ListUnspentResponse.
 * Use `create(ListUnspentResponseSchema)` to create a new message.
 */
export const ListUnspentResponseSchema: GenMessage<ListUnspentResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 28);

/**
 * @generated from message lnrpc.NewAddressRequest
 */
export type NewAddressRequest = Message<"lnrpc.NewAddressRequest"> & {
  /**
   * The type of address to generate.
   *
   * @generated from field: lnrpc.AddressType type = 1;
   */
  type: AddressType;

  /**
   * 
   * The name of the account to generate a new address for. If empty, the
   * default wallet account is used.
   *
   * @generated from field: string account = 2;
   */
  account: string;
};

/**
 * Describes the message lnrpc.NewAddressRequest.
 * Use `create(NewAddressRequestSchema)` to create a new message.
 */
export const NewAddressRequestSchema: GenMessage<NewAddressRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 29);

/**
 * @generated from message lnrpc.NewAddressResponse
 */
export type NewAddressResponse = Message<"lnrpc.NewAddressResponse"> & {
  /**
   * The newly generated wallet address
   *
   * @generated from field: string address = 1;
   */
  address: string;
};

/**
 * Describes the message lnrpc.NewAddressResponse.
 * Use `create(NewAddressResponseSchema)` to create a new message.
 */
export const NewAddressResponseSchema: GenMessage<NewAddressResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 30);

/**
 * @generated from message lnrpc.SignMessageRequest
 */
export type SignMessageRequest = Message<"lnrpc.SignMessageRequest"> & {
  /**
   * 
   * The message to be signed. When using REST, this field must be encoded as
   * base64.
   *
   * @generated from field: bytes msg = 1;
   */
  msg: Uint8Array;

  /**
   * 
   * Instead of the default double-SHA256 hashing of the message before signing,
   * only use one round of hashing instead.
   *
   * @generated from field: bool single_hash = 2;
   */
  singleHash: boolean;
};

/**
 * Describes the message lnrpc.SignMessageRequest.
 * Use `create(SignMessageRequestSchema)` to create a new message.
 */
export const SignMessageRequestSchema: GenMessage<SignMessageRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 31);

/**
 * @generated from message lnrpc.SignMessageResponse
 */
export type SignMessageResponse = Message<"lnrpc.SignMessageResponse"> & {
  /**
   * The signature for the given message
   *
   * @generated from field: string signature = 1;
   */
  signature: string;
};

/**
 * Describes the message lnrpc.SignMessageResponse.
 * Use `create(SignMessageResponseSchema)` to create a new message.
 */
export const SignMessageResponseSchema: GenMessage<SignMessageResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 32);

/**
 * @generated from message lnrpc.VerifyMessageRequest
 */
export type VerifyMessageRequest = Message<"lnrpc.VerifyMessageRequest"> & {
  /**
   * 
   * The message over which the signature is to be verified. When using REST,
   * this field must be encoded as base64.
   *
   * @generated from field: bytes msg = 1;
   */
  msg: Uint8Array;

  /**
   * The signature to be verified over the given message
   *
   * @generated from field: string signature = 2;
   */
  signature: string;
};

/**
 * Describes the message lnrpc.VerifyMessageRequest.
 * Use `create(VerifyMessageRequestSchema)` to create a new message.
 */
export const VerifyMessageRequestSchema: GenMessage<VerifyMessageRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 33);

/**
 * @generated from message lnrpc.VerifyMessageResponse
 */
export type VerifyMessageResponse = Message<"lnrpc.VerifyMessageResponse"> & {
  /**
   * Whether the signature was valid over the given message
   *
   * @generated from field: bool valid = 1;
   */
  valid: boolean;

  /**
   * The pubkey recovered from the signature
   *
   * @generated from field: string pubkey = 2;
   */
  pubkey: string;
};

/**
 * Describes the message lnrpc.VerifyMessageResponse.
 * Use `create(VerifyMessageResponseSchema)` to create a new message.
 */
export const VerifyMessageResponseSchema: GenMessage<VerifyMessageResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 34);

/**
 * @generated from message lnrpc.ConnectPeerRequest
 */
export type ConnectPeerRequest = Message<"lnrpc.ConnectPeerRequest"> & {
  /**
   * 
   * Lightning address of the peer to connect to.
   *
   * @generated from field: lnrpc.LightningAddress addr = 1;
   */
  addr?: LightningAddress;

  /**
   * 
   * If set, the daemon will attempt to persistently connect to the target
   * peer. Otherwise, the call will be synchronous.
   *
   * @generated from field: bool perm = 2;
   */
  perm: boolean;

  /**
   * 
   * The connection timeout value (in seconds) for this request. It won't affect
   * other requests.
   *
   * @generated from field: uint64 timeout = 3;
   */
  timeout: bigint;
};

/**
 * Describes the message lnrpc.ConnectPeerRequest.
 * Use `create(ConnectPeerRequestSchema)` to create a new message.
 */
export const ConnectPeerRequestSchema: GenMessage<ConnectPeerRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 35);

/**
 * @generated from message lnrpc.ConnectPeerResponse
 */
export type ConnectPeerResponse = Message<"lnrpc.ConnectPeerResponse"> & {
};

/**
 * Describes the message lnrpc.ConnectPeerResponse.
 * Use `create(ConnectPeerResponseSchema)` to create a new message.
 */
export const ConnectPeerResponseSchema: GenMessage<ConnectPeerResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 36);

/**
 * @generated from message lnrpc.DisconnectPeerRequest
 */
export type DisconnectPeerRequest = Message<"lnrpc.DisconnectPeerRequest"> & {
  /**
   * The pubkey of the node to disconnect from
   *
   * @generated from field: string pub_key = 1;
   */
  pubKey: string;
};

/**
 * Describes the message lnrpc.DisconnectPeerRequest.
 * Use `create(DisconnectPeerRequestSchema)` to create a new message.
 */
export const DisconnectPeerRequestSchema: GenMessage<DisconnectPeerRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 37);

/**
 * @generated from message lnrpc.DisconnectPeerResponse
 */
export type DisconnectPeerResponse = Message<"lnrpc.DisconnectPeerResponse"> & {
};

/**
 * Describes the message lnrpc.DisconnectPeerResponse.
 * Use `create(DisconnectPeerResponseSchema)` to create a new message.
 */
export const DisconnectPeerResponseSchema: GenMessage<DisconnectPeerResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 38);

/**
 * @generated from message lnrpc.HTLC
 */
export type HTLC = Message<"lnrpc.HTLC"> & {
  /**
   * @generated from field: bool incoming = 1;
   */
  incoming: boolean;

  /**
   * @generated from field: int64 amount = 2;
   */
  amount: bigint;

  /**
   * @generated from field: bytes hash_lock = 3;
   */
  hashLock: Uint8Array;

  /**
   * @generated from field: uint32 expiration_height = 4;
   */
  expirationHeight: number;

  /**
   * Index identifying the htlc on the channel.
   *
   * @generated from field: uint64 htlc_index = 5;
   */
  htlcIndex: bigint;

  /**
   * If this HTLC is involved in a forwarding operation, this field indicates
   * the forwarding channel. For an outgoing htlc, it is the incoming channel.
   * For an incoming htlc, it is the outgoing channel. When the htlc
   * originates from this node or this node is the final destination,
   * forwarding_channel will be zero. The forwarding channel will also be zero
   * for htlcs that need to be forwarded but don't have a forwarding decision
   * persisted yet.
   *
   * @generated from field: uint64 forwarding_channel = 6;
   */
  forwardingChannel: bigint;

  /**
   * Index identifying the htlc on the forwarding channel.
   *
   * @generated from field: uint64 forwarding_htlc_index = 7;
   */
  forwardingHtlcIndex: bigint;
};

/**
 * Describes the message lnrpc.HTLC.
 * Use `create(HTLCSchema)` to create a new message.
 */
export const HTLCSchema: GenMessage<HTLC> = /*@__PURE__*/
  messageDesc(file_lightning, 39);

/**
 * @generated from message lnrpc.ChannelConstraints
 */
export type ChannelConstraints = Message<"lnrpc.ChannelConstraints"> & {
  /**
   * 
   * The CSV delay expressed in relative blocks. If the channel is force closed,
   * we will need to wait for this many blocks before we can regain our funds.
   *
   * @generated from field: uint32 csv_delay = 1;
   */
  csvDelay: number;

  /**
   * The minimum satoshis this node is required to reserve in its balance.
   *
   * @generated from field: uint64 chan_reserve_sat = 2;
   */
  chanReserveSat: bigint;

  /**
   * The dust limit (in satoshis) of the initiator's commitment tx.
   *
   * @generated from field: uint64 dust_limit_sat = 3;
   */
  dustLimitSat: bigint;

  /**
   * The maximum amount of coins in millisatoshis that can be pending in this
   * channel.
   *
   * @generated from field: uint64 max_pending_amt_msat = 4;
   */
  maxPendingAmtMsat: bigint;

  /**
   * The smallest HTLC in millisatoshis that the initiator will accept.
   *
   * @generated from field: uint64 min_htlc_msat = 5;
   */
  minHtlcMsat: bigint;

  /**
   * The total number of incoming HTLC's that the initiator will accept.
   *
   * @generated from field: uint32 max_accepted_htlcs = 6;
   */
  maxAcceptedHtlcs: number;
};

/**
 * Describes the message lnrpc.ChannelConstraints.
 * Use `create(ChannelConstraintsSchema)` to create a new message.
 */
export const ChannelConstraintsSchema: GenMessage<ChannelConstraints> = /*@__PURE__*/
  messageDesc(file_lightning, 40);

/**
 * @generated from message lnrpc.Channel
 */
export type Channel = Message<"lnrpc.Channel"> & {
  /**
   * Whether this channel is active or not
   *
   * @generated from field: bool active = 1;
   */
  active: boolean;

  /**
   * The identity pubkey of the remote node
   *
   * @generated from field: string remote_pubkey = 2;
   */
  remotePubkey: string;

  /**
   * 
   * The outpoint (txid:index) of the funding transaction. With this value, Bob
   * will be able to generate a signature for Alice's version of the commitment
   * transaction.
   *
   * @generated from field: string channel_point = 3;
   */
  channelPoint: string;

  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 chan_id = 4 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * The total amount of funds held in this channel
   *
   * @generated from field: int64 capacity = 5;
   */
  capacity: bigint;

  /**
   * This node's current balance in this channel
   *
   * @generated from field: int64 local_balance = 6;
   */
  localBalance: bigint;

  /**
   * The counterparty's current balance in this channel
   *
   * @generated from field: int64 remote_balance = 7;
   */
  remoteBalance: bigint;

  /**
   * 
   * The amount calculated to be paid in fees for the current set of commitment
   * transactions. The fee amount is persisted with the channel in order to
   * allow the fee amount to be removed and recalculated with each channel state
   * update, including updates that happen after a system restart.
   *
   * @generated from field: int64 commit_fee = 8;
   */
  commitFee: bigint;

  /**
   * The weight of the commitment transaction
   *
   * @generated from field: int64 commit_weight = 9;
   */
  commitWeight: bigint;

  /**
   * 
   * The required number of satoshis per kilo-weight that the requester will pay
   * at all times, for both the funding transaction and commitment transaction.
   * This value can later be updated once the channel is open.
   *
   * @generated from field: int64 fee_per_kw = 10;
   */
  feePerKw: bigint;

  /**
   * The unsettled balance in this channel
   *
   * @generated from field: int64 unsettled_balance = 11;
   */
  unsettledBalance: bigint;

  /**
   * 
   * The total number of satoshis we've sent within this channel.
   *
   * @generated from field: int64 total_satoshis_sent = 12;
   */
  totalSatoshisSent: bigint;

  /**
   * 
   * The total number of satoshis we've received within this channel.
   *
   * @generated from field: int64 total_satoshis_received = 13;
   */
  totalSatoshisReceived: bigint;

  /**
   * 
   * The total number of updates conducted within this channel.
   *
   * @generated from field: uint64 num_updates = 14;
   */
  numUpdates: bigint;

  /**
   * 
   * The list of active, uncleared HTLCs currently pending within the channel.
   *
   * @generated from field: repeated lnrpc.HTLC pending_htlcs = 15;
   */
  pendingHtlcs: HTLC[];

  /**
   * 
   * Deprecated. The CSV delay expressed in relative blocks. If the channel is
   * force closed, we will need to wait for this many blocks before we can regain
   * our funds.
   *
   * @generated from field: uint32 csv_delay = 16 [deprecated = true];
   * @deprecated
   */
  csvDelay: number;

  /**
   * Whether this channel is advertised to the network or not.
   *
   * @generated from field: bool private = 17;
   */
  private: boolean;

  /**
   * True if we were the ones that created the channel.
   *
   * @generated from field: bool initiator = 18;
   */
  initiator: boolean;

  /**
   * A set of flags showing the current state of the channel.
   *
   * @generated from field: string chan_status_flags = 19;
   */
  chanStatusFlags: string;

  /**
   * Deprecated. The minimum satoshis this node is required to reserve in its
   * balance.
   *
   * @generated from field: int64 local_chan_reserve_sat = 20 [deprecated = true];
   * @deprecated
   */
  localChanReserveSat: bigint;

  /**
   * 
   * Deprecated. The minimum satoshis the other node is required to reserve in
   * its balance.
   *
   * @generated from field: int64 remote_chan_reserve_sat = 21 [deprecated = true];
   * @deprecated
   */
  remoteChanReserveSat: bigint;

  /**
   * Deprecated. Use commitment_type.
   *
   * @generated from field: bool static_remote_key = 22 [deprecated = true];
   * @deprecated
   */
  staticRemoteKey: boolean;

  /**
   * The commitment type used by this channel.
   *
   * @generated from field: lnrpc.CommitmentType commitment_type = 26;
   */
  commitmentType: CommitmentType;

  /**
   * 
   * The number of seconds that the channel has been monitored by the channel
   * scoring system. Scores are currently not persisted, so this value may be
   * less than the lifetime of the channel [EXPERIMENTAL].
   *
   * @generated from field: int64 lifetime = 23;
   */
  lifetime: bigint;

  /**
   * 
   * The number of seconds that the remote peer has been observed as being online
   * by the channel scoring system over the lifetime of the channel
   * [EXPERIMENTAL].
   *
   * @generated from field: int64 uptime = 24;
   */
  uptime: bigint;

  /**
   * 
   * Close address is the address that we will enforce payout to on cooperative
   * close if the channel was opened utilizing option upfront shutdown. This
   * value can be set on channel open by setting close_address in an open channel
   * request. If this value is not set, you can still choose a payout address by
   * cooperatively closing with the delivery_address field set.
   *
   * @generated from field: string close_address = 25;
   */
  closeAddress: string;

  /**
   * 
   * The amount that the initiator of the channel optionally pushed to the remote
   * party on channel open. This amount will be zero if the channel initiator did
   * not push any funds to the remote peer. If the initiator field is true, we
   * pushed this amount to our peer, if it is false, the remote peer pushed this
   * amount to us.
   *
   * @generated from field: uint64 push_amount_sat = 27;
   */
  pushAmountSat: bigint;

  /**
   * 
   * This uint32 indicates if this channel is to be considered 'frozen'. A
   * frozen channel doest not allow a cooperative channel close by the
   * initiator. The thaw_height is the height that this restriction stops
   * applying to the channel. This field is optional, not setting it or using a
   * value of zero will mean the channel has no additional restrictions. The
   * height can be interpreted in two ways: as a relative height if the value is
   * less than 500,000, or as an absolute height otherwise.
   *
   * @generated from field: uint32 thaw_height = 28;
   */
  thawHeight: number;

  /**
   * List constraints for the local node.
   *
   * @generated from field: lnrpc.ChannelConstraints local_constraints = 29;
   */
  localConstraints?: ChannelConstraints;

  /**
   * List constraints for the remote node.
   *
   * @generated from field: lnrpc.ChannelConstraints remote_constraints = 30;
   */
  remoteConstraints?: ChannelConstraints;

  /**
   * 
   * This lists out the set of alias short channel ids that exist for a channel.
   * This may be empty.
   *
   * @generated from field: repeated uint64 alias_scids = 31;
   */
  aliasScids: bigint[];

  /**
   * Whether or not this is a zero-conf channel.
   *
   * @generated from field: bool zero_conf = 32;
   */
  zeroConf: boolean;

  /**
   * This is the confirmed / on-chain zero-conf SCID.
   *
   * @generated from field: uint64 zero_conf_confirmed_scid = 33;
   */
  zeroConfConfirmedScid: bigint;

  /**
   * The configured alias name of our peer.
   *
   * @generated from field: string peer_alias = 34;
   */
  peerAlias: string;

  /**
   * This is the peer SCID alias.
   *
   * @generated from field: uint64 peer_scid_alias = 35 [jstype = JS_STRING];
   */
  peerScidAlias: string;

  /**
   * 
   * An optional note-to-self to go along with the channel containing some
   * useful information. This is only ever stored locally and in no way impacts
   * the channel's operation.
   *
   * @generated from field: string memo = 36;
   */
  memo: string;
};

/**
 * Describes the message lnrpc.Channel.
 * Use `create(ChannelSchema)` to create a new message.
 */
export const ChannelSchema: GenMessage<Channel> = /*@__PURE__*/
  messageDesc(file_lightning, 41);

/**
 * @generated from message lnrpc.ListChannelsRequest
 */
export type ListChannelsRequest = Message<"lnrpc.ListChannelsRequest"> & {
  /**
   * @generated from field: bool active_only = 1;
   */
  activeOnly: boolean;

  /**
   * @generated from field: bool inactive_only = 2;
   */
  inactiveOnly: boolean;

  /**
   * @generated from field: bool public_only = 3;
   */
  publicOnly: boolean;

  /**
   * @generated from field: bool private_only = 4;
   */
  privateOnly: boolean;

  /**
   * 
   * Filters the response for channels with a target peer's pubkey. If peer is
   * empty, all channels will be returned.
   *
   * @generated from field: bytes peer = 5;
   */
  peer: Uint8Array;

  /**
   * Informs the server if the peer alias lookup per channel should be
   * enabled. It is turned off by default in order to avoid degradation of
   * performance for existing clients.
   *
   * @generated from field: bool peer_alias_lookup = 6;
   */
  peerAliasLookup: boolean;
};

/**
 * Describes the message lnrpc.ListChannelsRequest.
 * Use `create(ListChannelsRequestSchema)` to create a new message.
 */
export const ListChannelsRequestSchema: GenMessage<ListChannelsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 42);

/**
 * @generated from message lnrpc.ListChannelsResponse
 */
export type ListChannelsResponse = Message<"lnrpc.ListChannelsResponse"> & {
  /**
   * The list of active channels
   *
   * @generated from field: repeated lnrpc.Channel channels = 11;
   */
  channels: Channel[];
};

/**
 * Describes the message lnrpc.ListChannelsResponse.
 * Use `create(ListChannelsResponseSchema)` to create a new message.
 */
export const ListChannelsResponseSchema: GenMessage<ListChannelsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 43);

/**
 * @generated from message lnrpc.AliasMap
 */
export type AliasMap = Message<"lnrpc.AliasMap"> & {
  /**
   * 
   * For non-zero-conf channels, this is the confirmed SCID. Otherwise, this is
   * the first assigned "base" alias.
   *
   * @generated from field: uint64 base_scid = 1;
   */
  baseScid: bigint;

  /**
   * The set of all aliases stored for the base SCID.
   *
   * @generated from field: repeated uint64 aliases = 2;
   */
  aliases: bigint[];
};

/**
 * Describes the message lnrpc.AliasMap.
 * Use `create(AliasMapSchema)` to create a new message.
 */
export const AliasMapSchema: GenMessage<AliasMap> = /*@__PURE__*/
  messageDesc(file_lightning, 44);

/**
 * @generated from message lnrpc.ListAliasesRequest
 */
export type ListAliasesRequest = Message<"lnrpc.ListAliasesRequest"> & {
};

/**
 * Describes the message lnrpc.ListAliasesRequest.
 * Use `create(ListAliasesRequestSchema)` to create a new message.
 */
export const ListAliasesRequestSchema: GenMessage<ListAliasesRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 45);

/**
 * @generated from message lnrpc.ListAliasesResponse
 */
export type ListAliasesResponse = Message<"lnrpc.ListAliasesResponse"> & {
  /**
   * @generated from field: repeated lnrpc.AliasMap alias_maps = 1;
   */
  aliasMaps: AliasMap[];
};

/**
 * Describes the message lnrpc.ListAliasesResponse.
 * Use `create(ListAliasesResponseSchema)` to create a new message.
 */
export const ListAliasesResponseSchema: GenMessage<ListAliasesResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 46);

/**
 * @generated from message lnrpc.ChannelCloseSummary
 */
export type ChannelCloseSummary = Message<"lnrpc.ChannelCloseSummary"> & {
  /**
   * The outpoint (txid:index) of the funding transaction.
   *
   * @generated from field: string channel_point = 1;
   */
  channelPoint: string;

  /**
   *  The unique channel ID for the channel.
   *
   * @generated from field: uint64 chan_id = 2 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * The hash of the genesis block that this channel resides within.
   *
   * @generated from field: string chain_hash = 3;
   */
  chainHash: string;

  /**
   * The txid of the transaction which ultimately closed this channel.
   *
   * @generated from field: string closing_tx_hash = 4;
   */
  closingTxHash: string;

  /**
   * Public key of the remote peer that we formerly had a channel with.
   *
   * @generated from field: string remote_pubkey = 5;
   */
  remotePubkey: string;

  /**
   * Total capacity of the channel.
   *
   * @generated from field: int64 capacity = 6;
   */
  capacity: bigint;

  /**
   * Height at which the funding transaction was spent.
   *
   * @generated from field: uint32 close_height = 7;
   */
  closeHeight: number;

  /**
   * Settled balance at the time of channel closure
   *
   * @generated from field: int64 settled_balance = 8;
   */
  settledBalance: bigint;

  /**
   * The sum of all the time-locked outputs at the time of channel closure
   *
   * @generated from field: int64 time_locked_balance = 9;
   */
  timeLockedBalance: bigint;

  /**
   * Details on how the channel was closed.
   *
   * @generated from field: lnrpc.ChannelCloseSummary.ClosureType close_type = 10;
   */
  closeType: ChannelCloseSummary_ClosureType;

  /**
   * 
   * Open initiator is the party that initiated opening the channel. Note that
   * this value may be unknown if the channel was closed before we migrated to
   * store open channel information after close.
   *
   * @generated from field: lnrpc.Initiator open_initiator = 11;
   */
  openInitiator: Initiator;

  /**
   * 
   * Close initiator indicates which party initiated the close. This value will
   * be unknown for channels that were cooperatively closed before we started
   * tracking cooperative close initiators. Note that this indicates which party
   * initiated a close, and it is possible for both to initiate cooperative or
   * force closes, although only one party's close will be confirmed on chain.
   *
   * @generated from field: lnrpc.Initiator close_initiator = 12;
   */
  closeInitiator: Initiator;

  /**
   * @generated from field: repeated lnrpc.Resolution resolutions = 13;
   */
  resolutions: Resolution[];

  /**
   * 
   * This lists out the set of alias short channel ids that existed for the
   * closed channel. This may be empty.
   *
   * @generated from field: repeated uint64 alias_scids = 14;
   */
  aliasScids: bigint[];

  /**
   *  The confirmed SCID for a zero-conf channel.
   *
   * @generated from field: uint64 zero_conf_confirmed_scid = 15 [jstype = JS_STRING];
   */
  zeroConfConfirmedScid: string;
};

/**
 * Describes the message lnrpc.ChannelCloseSummary.
 * Use `create(ChannelCloseSummarySchema)` to create a new message.
 */
export const ChannelCloseSummarySchema: GenMessage<ChannelCloseSummary> = /*@__PURE__*/
  messageDesc(file_lightning, 47);

/**
 * @generated from enum lnrpc.ChannelCloseSummary.ClosureType
 */
export enum ChannelCloseSummary_ClosureType {
  /**
   * @generated from enum value: COOPERATIVE_CLOSE = 0;
   */
  COOPERATIVE_CLOSE = 0,

  /**
   * @generated from enum value: LOCAL_FORCE_CLOSE = 1;
   */
  LOCAL_FORCE_CLOSE = 1,

  /**
   * @generated from enum value: REMOTE_FORCE_CLOSE = 2;
   */
  REMOTE_FORCE_CLOSE = 2,

  /**
   * @generated from enum value: BREACH_CLOSE = 3;
   */
  BREACH_CLOSE = 3,

  /**
   * @generated from enum value: FUNDING_CANCELED = 4;
   */
  FUNDING_CANCELED = 4,

  /**
   * @generated from enum value: ABANDONED = 5;
   */
  ABANDONED = 5,
}

/**
 * Describes the enum lnrpc.ChannelCloseSummary.ClosureType.
 */
export const ChannelCloseSummary_ClosureTypeSchema: GenEnum<ChannelCloseSummary_ClosureType> = /*@__PURE__*/
  enumDesc(file_lightning, 47, 0);

/**
 * @generated from message lnrpc.Resolution
 */
export type Resolution = Message<"lnrpc.Resolution"> & {
  /**
   * The type of output we are resolving.
   *
   * @generated from field: lnrpc.ResolutionType resolution_type = 1;
   */
  resolutionType: ResolutionType;

  /**
   * The outcome of our on chain action that resolved the outpoint.
   *
   * @generated from field: lnrpc.ResolutionOutcome outcome = 2;
   */
  outcome: ResolutionOutcome;

  /**
   * The outpoint that was spent by the resolution.
   *
   * @generated from field: lnrpc.OutPoint outpoint = 3;
   */
  outpoint?: OutPoint;

  /**
   * The amount that was claimed by the resolution.
   *
   * @generated from field: uint64 amount_sat = 4;
   */
  amountSat: bigint;

  /**
   * The hex-encoded transaction ID of the sweep transaction that spent the
   * output.
   *
   * @generated from field: string sweep_txid = 5;
   */
  sweepTxid: string;
};

/**
 * Describes the message lnrpc.Resolution.
 * Use `create(ResolutionSchema)` to create a new message.
 */
export const ResolutionSchema: GenMessage<Resolution> = /*@__PURE__*/
  messageDesc(file_lightning, 48);

/**
 * @generated from message lnrpc.ClosedChannelsRequest
 */
export type ClosedChannelsRequest = Message<"lnrpc.ClosedChannelsRequest"> & {
  /**
   * @generated from field: bool cooperative = 1;
   */
  cooperative: boolean;

  /**
   * @generated from field: bool local_force = 2;
   */
  localForce: boolean;

  /**
   * @generated from field: bool remote_force = 3;
   */
  remoteForce: boolean;

  /**
   * @generated from field: bool breach = 4;
   */
  breach: boolean;

  /**
   * @generated from field: bool funding_canceled = 5;
   */
  fundingCanceled: boolean;

  /**
   * @generated from field: bool abandoned = 6;
   */
  abandoned: boolean;
};

/**
 * Describes the message lnrpc.ClosedChannelsRequest.
 * Use `create(ClosedChannelsRequestSchema)` to create a new message.
 */
export const ClosedChannelsRequestSchema: GenMessage<ClosedChannelsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 49);

/**
 * @generated from message lnrpc.ClosedChannelsResponse
 */
export type ClosedChannelsResponse = Message<"lnrpc.ClosedChannelsResponse"> & {
  /**
   * @generated from field: repeated lnrpc.ChannelCloseSummary channels = 1;
   */
  channels: ChannelCloseSummary[];
};

/**
 * Describes the message lnrpc.ClosedChannelsResponse.
 * Use `create(ClosedChannelsResponseSchema)` to create a new message.
 */
export const ClosedChannelsResponseSchema: GenMessage<ClosedChannelsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 50);

/**
 * @generated from message lnrpc.Peer
 */
export type Peer = Message<"lnrpc.Peer"> & {
  /**
   * The identity pubkey of the peer
   *
   * @generated from field: string pub_key = 1;
   */
  pubKey: string;

  /**
   * Network address of the peer; eg `127.0.0.1:10011`
   *
   * @generated from field: string address = 3;
   */
  address: string;

  /**
   * Bytes of data transmitted to this peer
   *
   * @generated from field: uint64 bytes_sent = 4;
   */
  bytesSent: bigint;

  /**
   * Bytes of data transmitted from this peer
   *
   * @generated from field: uint64 bytes_recv = 5;
   */
  bytesRecv: bigint;

  /**
   * Satoshis sent to this peer
   *
   * @generated from field: int64 sat_sent = 6;
   */
  satSent: bigint;

  /**
   * Satoshis received from this peer
   *
   * @generated from field: int64 sat_recv = 7;
   */
  satRecv: bigint;

  /**
   * A channel is inbound if the counterparty initiated the channel
   *
   * @generated from field: bool inbound = 8;
   */
  inbound: boolean;

  /**
   * Ping time to this peer
   *
   * @generated from field: int64 ping_time = 9;
   */
  pingTime: bigint;

  /**
   * The type of sync we are currently performing with this peer.
   *
   * @generated from field: lnrpc.Peer.SyncType sync_type = 10;
   */
  syncType: Peer_SyncType;

  /**
   * Features advertised by the remote peer in their init message.
   *
   * @generated from field: map<uint32, lnrpc.Feature> features = 11;
   */
  features: { [key: number]: Feature };

  /**
   * 
   * The latest errors received from our peer with timestamps, limited to the 10
   * most recent errors. These errors are tracked across peer connections, but
   * are not persisted across lnd restarts. Note that these errors are only
   * stored for peers that we have channels open with, to prevent peers from
   * spamming us with errors at no cost.
   *
   * @generated from field: repeated lnrpc.TimestampedError errors = 12;
   */
  errors: TimestampedError[];

  /**
   * 
   * The number of times we have recorded this peer going offline or coming
   * online, recorded across restarts. Note that this value is decreased over
   * time if the peer has not recently flapped, so that we can forgive peers
   * with historically high flap counts.
   *
   * @generated from field: int32 flap_count = 13;
   */
  flapCount: number;

  /**
   * 
   * The timestamp of the last flap we observed for this peer. If this value is
   * zero, we have not observed any flaps for this peer.
   *
   * @generated from field: int64 last_flap_ns = 14;
   */
  lastFlapNs: bigint;

  /**
   * 
   * The last ping payload the peer has sent to us.
   *
   * @generated from field: bytes last_ping_payload = 15;
   */
  lastPingPayload: Uint8Array;
};

/**
 * Describes the message lnrpc.Peer.
 * Use `create(PeerSchema)` to create a new message.
 */
export const PeerSchema: GenMessage<Peer> = /*@__PURE__*/
  messageDesc(file_lightning, 51);

/**
 * @generated from enum lnrpc.Peer.SyncType
 */
export enum Peer_SyncType {
  /**
   * 
   * Denotes that we cannot determine the peer's current sync type.
   *
   * @generated from enum value: UNKNOWN_SYNC = 0;
   */
  UNKNOWN_SYNC = 0,

  /**
   * 
   * Denotes that we are actively receiving new graph updates from the peer.
   *
   * @generated from enum value: ACTIVE_SYNC = 1;
   */
  ACTIVE_SYNC = 1,

  /**
   * 
   * Denotes that we are not receiving new graph updates from the peer.
   *
   * @generated from enum value: PASSIVE_SYNC = 2;
   */
  PASSIVE_SYNC = 2,

  /**
   * 
   * Denotes that this peer is pinned into an active sync.
   *
   * @generated from enum value: PINNED_SYNC = 3;
   */
  PINNED_SYNC = 3,
}

/**
 * Describes the enum lnrpc.Peer.SyncType.
 */
export const Peer_SyncTypeSchema: GenEnum<Peer_SyncType> = /*@__PURE__*/
  enumDesc(file_lightning, 51, 0);

/**
 * @generated from message lnrpc.TimestampedError
 */
export type TimestampedError = Message<"lnrpc.TimestampedError"> & {
  /**
   * The unix timestamp in seconds when the error occurred.
   *
   * @generated from field: uint64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * The string representation of the error sent by our peer.
   *
   * @generated from field: string error = 2;
   */
  error: string;
};

/**
 * Describes the message lnrpc.TimestampedError.
 * Use `create(TimestampedErrorSchema)` to create a new message.
 */
export const TimestampedErrorSchema: GenMessage<TimestampedError> = /*@__PURE__*/
  messageDesc(file_lightning, 52);

/**
 * @generated from message lnrpc.ListPeersRequest
 */
export type ListPeersRequest = Message<"lnrpc.ListPeersRequest"> & {
  /**
   * 
   * If true, only the last error that our peer sent us will be returned with
   * the peer's information, rather than the full set of historic errors we have
   * stored.
   *
   * @generated from field: bool latest_error = 1;
   */
  latestError: boolean;
};

/**
 * Describes the message lnrpc.ListPeersRequest.
 * Use `create(ListPeersRequestSchema)` to create a new message.
 */
export const ListPeersRequestSchema: GenMessage<ListPeersRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 53);

/**
 * @generated from message lnrpc.ListPeersResponse
 */
export type ListPeersResponse = Message<"lnrpc.ListPeersResponse"> & {
  /**
   * The list of currently connected peers
   *
   * @generated from field: repeated lnrpc.Peer peers = 1;
   */
  peers: Peer[];
};

/**
 * Describes the message lnrpc.ListPeersResponse.
 * Use `create(ListPeersResponseSchema)` to create a new message.
 */
export const ListPeersResponseSchema: GenMessage<ListPeersResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 54);

/**
 * @generated from message lnrpc.PeerEventSubscription
 */
export type PeerEventSubscription = Message<"lnrpc.PeerEventSubscription"> & {
};

/**
 * Describes the message lnrpc.PeerEventSubscription.
 * Use `create(PeerEventSubscriptionSchema)` to create a new message.
 */
export const PeerEventSubscriptionSchema: GenMessage<PeerEventSubscription> = /*@__PURE__*/
  messageDesc(file_lightning, 55);

/**
 * @generated from message lnrpc.PeerEvent
 */
export type PeerEvent = Message<"lnrpc.PeerEvent"> & {
  /**
   * The identity pubkey of the peer.
   *
   * @generated from field: string pub_key = 1;
   */
  pubKey: string;

  /**
   * @generated from field: lnrpc.PeerEvent.EventType type = 2;
   */
  type: PeerEvent_EventType;
};

/**
 * Describes the message lnrpc.PeerEvent.
 * Use `create(PeerEventSchema)` to create a new message.
 */
export const PeerEventSchema: GenMessage<PeerEvent> = /*@__PURE__*/
  messageDesc(file_lightning, 56);

/**
 * @generated from enum lnrpc.PeerEvent.EventType
 */
export enum PeerEvent_EventType {
  /**
   * @generated from enum value: PEER_ONLINE = 0;
   */
  PEER_ONLINE = 0,

  /**
   * @generated from enum value: PEER_OFFLINE = 1;
   */
  PEER_OFFLINE = 1,
}

/**
 * Describes the enum lnrpc.PeerEvent.EventType.
 */
export const PeerEvent_EventTypeSchema: GenEnum<PeerEvent_EventType> = /*@__PURE__*/
  enumDesc(file_lightning, 56, 0);

/**
 * @generated from message lnrpc.GetInfoRequest
 */
export type GetInfoRequest = Message<"lnrpc.GetInfoRequest"> & {
};

/**
 * Describes the message lnrpc.GetInfoRequest.
 * Use `create(GetInfoRequestSchema)` to create a new message.
 */
export const GetInfoRequestSchema: GenMessage<GetInfoRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 57);

/**
 * @generated from message lnrpc.GetInfoResponse
 */
export type GetInfoResponse = Message<"lnrpc.GetInfoResponse"> & {
  /**
   * The version of the LND software that the node is running.
   *
   * @generated from field: string version = 14;
   */
  version: string;

  /**
   * The SHA1 commit hash that the daemon is compiled with.
   *
   * @generated from field: string commit_hash = 20;
   */
  commitHash: string;

  /**
   * The identity pubkey of the current node.
   *
   * @generated from field: string identity_pubkey = 1;
   */
  identityPubkey: string;

  /**
   * If applicable, the alias of the current node, e.g. "bob"
   *
   * @generated from field: string alias = 2;
   */
  alias: string;

  /**
   * The color of the current node in hex code format
   *
   * @generated from field: string color = 17;
   */
  color: string;

  /**
   * Number of pending channels
   *
   * @generated from field: uint32 num_pending_channels = 3;
   */
  numPendingChannels: number;

  /**
   * Number of active channels
   *
   * @generated from field: uint32 num_active_channels = 4;
   */
  numActiveChannels: number;

  /**
   * Number of inactive channels
   *
   * @generated from field: uint32 num_inactive_channels = 15;
   */
  numInactiveChannels: number;

  /**
   * Number of peers
   *
   * @generated from field: uint32 num_peers = 5;
   */
  numPeers: number;

  /**
   * The node's current view of the height of the best block
   *
   * @generated from field: uint32 block_height = 6;
   */
  blockHeight: number;

  /**
   * The node's current view of the hash of the best block
   *
   * @generated from field: string block_hash = 8;
   */
  blockHash: string;

  /**
   * Timestamp of the block best known to the wallet
   *
   * @generated from field: int64 best_header_timestamp = 13;
   */
  bestHeaderTimestamp: bigint;

  /**
   * Whether the wallet's view is synced to the main chain
   *
   * @generated from field: bool synced_to_chain = 9;
   */
  syncedToChain: boolean;

  /**
   * Whether we consider ourselves synced with the public channel graph.
   *
   * @generated from field: bool synced_to_graph = 18;
   */
  syncedToGraph: boolean;

  /**
   * 
   * Whether the current node is connected to testnet. This field is
   * deprecated and the network field should be used instead
   *
   * @generated from field: bool testnet = 10 [deprecated = true];
   * @deprecated
   */
  testnet: boolean;

  /**
   * A list of active chains the node is connected to
   *
   * @generated from field: repeated lnrpc.Chain chains = 16;
   */
  chains: Chain[];

  /**
   * The URIs of the current node.
   *
   * @generated from field: repeated string uris = 12;
   */
  uris: string[];

  /**
   * 
   * Features that our node has advertised in our init message, node
   * announcements and invoices.
   *
   * @generated from field: map<uint32, lnrpc.Feature> features = 19;
   */
  features: { [key: number]: Feature };

  /**
   * 
   * Indicates whether the HTLC interceptor API is in always-on mode.
   *
   * @generated from field: bool require_htlc_interceptor = 21;
   */
  requireHtlcInterceptor: boolean;

  /**
   * Indicates whether final htlc resolutions are stored on disk.
   *
   * @generated from field: bool store_final_htlc_resolutions = 22;
   */
  storeFinalHtlcResolutions: boolean;
};

/**
 * Describes the message lnrpc.GetInfoResponse.
 * Use `create(GetInfoResponseSchema)` to create a new message.
 */
export const GetInfoResponseSchema: GenMessage<GetInfoResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 58);

/**
 * @generated from message lnrpc.GetRecoveryInfoRequest
 */
export type GetRecoveryInfoRequest = Message<"lnrpc.GetRecoveryInfoRequest"> & {
};

/**
 * Describes the message lnrpc.GetRecoveryInfoRequest.
 * Use `create(GetRecoveryInfoRequestSchema)` to create a new message.
 */
export const GetRecoveryInfoRequestSchema: GenMessage<GetRecoveryInfoRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 59);

/**
 * @generated from message lnrpc.GetRecoveryInfoResponse
 */
export type GetRecoveryInfoResponse = Message<"lnrpc.GetRecoveryInfoResponse"> & {
  /**
   * Whether the wallet is in recovery mode
   *
   * @generated from field: bool recovery_mode = 1;
   */
  recoveryMode: boolean;

  /**
   * Whether the wallet recovery progress is finished
   *
   * @generated from field: bool recovery_finished = 2;
   */
  recoveryFinished: boolean;

  /**
   * The recovery progress, ranging from 0 to 1.
   *
   * @generated from field: double progress = 3;
   */
  progress: number;
};

/**
 * Describes the message lnrpc.GetRecoveryInfoResponse.
 * Use `create(GetRecoveryInfoResponseSchema)` to create a new message.
 */
export const GetRecoveryInfoResponseSchema: GenMessage<GetRecoveryInfoResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 60);

/**
 * @generated from message lnrpc.Chain
 */
export type Chain = Message<"lnrpc.Chain"> & {
  /**
   * The blockchain the node is on (eg bitcoin, litecoin)
   *
   * @generated from field: string chain = 1;
   */
  chain: string;

  /**
   * The network the node is on (eg regtest, testnet, mainnet)
   *
   * @generated from field: string network = 2;
   */
  network: string;
};

/**
 * Describes the message lnrpc.Chain.
 * Use `create(ChainSchema)` to create a new message.
 */
export const ChainSchema: GenMessage<Chain> = /*@__PURE__*/
  messageDesc(file_lightning, 61);

/**
 * @generated from message lnrpc.ConfirmationUpdate
 */
export type ConfirmationUpdate = Message<"lnrpc.ConfirmationUpdate"> & {
  /**
   * @generated from field: bytes block_sha = 1;
   */
  blockSha: Uint8Array;

  /**
   * @generated from field: int32 block_height = 2;
   */
  blockHeight: number;

  /**
   * @generated from field: uint32 num_confs_left = 3;
   */
  numConfsLeft: number;
};

/**
 * Describes the message lnrpc.ConfirmationUpdate.
 * Use `create(ConfirmationUpdateSchema)` to create a new message.
 */
export const ConfirmationUpdateSchema: GenMessage<ConfirmationUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 62);

/**
 * @generated from message lnrpc.ChannelOpenUpdate
 */
export type ChannelOpenUpdate = Message<"lnrpc.ChannelOpenUpdate"> & {
  /**
   * @generated from field: lnrpc.ChannelPoint channel_point = 1;
   */
  channelPoint?: ChannelPoint;
};

/**
 * Describes the message lnrpc.ChannelOpenUpdate.
 * Use `create(ChannelOpenUpdateSchema)` to create a new message.
 */
export const ChannelOpenUpdateSchema: GenMessage<ChannelOpenUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 63);

/**
 * @generated from message lnrpc.ChannelCloseUpdate
 */
export type ChannelCloseUpdate = Message<"lnrpc.ChannelCloseUpdate"> & {
  /**
   * @generated from field: bytes closing_txid = 1;
   */
  closingTxid: Uint8Array;

  /**
   * @generated from field: bool success = 2;
   */
  success: boolean;
};

/**
 * Describes the message lnrpc.ChannelCloseUpdate.
 * Use `create(ChannelCloseUpdateSchema)` to create a new message.
 */
export const ChannelCloseUpdateSchema: GenMessage<ChannelCloseUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 64);

/**
 * @generated from message lnrpc.CloseChannelRequest
 */
export type CloseChannelRequest = Message<"lnrpc.CloseChannelRequest"> & {
  /**
   * 
   * The outpoint (txid:index) of the funding transaction. With this value, Bob
   * will be able to generate a signature for Alice's version of the commitment
   * transaction.
   *
   * @generated from field: lnrpc.ChannelPoint channel_point = 1;
   */
  channelPoint?: ChannelPoint;

  /**
   * If true, then the channel will be closed forcibly. This means the
   * current commitment transaction will be signed and broadcast.
   *
   * @generated from field: bool force = 2;
   */
  force: boolean;

  /**
   * The target number of blocks that the closure transaction should be
   * confirmed by.
   *
   * @generated from field: int32 target_conf = 3;
   */
  targetConf: number;

  /**
   * Deprecated, use sat_per_vbyte.
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * closure transaction.
   *
   * @generated from field: int64 sat_per_byte = 4 [deprecated = true];
   * @deprecated
   */
  satPerByte: bigint;

  /**
   * 
   * An optional address to send funds to in the case of a cooperative close.
   * If the channel was opened with an upfront shutdown script and this field
   * is set, the request to close will fail because the channel must pay out
   * to the upfront shutdown addresss.
   *
   * @generated from field: string delivery_address = 5;
   */
  deliveryAddress: string;

  /**
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * closure transaction.
   *
   * @generated from field: uint64 sat_per_vbyte = 6;
   */
  satPerVbyte: bigint;

  /**
   * The maximum fee rate the closer is willing to pay.
   * 
   * NOTE: This field is only respected if we're the initiator of the channel.
   *
   * @generated from field: uint64 max_fee_per_vbyte = 7;
   */
  maxFeePerVbyte: bigint;
};

/**
 * Describes the message lnrpc.CloseChannelRequest.
 * Use `create(CloseChannelRequestSchema)` to create a new message.
 */
export const CloseChannelRequestSchema: GenMessage<CloseChannelRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 65);

/**
 * @generated from message lnrpc.CloseStatusUpdate
 */
export type CloseStatusUpdate = Message<"lnrpc.CloseStatusUpdate"> & {
  /**
   * @generated from oneof lnrpc.CloseStatusUpdate.update
   */
  update: {
    /**
     * @generated from field: lnrpc.PendingUpdate close_pending = 1;
     */
    value: PendingUpdate;
    case: "closePending";
  } | {
    /**
     * @generated from field: lnrpc.ChannelCloseUpdate chan_close = 3;
     */
    value: ChannelCloseUpdate;
    case: "chanClose";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.CloseStatusUpdate.
 * Use `create(CloseStatusUpdateSchema)` to create a new message.
 */
export const CloseStatusUpdateSchema: GenMessage<CloseStatusUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 66);

/**
 * @generated from message lnrpc.PendingUpdate
 */
export type PendingUpdate = Message<"lnrpc.PendingUpdate"> & {
  /**
   * @generated from field: bytes txid = 1;
   */
  txid: Uint8Array;

  /**
   * @generated from field: uint32 output_index = 2;
   */
  outputIndex: number;
};

/**
 * Describes the message lnrpc.PendingUpdate.
 * Use `create(PendingUpdateSchema)` to create a new message.
 */
export const PendingUpdateSchema: GenMessage<PendingUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 67);

/**
 * @generated from message lnrpc.ReadyForPsbtFunding
 */
export type ReadyForPsbtFunding = Message<"lnrpc.ReadyForPsbtFunding"> & {
  /**
   * 
   * The P2WSH address of the channel funding multisig address that the below
   * specified amount in satoshis needs to be sent to.
   *
   * @generated from field: string funding_address = 1;
   */
  fundingAddress: string;

  /**
   * 
   * The exact amount in satoshis that needs to be sent to the above address to
   * fund the pending channel.
   *
   * @generated from field: int64 funding_amount = 2;
   */
  fundingAmount: bigint;

  /**
   * 
   * A raw PSBT that contains the pending channel output. If a base PSBT was
   * provided in the PsbtShim, this is the base PSBT with one additional output.
   * If no base PSBT was specified, this is an otherwise empty PSBT with exactly
   * one output.
   *
   * @generated from field: bytes psbt = 3;
   */
  psbt: Uint8Array;
};

/**
 * Describes the message lnrpc.ReadyForPsbtFunding.
 * Use `create(ReadyForPsbtFundingSchema)` to create a new message.
 */
export const ReadyForPsbtFundingSchema: GenMessage<ReadyForPsbtFunding> = /*@__PURE__*/
  messageDesc(file_lightning, 68);

/**
 * @generated from message lnrpc.BatchOpenChannelRequest
 */
export type BatchOpenChannelRequest = Message<"lnrpc.BatchOpenChannelRequest"> & {
  /**
   * The list of channels to open.
   *
   * @generated from field: repeated lnrpc.BatchOpenChannel channels = 1;
   */
  channels: BatchOpenChannel[];

  /**
   * The target number of blocks that the funding transaction should be
   * confirmed by.
   *
   * @generated from field: int32 target_conf = 2;
   */
  targetConf: number;

  /**
   * A manual fee rate set in sat/vByte that should be used when crafting the
   * funding transaction.
   *
   * @generated from field: int64 sat_per_vbyte = 3;
   */
  satPerVbyte: bigint;

  /**
   * The minimum number of confirmations each one of your outputs used for
   * the funding transaction must satisfy.
   *
   * @generated from field: int32 min_confs = 4;
   */
  minConfs: number;

  /**
   * Whether unconfirmed outputs should be used as inputs for the funding
   * transaction.
   *
   * @generated from field: bool spend_unconfirmed = 5;
   */
  spendUnconfirmed: boolean;

  /**
   * An optional label for the batch transaction, limited to 500 characters.
   *
   * @generated from field: string label = 6;
   */
  label: string;
};

/**
 * Describes the message lnrpc.BatchOpenChannelRequest.
 * Use `create(BatchOpenChannelRequestSchema)` to create a new message.
 */
export const BatchOpenChannelRequestSchema: GenMessage<BatchOpenChannelRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 69);

/**
 * @generated from message lnrpc.BatchOpenChannel
 */
export type BatchOpenChannel = Message<"lnrpc.BatchOpenChannel"> & {
  /**
   * The pubkey of the node to open a channel with. When using REST, this
   * field must be encoded as base64.
   *
   * @generated from field: bytes node_pubkey = 1;
   */
  nodePubkey: Uint8Array;

  /**
   * The number of satoshis the wallet should commit to the channel.
   *
   * @generated from field: int64 local_funding_amount = 2;
   */
  localFundingAmount: bigint;

  /**
   * The number of satoshis to push to the remote side as part of the initial
   * commitment state.
   *
   * @generated from field: int64 push_sat = 3;
   */
  pushSat: bigint;

  /**
   * Whether this channel should be private, not announced to the greater
   * network.
   *
   * @generated from field: bool private = 4;
   */
  private: boolean;

  /**
   * The minimum value in millisatoshi we will require for incoming HTLCs on
   * the channel.
   *
   * @generated from field: int64 min_htlc_msat = 5;
   */
  minHtlcMsat: bigint;

  /**
   * The delay we require on the remote's commitment transaction. If this is
   * not set, it will be scaled automatically with the channel size.
   *
   * @generated from field: uint32 remote_csv_delay = 6;
   */
  remoteCsvDelay: number;

  /**
   * 
   * Close address is an optional address which specifies the address to which
   * funds should be paid out to upon cooperative close. This field may only be
   * set if the peer supports the option upfront feature bit (call listpeers
   * to check). The remote peer will only accept cooperative closes to this
   * address if it is set.
   * 
   * Note: If this value is set on channel creation, you will *not* be able to
   * cooperatively close out to a different address.
   *
   * @generated from field: string close_address = 7;
   */
  closeAddress: string;

  /**
   * 
   * An optional, unique identifier of 32 random bytes that will be used as the
   * pending channel ID to identify the channel while it is in the pre-pending
   * state.
   *
   * @generated from field: bytes pending_chan_id = 8;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * The explicit commitment type to use. Note this field will only be used if
   * the remote peer supports explicit channel negotiation.
   *
   * @generated from field: lnrpc.CommitmentType commitment_type = 9;
   */
  commitmentType: CommitmentType;

  /**
   * 
   * The maximum amount of coins in millisatoshi that can be pending within
   * the channel. It only applies to the remote party.
   *
   * @generated from field: uint64 remote_max_value_in_flight_msat = 10;
   */
  remoteMaxValueInFlightMsat: bigint;

  /**
   * 
   * The maximum number of concurrent HTLCs we will allow the remote party to add
   * to the commitment transaction.
   *
   * @generated from field: uint32 remote_max_htlcs = 11;
   */
  remoteMaxHtlcs: number;

  /**
   * 
   * Max local csv is the maximum csv delay we will allow for our own commitment
   * transaction.
   *
   * @generated from field: uint32 max_local_csv = 12;
   */
  maxLocalCsv: number;

  /**
   * 
   * If this is true, then a zero-conf channel open will be attempted.
   *
   * @generated from field: bool zero_conf = 13;
   */
  zeroConf: boolean;

  /**
   * 
   * If this is true, then an option-scid-alias channel-type open will be
   * attempted.
   *
   * @generated from field: bool scid_alias = 14;
   */
  scidAlias: boolean;

  /**
   * 
   * The base fee charged regardless of the number of milli-satoshis sent.
   *
   * @generated from field: uint64 base_fee = 15;
   */
  baseFee: bigint;

  /**
   * 
   * The fee rate in ppm (parts per million) that will be charged in
   * proportion of the value of each forwarded HTLC.
   *
   * @generated from field: uint64 fee_rate = 16;
   */
  feeRate: bigint;

  /**
   * 
   * If use_base_fee is true the open channel announcement will update the
   * channel base fee with the value specified in base_fee. In the case of
   * a base_fee of 0 use_base_fee is needed downstream to distinguish whether
   * to use the default base fee value specified in the config or 0.
   *
   * @generated from field: bool use_base_fee = 17;
   */
  useBaseFee: boolean;

  /**
   * 
   * If use_fee_rate is true the open channel announcement will update the
   * channel fee rate with the value specified in fee_rate. In the case of
   * a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
   * to use the default fee rate value specified in the config or 0.
   *
   * @generated from field: bool use_fee_rate = 18;
   */
  useFeeRate: boolean;

  /**
   * 
   * The number of satoshis we require the remote peer to reserve. This value,
   * if specified, must be above the dust limit and below 20% of the channel
   * capacity.
   *
   * @generated from field: uint64 remote_chan_reserve_sat = 19;
   */
  remoteChanReserveSat: bigint;

  /**
   * 
   * An optional note-to-self to go along with the channel containing some
   * useful information. This is only ever stored locally and in no way impacts
   * the channel's operation.
   *
   * @generated from field: string memo = 20;
   */
  memo: string;
};

/**
 * Describes the message lnrpc.BatchOpenChannel.
 * Use `create(BatchOpenChannelSchema)` to create a new message.
 */
export const BatchOpenChannelSchema: GenMessage<BatchOpenChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 70);

/**
 * @generated from message lnrpc.BatchOpenChannelResponse
 */
export type BatchOpenChannelResponse = Message<"lnrpc.BatchOpenChannelResponse"> & {
  /**
   * @generated from field: repeated lnrpc.PendingUpdate pending_channels = 1;
   */
  pendingChannels: PendingUpdate[];
};

/**
 * Describes the message lnrpc.BatchOpenChannelResponse.
 * Use `create(BatchOpenChannelResponseSchema)` to create a new message.
 */
export const BatchOpenChannelResponseSchema: GenMessage<BatchOpenChannelResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 71);

/**
 * @generated from message lnrpc.OpenChannelRequest
 */
export type OpenChannelRequest = Message<"lnrpc.OpenChannelRequest"> & {
  /**
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * funding transaction.
   *
   * @generated from field: uint64 sat_per_vbyte = 1;
   */
  satPerVbyte: bigint;

  /**
   * 
   * The pubkey of the node to open a channel with. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes node_pubkey = 2;
   */
  nodePubkey: Uint8Array;

  /**
   * 
   * The hex encoded pubkey of the node to open a channel with. Deprecated now
   * that the REST gateway supports base64 encoding of bytes fields.
   *
   * @generated from field: string node_pubkey_string = 3 [deprecated = true];
   * @deprecated
   */
  nodePubkeyString: string;

  /**
   * The number of satoshis the wallet should commit to the channel
   *
   * @generated from field: int64 local_funding_amount = 4;
   */
  localFundingAmount: bigint;

  /**
   * The number of satoshis to push to the remote side as part of the initial
   * commitment state
   *
   * @generated from field: int64 push_sat = 5;
   */
  pushSat: bigint;

  /**
   * The target number of blocks that the funding transaction should be
   * confirmed by.
   *
   * @generated from field: int32 target_conf = 6;
   */
  targetConf: number;

  /**
   * Deprecated, use sat_per_vbyte.
   * A manual fee rate set in sat/vbyte that should be used when crafting the
   * funding transaction.
   *
   * @generated from field: int64 sat_per_byte = 7 [deprecated = true];
   * @deprecated
   */
  satPerByte: bigint;

  /**
   * Whether this channel should be private, not announced to the greater
   * network.
   *
   * @generated from field: bool private = 8;
   */
  private: boolean;

  /**
   * The minimum value in millisatoshi we will require for incoming HTLCs on
   * the channel.
   *
   * @generated from field: int64 min_htlc_msat = 9;
   */
  minHtlcMsat: bigint;

  /**
   * The delay we require on the remote's commitment transaction. If this is
   * not set, it will be scaled automatically with the channel size.
   *
   * @generated from field: uint32 remote_csv_delay = 10;
   */
  remoteCsvDelay: number;

  /**
   * The minimum number of confirmations each one of your outputs used for
   * the funding transaction must satisfy.
   *
   * @generated from field: int32 min_confs = 11;
   */
  minConfs: number;

  /**
   * Whether unconfirmed outputs should be used as inputs for the funding
   * transaction.
   *
   * @generated from field: bool spend_unconfirmed = 12;
   */
  spendUnconfirmed: boolean;

  /**
   * 
   * Close address is an optional address which specifies the address to which
   * funds should be paid out to upon cooperative close. This field may only be
   * set if the peer supports the option upfront feature bit (call listpeers
   * to check). The remote peer will only accept cooperative closes to this
   * address if it is set.
   * 
   * Note: If this value is set on channel creation, you will *not* be able to
   * cooperatively close out to a different address.
   *
   * @generated from field: string close_address = 13;
   */
  closeAddress: string;

  /**
   * 
   * Funding shims are an optional argument that allow the caller to intercept
   * certain funding functionality. For example, a shim can be provided to use a
   * particular key for the commitment key (ideally cold) rather than use one
   * that is generated by the wallet as normal, or signal that signing will be
   * carried out in an interactive manner (PSBT based).
   *
   * @generated from field: lnrpc.FundingShim funding_shim = 14;
   */
  fundingShim?: FundingShim;

  /**
   * 
   * The maximum amount of coins in millisatoshi that can be pending within
   * the channel. It only applies to the remote party.
   *
   * @generated from field: uint64 remote_max_value_in_flight_msat = 15;
   */
  remoteMaxValueInFlightMsat: bigint;

  /**
   * 
   * The maximum number of concurrent HTLCs we will allow the remote party to add
   * to the commitment transaction.
   *
   * @generated from field: uint32 remote_max_htlcs = 16;
   */
  remoteMaxHtlcs: number;

  /**
   * 
   * Max local csv is the maximum csv delay we will allow for our own commitment
   * transaction.
   *
   * @generated from field: uint32 max_local_csv = 17;
   */
  maxLocalCsv: number;

  /**
   * 
   * The explicit commitment type to use. Note this field will only be used if
   * the remote peer supports explicit channel negotiation.
   *
   * @generated from field: lnrpc.CommitmentType commitment_type = 18;
   */
  commitmentType: CommitmentType;

  /**
   * 
   * If this is true, then a zero-conf channel open will be attempted.
   *
   * @generated from field: bool zero_conf = 19;
   */
  zeroConf: boolean;

  /**
   * 
   * If this is true, then an option-scid-alias channel-type open will be
   * attempted.
   *
   * @generated from field: bool scid_alias = 20;
   */
  scidAlias: boolean;

  /**
   * 
   * The base fee charged regardless of the number of milli-satoshis sent.
   *
   * @generated from field: uint64 base_fee = 21;
   */
  baseFee: bigint;

  /**
   * 
   * The fee rate in ppm (parts per million) that will be charged in
   * proportion of the value of each forwarded HTLC.
   *
   * @generated from field: uint64 fee_rate = 22;
   */
  feeRate: bigint;

  /**
   * 
   * If use_base_fee is true the open channel announcement will update the
   * channel base fee with the value specified in base_fee. In the case of
   * a base_fee of 0 use_base_fee is needed downstream to distinguish whether
   * to use the default base fee value specified in the config or 0.
   *
   * @generated from field: bool use_base_fee = 23;
   */
  useBaseFee: boolean;

  /**
   * 
   * If use_fee_rate is true the open channel announcement will update the
   * channel fee rate with the value specified in fee_rate. In the case of
   * a fee_rate of 0 use_fee_rate is needed downstream to distinguish whether
   * to use the default fee rate value specified in the config or 0.
   *
   * @generated from field: bool use_fee_rate = 24;
   */
  useFeeRate: boolean;

  /**
   * 
   * The number of satoshis we require the remote peer to reserve. This value,
   * if specified, must be above the dust limit and below 20% of the channel
   * capacity.
   *
   * @generated from field: uint64 remote_chan_reserve_sat = 25;
   */
  remoteChanReserveSat: bigint;

  /**
   * 
   * If set, then lnd will attempt to commit all the coins under control of the
   * internal wallet to open the channel, and the LocalFundingAmount field must
   * be zero and is ignored.
   *
   * @generated from field: bool fund_max = 26;
   */
  fundMax: boolean;

  /**
   * 
   * An optional note-to-self to go along with the channel containing some
   * useful information. This is only ever stored locally and in no way impacts
   * the channel's operation.
   *
   * @generated from field: string memo = 27;
   */
  memo: string;

  /**
   * 
   * A list of selected outpoints that are allocated for channel funding.
   *
   * @generated from field: repeated lnrpc.OutPoint outpoints = 28;
   */
  outpoints: OutPoint[];
};

/**
 * Describes the message lnrpc.OpenChannelRequest.
 * Use `create(OpenChannelRequestSchema)` to create a new message.
 */
export const OpenChannelRequestSchema: GenMessage<OpenChannelRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 72);

/**
 * @generated from message lnrpc.OpenStatusUpdate
 */
export type OpenStatusUpdate = Message<"lnrpc.OpenStatusUpdate"> & {
  /**
   * @generated from oneof lnrpc.OpenStatusUpdate.update
   */
  update: {
    /**
     * 
     * Signals that the channel is now fully negotiated and the funding
     * transaction published.
     *
     * @generated from field: lnrpc.PendingUpdate chan_pending = 1;
     */
    value: PendingUpdate;
    case: "chanPending";
  } | {
    /**
     * 
     * Signals that the channel's funding transaction has now reached the
     * required number of confirmations on chain and can be used.
     *
     * @generated from field: lnrpc.ChannelOpenUpdate chan_open = 3;
     */
    value: ChannelOpenUpdate;
    case: "chanOpen";
  } | {
    /**
     * 
     * Signals that the funding process has been suspended and the construction
     * of a PSBT that funds the channel PK script is now required.
     *
     * @generated from field: lnrpc.ReadyForPsbtFunding psbt_fund = 5;
     */
    value: ReadyForPsbtFunding;
    case: "psbtFund";
  } | { case: undefined; value?: undefined };

  /**
   * 
   * The pending channel ID of the created channel. This value may be used to
   * further the funding flow manually via the FundingStateStep method.
   *
   * @generated from field: bytes pending_chan_id = 4;
   */
  pendingChanId: Uint8Array;
};

/**
 * Describes the message lnrpc.OpenStatusUpdate.
 * Use `create(OpenStatusUpdateSchema)` to create a new message.
 */
export const OpenStatusUpdateSchema: GenMessage<OpenStatusUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 73);

/**
 * @generated from message lnrpc.KeyLocator
 */
export type KeyLocator = Message<"lnrpc.KeyLocator"> & {
  /**
   * The family of key being identified.
   *
   * @generated from field: int32 key_family = 1;
   */
  keyFamily: number;

  /**
   * The precise index of the key being identified.
   *
   * @generated from field: int32 key_index = 2;
   */
  keyIndex: number;
};

/**
 * Describes the message lnrpc.KeyLocator.
 * Use `create(KeyLocatorSchema)` to create a new message.
 */
export const KeyLocatorSchema: GenMessage<KeyLocator> = /*@__PURE__*/
  messageDesc(file_lightning, 74);

/**
 * @generated from message lnrpc.KeyDescriptor
 */
export type KeyDescriptor = Message<"lnrpc.KeyDescriptor"> & {
  /**
   * 
   * The raw bytes of the key being identified.
   *
   * @generated from field: bytes raw_key_bytes = 1;
   */
  rawKeyBytes: Uint8Array;

  /**
   * 
   * The key locator that identifies which key to use for signing.
   *
   * @generated from field: lnrpc.KeyLocator key_loc = 2;
   */
  keyLoc?: KeyLocator;
};

/**
 * Describes the message lnrpc.KeyDescriptor.
 * Use `create(KeyDescriptorSchema)` to create a new message.
 */
export const KeyDescriptorSchema: GenMessage<KeyDescriptor> = /*@__PURE__*/
  messageDesc(file_lightning, 75);

/**
 * @generated from message lnrpc.ChanPointShim
 */
export type ChanPointShim = Message<"lnrpc.ChanPointShim"> & {
  /**
   * 
   * The size of the pre-crafted output to be used as the channel point for this
   * channel funding.
   *
   * @generated from field: int64 amt = 1;
   */
  amt: bigint;

  /**
   * The target channel point to refrence in created commitment transactions.
   *
   * @generated from field: lnrpc.ChannelPoint chan_point = 2;
   */
  chanPoint?: ChannelPoint;

  /**
   * Our local key to use when creating the multi-sig output.
   *
   * @generated from field: lnrpc.KeyDescriptor local_key = 3;
   */
  localKey?: KeyDescriptor;

  /**
   * The key of the remote party to use when creating the multi-sig output.
   *
   * @generated from field: bytes remote_key = 4;
   */
  remoteKey: Uint8Array;

  /**
   * 
   * If non-zero, then this will be used as the pending channel ID on the wire
   * protocol to initate the funding request. This is an optional field, and
   * should only be set if the responder is already expecting a specific pending
   * channel ID.
   *
   * @generated from field: bytes pending_chan_id = 5;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * This uint32 indicates if this channel is to be considered 'frozen'. A frozen
   * channel does not allow a cooperative channel close by the initiator. The
   * thaw_height is the height that this restriction stops applying to the
   * channel. The height can be interpreted in two ways: as a relative height if
   * the value is less than 500,000, or as an absolute height otherwise.
   *
   * @generated from field: uint32 thaw_height = 6;
   */
  thawHeight: number;

  /**
   * 
   * Indicates that the funding output is using a MuSig2 multi-sig output.
   *
   * @generated from field: bool musig2 = 7;
   */
  musig2: boolean;
};

/**
 * Describes the message lnrpc.ChanPointShim.
 * Use `create(ChanPointShimSchema)` to create a new message.
 */
export const ChanPointShimSchema: GenMessage<ChanPointShim> = /*@__PURE__*/
  messageDesc(file_lightning, 76);

/**
 * @generated from message lnrpc.PsbtShim
 */
export type PsbtShim = Message<"lnrpc.PsbtShim"> & {
  /**
   * 
   * A unique identifier of 32 random bytes that will be used as the pending
   * channel ID to identify the PSBT state machine when interacting with it and
   * on the wire protocol to initiate the funding request.
   *
   * @generated from field: bytes pending_chan_id = 1;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * An optional base PSBT the new channel output will be added to. If this is
   * non-empty, it must be a binary serialized PSBT.
   *
   * @generated from field: bytes base_psbt = 2;
   */
  basePsbt: Uint8Array;

  /**
   * 
   * If a channel should be part of a batch (multiple channel openings in one
   * transaction), it can be dangerous if the whole batch transaction is
   * published too early before all channel opening negotiations are completed.
   * This flag prevents this particular channel from broadcasting the transaction
   * after the negotiation with the remote peer. In a batch of channel openings
   * this flag should be set to true for every channel but the very last.
   *
   * @generated from field: bool no_publish = 3;
   */
  noPublish: boolean;
};

/**
 * Describes the message lnrpc.PsbtShim.
 * Use `create(PsbtShimSchema)` to create a new message.
 */
export const PsbtShimSchema: GenMessage<PsbtShim> = /*@__PURE__*/
  messageDesc(file_lightning, 77);

/**
 * @generated from message lnrpc.FundingShim
 */
export type FundingShim = Message<"lnrpc.FundingShim"> & {
  /**
   * @generated from oneof lnrpc.FundingShim.shim
   */
  shim: {
    /**
     * 
     * A channel shim where the channel point was fully constructed outside
     * of lnd's wallet and the transaction might already be published.
     *
     * @generated from field: lnrpc.ChanPointShim chan_point_shim = 1;
     */
    value: ChanPointShim;
    case: "chanPointShim";
  } | {
    /**
     * 
     * A channel shim that uses a PSBT to fund and sign the channel funding
     * transaction.
     *
     * @generated from field: lnrpc.PsbtShim psbt_shim = 2;
     */
    value: PsbtShim;
    case: "psbtShim";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.FundingShim.
 * Use `create(FundingShimSchema)` to create a new message.
 */
export const FundingShimSchema: GenMessage<FundingShim> = /*@__PURE__*/
  messageDesc(file_lightning, 78);

/**
 * @generated from message lnrpc.FundingShimCancel
 */
export type FundingShimCancel = Message<"lnrpc.FundingShimCancel"> & {
  /**
   * The pending channel ID of the channel to cancel the funding shim for.
   *
   * @generated from field: bytes pending_chan_id = 1;
   */
  pendingChanId: Uint8Array;
};

/**
 * Describes the message lnrpc.FundingShimCancel.
 * Use `create(FundingShimCancelSchema)` to create a new message.
 */
export const FundingShimCancelSchema: GenMessage<FundingShimCancel> = /*@__PURE__*/
  messageDesc(file_lightning, 79);

/**
 * @generated from message lnrpc.FundingPsbtVerify
 */
export type FundingPsbtVerify = Message<"lnrpc.FundingPsbtVerify"> & {
  /**
   * 
   * The funded but not yet signed PSBT that sends the exact channel capacity
   * amount to the PK script returned in the open channel message in a previous
   * step.
   *
   * @generated from field: bytes funded_psbt = 1;
   */
  fundedPsbt: Uint8Array;

  /**
   * The pending channel ID of the channel to get the PSBT for.
   *
   * @generated from field: bytes pending_chan_id = 2;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * Can only be used if the no_publish flag was set to true in the OpenChannel
   * call meaning that the caller is solely responsible for publishing the final
   * funding transaction. If skip_finalize is set to true then lnd will not wait
   * for a FundingPsbtFinalize state step and instead assumes that a transaction
   * with the same TXID as the passed in PSBT will eventually confirm.
   * IT IS ABSOLUTELY IMPERATIVE that the TXID of the transaction that is
   * eventually published does have the _same TXID_ as the verified PSBT. That
   * means no inputs or outputs can change, only signatures can be added. If the
   * TXID changes between this call and the publish step then the channel will
   * never be created and the funds will be in limbo.
   *
   * @generated from field: bool skip_finalize = 3;
   */
  skipFinalize: boolean;
};

/**
 * Describes the message lnrpc.FundingPsbtVerify.
 * Use `create(FundingPsbtVerifySchema)` to create a new message.
 */
export const FundingPsbtVerifySchema: GenMessage<FundingPsbtVerify> = /*@__PURE__*/
  messageDesc(file_lightning, 80);

/**
 * @generated from message lnrpc.FundingPsbtFinalize
 */
export type FundingPsbtFinalize = Message<"lnrpc.FundingPsbtFinalize"> & {
  /**
   * 
   * The funded PSBT that contains all witness data to send the exact channel
   * capacity amount to the PK script returned in the open channel message in a
   * previous step. Cannot be set at the same time as final_raw_tx.
   *
   * @generated from field: bytes signed_psbt = 1;
   */
  signedPsbt: Uint8Array;

  /**
   * The pending channel ID of the channel to get the PSBT for.
   *
   * @generated from field: bytes pending_chan_id = 2;
   */
  pendingChanId: Uint8Array;

  /**
   * 
   * As an alternative to the signed PSBT with all witness data, the final raw
   * wire format transaction can also be specified directly. Cannot be set at the
   * same time as signed_psbt.
   *
   * @generated from field: bytes final_raw_tx = 3;
   */
  finalRawTx: Uint8Array;
};

/**
 * Describes the message lnrpc.FundingPsbtFinalize.
 * Use `create(FundingPsbtFinalizeSchema)` to create a new message.
 */
export const FundingPsbtFinalizeSchema: GenMessage<FundingPsbtFinalize> = /*@__PURE__*/
  messageDesc(file_lightning, 81);

/**
 * @generated from message lnrpc.FundingTransitionMsg
 */
export type FundingTransitionMsg = Message<"lnrpc.FundingTransitionMsg"> & {
  /**
   * @generated from oneof lnrpc.FundingTransitionMsg.trigger
   */
  trigger: {
    /**
     * 
     * The funding shim to register. This should be used before any
     * channel funding has began by the remote party, as it is intended as a
     * preparatory step for the full channel funding.
     *
     * @generated from field: lnrpc.FundingShim shim_register = 1;
     */
    value: FundingShim;
    case: "shimRegister";
  } | {
    /**
     * Used to cancel an existing registered funding shim.
     *
     * @generated from field: lnrpc.FundingShimCancel shim_cancel = 2;
     */
    value: FundingShimCancel;
    case: "shimCancel";
  } | {
    /**
     * 
     * Used to continue a funding flow that was initiated to be executed
     * through a PSBT. This step verifies that the PSBT contains the correct
     * outputs to fund the channel.
     *
     * @generated from field: lnrpc.FundingPsbtVerify psbt_verify = 3;
     */
    value: FundingPsbtVerify;
    case: "psbtVerify";
  } | {
    /**
     * 
     * Used to continue a funding flow that was initiated to be executed
     * through a PSBT. This step finalizes the funded and signed PSBT, finishes
     * negotiation with the peer and finally publishes the resulting funding
     * transaction.
     *
     * @generated from field: lnrpc.FundingPsbtFinalize psbt_finalize = 4;
     */
    value: FundingPsbtFinalize;
    case: "psbtFinalize";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.FundingTransitionMsg.
 * Use `create(FundingTransitionMsgSchema)` to create a new message.
 */
export const FundingTransitionMsgSchema: GenMessage<FundingTransitionMsg> = /*@__PURE__*/
  messageDesc(file_lightning, 82);

/**
 * @generated from message lnrpc.FundingStateStepResp
 */
export type FundingStateStepResp = Message<"lnrpc.FundingStateStepResp"> & {
};

/**
 * Describes the message lnrpc.FundingStateStepResp.
 * Use `create(FundingStateStepRespSchema)` to create a new message.
 */
export const FundingStateStepRespSchema: GenMessage<FundingStateStepResp> = /*@__PURE__*/
  messageDesc(file_lightning, 83);

/**
 * @generated from message lnrpc.PendingHTLC
 */
export type PendingHTLC = Message<"lnrpc.PendingHTLC"> & {
  /**
   * The direction within the channel that the htlc was sent
   *
   * @generated from field: bool incoming = 1;
   */
  incoming: boolean;

  /**
   * The total value of the htlc
   *
   * @generated from field: int64 amount = 2;
   */
  amount: bigint;

  /**
   * The final output to be swept back to the user's wallet
   *
   * @generated from field: string outpoint = 3;
   */
  outpoint: string;

  /**
   * The next block height at which we can spend the current stage
   *
   * @generated from field: uint32 maturity_height = 4;
   */
  maturityHeight: number;

  /**
   * 
   * The number of blocks remaining until the current stage can be swept.
   * Negative values indicate how many blocks have passed since becoming
   * mature.
   *
   * @generated from field: int32 blocks_til_maturity = 5;
   */
  blocksTilMaturity: number;

  /**
   * Indicates whether the htlc is in its first or second stage of recovery
   *
   * @generated from field: uint32 stage = 6;
   */
  stage: number;
};

/**
 * Describes the message lnrpc.PendingHTLC.
 * Use `create(PendingHTLCSchema)` to create a new message.
 */
export const PendingHTLCSchema: GenMessage<PendingHTLC> = /*@__PURE__*/
  messageDesc(file_lightning, 84);

/**
 * @generated from message lnrpc.PendingChannelsRequest
 */
export type PendingChannelsRequest = Message<"lnrpc.PendingChannelsRequest"> & {
};

/**
 * Describes the message lnrpc.PendingChannelsRequest.
 * Use `create(PendingChannelsRequestSchema)` to create a new message.
 */
export const PendingChannelsRequestSchema: GenMessage<PendingChannelsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 85);

/**
 * @generated from message lnrpc.PendingChannelsResponse
 */
export type PendingChannelsResponse = Message<"lnrpc.PendingChannelsResponse"> & {
  /**
   * The balance in satoshis encumbered in pending channels
   *
   * @generated from field: int64 total_limbo_balance = 1;
   */
  totalLimboBalance: bigint;

  /**
   * Channels pending opening
   *
   * @generated from field: repeated lnrpc.PendingChannelsResponse.PendingOpenChannel pending_open_channels = 2;
   */
  pendingOpenChannels: PendingChannelsResponse_PendingOpenChannel[];

  /**
   * 
   * Deprecated: Channels pending closing previously contained cooperatively
   * closed channels with a single confirmation. These channels are now
   * considered closed from the time we see them on chain.
   *
   * @generated from field: repeated lnrpc.PendingChannelsResponse.ClosedChannel pending_closing_channels = 3 [deprecated = true];
   * @deprecated
   */
  pendingClosingChannels: PendingChannelsResponse_ClosedChannel[];

  /**
   * Channels pending force closing
   *
   * @generated from field: repeated lnrpc.PendingChannelsResponse.ForceClosedChannel pending_force_closing_channels = 4;
   */
  pendingForceClosingChannels: PendingChannelsResponse_ForceClosedChannel[];

  /**
   * Channels waiting for closing tx to confirm
   *
   * @generated from field: repeated lnrpc.PendingChannelsResponse.WaitingCloseChannel waiting_close_channels = 5;
   */
  waitingCloseChannels: PendingChannelsResponse_WaitingCloseChannel[];
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.
 * Use `create(PendingChannelsResponseSchema)` to create a new message.
 */
export const PendingChannelsResponseSchema: GenMessage<PendingChannelsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 86);

/**
 * @generated from message lnrpc.PendingChannelsResponse.PendingChannel
 */
export type PendingChannelsResponse_PendingChannel = Message<"lnrpc.PendingChannelsResponse.PendingChannel"> & {
  /**
   * @generated from field: string remote_node_pub = 1;
   */
  remoteNodePub: string;

  /**
   * @generated from field: string channel_point = 2;
   */
  channelPoint: string;

  /**
   * @generated from field: int64 capacity = 3;
   */
  capacity: bigint;

  /**
   * @generated from field: int64 local_balance = 4;
   */
  localBalance: bigint;

  /**
   * @generated from field: int64 remote_balance = 5;
   */
  remoteBalance: bigint;

  /**
   * The minimum satoshis this node is required to reserve in its
   * balance.
   *
   * @generated from field: int64 local_chan_reserve_sat = 6;
   */
  localChanReserveSat: bigint;

  /**
   * 
   * The minimum satoshis the other node is required to reserve in its
   * balance.
   *
   * @generated from field: int64 remote_chan_reserve_sat = 7;
   */
  remoteChanReserveSat: bigint;

  /**
   * The party that initiated opening the channel.
   *
   * @generated from field: lnrpc.Initiator initiator = 8;
   */
  initiator: Initiator;

  /**
   * The commitment type used by this channel.
   *
   * @generated from field: lnrpc.CommitmentType commitment_type = 9;
   */
  commitmentType: CommitmentType;

  /**
   * Total number of forwarding packages created in this channel.
   *
   * @generated from field: int64 num_forwarding_packages = 10;
   */
  numForwardingPackages: bigint;

  /**
   * A set of flags showing the current state of the channel.
   *
   * @generated from field: string chan_status_flags = 11;
   */
  chanStatusFlags: string;

  /**
   * Whether this channel is advertised to the network or not.
   *
   * @generated from field: bool private = 12;
   */
  private: boolean;

  /**
   * 
   * An optional note-to-self to go along with the channel containing some
   * useful information. This is only ever stored locally and in no way
   * impacts the channel's operation.
   *
   * @generated from field: string memo = 13;
   */
  memo: string;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.PendingChannel.
 * Use `create(PendingChannelsResponse_PendingChannelSchema)` to create a new message.
 */
export const PendingChannelsResponse_PendingChannelSchema: GenMessage<PendingChannelsResponse_PendingChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 0);

/**
 * @generated from message lnrpc.PendingChannelsResponse.PendingOpenChannel
 */
export type PendingChannelsResponse_PendingOpenChannel = Message<"lnrpc.PendingChannelsResponse.PendingOpenChannel"> & {
  /**
   * The pending channel
   *
   * @generated from field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
   */
  channel?: PendingChannelsResponse_PendingChannel;

  /**
   * 
   * The amount calculated to be paid in fees for the current set of
   * commitment transactions. The fee amount is persisted with the channel
   * in order to allow the fee amount to be removed and recalculated with
   * each channel state update, including updates that happen after a system
   * restart.
   *
   * @generated from field: int64 commit_fee = 4;
   */
  commitFee: bigint;

  /**
   * The weight of the commitment transaction
   *
   * @generated from field: int64 commit_weight = 5;
   */
  commitWeight: bigint;

  /**
   * 
   * The required number of satoshis per kilo-weight that the requester will
   * pay at all times, for both the funding transaction and commitment
   * transaction. This value can later be updated once the channel is open.
   *
   * @generated from field: int64 fee_per_kw = 6;
   */
  feePerKw: bigint;

  /**
   * The number of blocks until the funding transaction is considered
   * expired. If this value gets close to zero, there is a risk that the
   * channel funding will be canceled by the channel responder. The
   * channel should be fee bumped using CPFP (see walletrpc.BumpFee) to
   * ensure that the channel confirms in time. Otherwise a force-close
   * will be necessary if the channel confirms after the funding
   * transaction expires. A negative value means the channel responder has
   * very likely canceled the funding and the channel will never become
   * fully operational.
   *
   * @generated from field: int32 funding_expiry_blocks = 3;
   */
  fundingExpiryBlocks: number;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.PendingOpenChannel.
 * Use `create(PendingChannelsResponse_PendingOpenChannelSchema)` to create a new message.
 */
export const PendingChannelsResponse_PendingOpenChannelSchema: GenMessage<PendingChannelsResponse_PendingOpenChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 1);

/**
 * @generated from message lnrpc.PendingChannelsResponse.WaitingCloseChannel
 */
export type PendingChannelsResponse_WaitingCloseChannel = Message<"lnrpc.PendingChannelsResponse.WaitingCloseChannel"> & {
  /**
   * The pending channel waiting for closing tx to confirm
   *
   * @generated from field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
   */
  channel?: PendingChannelsResponse_PendingChannel;

  /**
   * The balance in satoshis encumbered in this channel
   *
   * @generated from field: int64 limbo_balance = 2;
   */
  limboBalance: bigint;

  /**
   * 
   * A list of valid commitment transactions. Any of these can confirm at
   * this point.
   *
   * @generated from field: lnrpc.PendingChannelsResponse.Commitments commitments = 3;
   */
  commitments?: PendingChannelsResponse_Commitments;

  /**
   * The transaction id of the closing transaction
   *
   * @generated from field: string closing_txid = 4;
   */
  closingTxid: string;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.WaitingCloseChannel.
 * Use `create(PendingChannelsResponse_WaitingCloseChannelSchema)` to create a new message.
 */
export const PendingChannelsResponse_WaitingCloseChannelSchema: GenMessage<PendingChannelsResponse_WaitingCloseChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 2);

/**
 * @generated from message lnrpc.PendingChannelsResponse.Commitments
 */
export type PendingChannelsResponse_Commitments = Message<"lnrpc.PendingChannelsResponse.Commitments"> & {
  /**
   * Hash of the local version of the commitment tx.
   *
   * @generated from field: string local_txid = 1;
   */
  localTxid: string;

  /**
   * Hash of the remote version of the commitment tx.
   *
   * @generated from field: string remote_txid = 2;
   */
  remoteTxid: string;

  /**
   * Hash of the remote pending version of the commitment tx.
   *
   * @generated from field: string remote_pending_txid = 3;
   */
  remotePendingTxid: string;

  /**
   * 
   * The amount in satoshis calculated to be paid in fees for the local
   * commitment.
   *
   * @generated from field: uint64 local_commit_fee_sat = 4;
   */
  localCommitFeeSat: bigint;

  /**
   * 
   * The amount in satoshis calculated to be paid in fees for the remote
   * commitment.
   *
   * @generated from field: uint64 remote_commit_fee_sat = 5;
   */
  remoteCommitFeeSat: bigint;

  /**
   * 
   * The amount in satoshis calculated to be paid in fees for the remote
   * pending commitment.
   *
   * @generated from field: uint64 remote_pending_commit_fee_sat = 6;
   */
  remotePendingCommitFeeSat: bigint;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.Commitments.
 * Use `create(PendingChannelsResponse_CommitmentsSchema)` to create a new message.
 */
export const PendingChannelsResponse_CommitmentsSchema: GenMessage<PendingChannelsResponse_Commitments> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 3);

/**
 * @generated from message lnrpc.PendingChannelsResponse.ClosedChannel
 */
export type PendingChannelsResponse_ClosedChannel = Message<"lnrpc.PendingChannelsResponse.ClosedChannel"> & {
  /**
   * The pending channel to be closed
   *
   * @generated from field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
   */
  channel?: PendingChannelsResponse_PendingChannel;

  /**
   * The transaction id of the closing transaction
   *
   * @generated from field: string closing_txid = 2;
   */
  closingTxid: string;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.ClosedChannel.
 * Use `create(PendingChannelsResponse_ClosedChannelSchema)` to create a new message.
 */
export const PendingChannelsResponse_ClosedChannelSchema: GenMessage<PendingChannelsResponse_ClosedChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 4);

/**
 * @generated from message lnrpc.PendingChannelsResponse.ForceClosedChannel
 */
export type PendingChannelsResponse_ForceClosedChannel = Message<"lnrpc.PendingChannelsResponse.ForceClosedChannel"> & {
  /**
   * The pending channel to be force closed
   *
   * @generated from field: lnrpc.PendingChannelsResponse.PendingChannel channel = 1;
   */
  channel?: PendingChannelsResponse_PendingChannel;

  /**
   * The transaction id of the closing transaction
   *
   * @generated from field: string closing_txid = 2;
   */
  closingTxid: string;

  /**
   * The balance in satoshis encumbered in this pending channel
   *
   * @generated from field: int64 limbo_balance = 3;
   */
  limboBalance: bigint;

  /**
   * The height at which funds can be swept into the wallet
   *
   * @generated from field: uint32 maturity_height = 4;
   */
  maturityHeight: number;

  /**
   * 
   * Remaining # of blocks until the commitment output can be swept.
   * Negative values indicate how many blocks have passed since becoming
   * mature.
   *
   * @generated from field: int32 blocks_til_maturity = 5;
   */
  blocksTilMaturity: number;

  /**
   * The total value of funds successfully recovered from this channel
   *
   * @generated from field: int64 recovered_balance = 6;
   */
  recoveredBalance: bigint;

  /**
   * @generated from field: repeated lnrpc.PendingHTLC pending_htlcs = 8;
   */
  pendingHtlcs: PendingHTLC[];

  /**
   * @generated from field: lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState anchor = 9;
   */
  anchor: PendingChannelsResponse_ForceClosedChannel_AnchorState;
};

/**
 * Describes the message lnrpc.PendingChannelsResponse.ForceClosedChannel.
 * Use `create(PendingChannelsResponse_ForceClosedChannelSchema)` to create a new message.
 */
export const PendingChannelsResponse_ForceClosedChannelSchema: GenMessage<PendingChannelsResponse_ForceClosedChannel> = /*@__PURE__*/
  messageDesc(file_lightning, 86, 5);

/**
 * 
 * There are three resolution states for the anchor:
 * limbo, lost and recovered. Derive the current state
 * from the limbo and recovered balances.
 *
 * @generated from enum lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState
 */
export enum PendingChannelsResponse_ForceClosedChannel_AnchorState {
  /**
   * The recovered_balance is zero and limbo_balance is non-zero.
   *
   * @generated from enum value: LIMBO = 0;
   */
  LIMBO = 0,

  /**
   * The recovered_balance is non-zero.
   *
   * @generated from enum value: RECOVERED = 1;
   */
  RECOVERED = 1,

  /**
   * A state that is neither LIMBO nor RECOVERED.
   *
   * @generated from enum value: LOST = 2;
   */
  LOST = 2,
}

/**
 * Describes the enum lnrpc.PendingChannelsResponse.ForceClosedChannel.AnchorState.
 */
export const PendingChannelsResponse_ForceClosedChannel_AnchorStateSchema: GenEnum<PendingChannelsResponse_ForceClosedChannel_AnchorState> = /*@__PURE__*/
  enumDesc(file_lightning, 86, 5, 0);

/**
 * @generated from message lnrpc.ChannelEventSubscription
 */
export type ChannelEventSubscription = Message<"lnrpc.ChannelEventSubscription"> & {
};

/**
 * Describes the message lnrpc.ChannelEventSubscription.
 * Use `create(ChannelEventSubscriptionSchema)` to create a new message.
 */
export const ChannelEventSubscriptionSchema: GenMessage<ChannelEventSubscription> = /*@__PURE__*/
  messageDesc(file_lightning, 87);

/**
 * @generated from message lnrpc.ChannelEventUpdate
 */
export type ChannelEventUpdate = Message<"lnrpc.ChannelEventUpdate"> & {
  /**
   * @generated from oneof lnrpc.ChannelEventUpdate.channel
   */
  channel: {
    /**
     * @generated from field: lnrpc.Channel open_channel = 1;
     */
    value: Channel;
    case: "openChannel";
  } | {
    /**
     * @generated from field: lnrpc.ChannelCloseSummary closed_channel = 2;
     */
    value: ChannelCloseSummary;
    case: "closedChannel";
  } | {
    /**
     * @generated from field: lnrpc.ChannelPoint active_channel = 3;
     */
    value: ChannelPoint;
    case: "activeChannel";
  } | {
    /**
     * @generated from field: lnrpc.ChannelPoint inactive_channel = 4;
     */
    value: ChannelPoint;
    case: "inactiveChannel";
  } | {
    /**
     * @generated from field: lnrpc.PendingUpdate pending_open_channel = 6;
     */
    value: PendingUpdate;
    case: "pendingOpenChannel";
  } | {
    /**
     * @generated from field: lnrpc.ChannelPoint fully_resolved_channel = 7;
     */
    value: ChannelPoint;
    case: "fullyResolvedChannel";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: lnrpc.ChannelEventUpdate.UpdateType type = 5;
   */
  type: ChannelEventUpdate_UpdateType;
};

/**
 * Describes the message lnrpc.ChannelEventUpdate.
 * Use `create(ChannelEventUpdateSchema)` to create a new message.
 */
export const ChannelEventUpdateSchema: GenMessage<ChannelEventUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 88);

/**
 * @generated from enum lnrpc.ChannelEventUpdate.UpdateType
 */
export enum ChannelEventUpdate_UpdateType {
  /**
   * @generated from enum value: OPEN_CHANNEL = 0;
   */
  OPEN_CHANNEL = 0,

  /**
   * @generated from enum value: CLOSED_CHANNEL = 1;
   */
  CLOSED_CHANNEL = 1,

  /**
   * @generated from enum value: ACTIVE_CHANNEL = 2;
   */
  ACTIVE_CHANNEL = 2,

  /**
   * @generated from enum value: INACTIVE_CHANNEL = 3;
   */
  INACTIVE_CHANNEL = 3,

  /**
   * @generated from enum value: PENDING_OPEN_CHANNEL = 4;
   */
  PENDING_OPEN_CHANNEL = 4,

  /**
   * @generated from enum value: FULLY_RESOLVED_CHANNEL = 5;
   */
  FULLY_RESOLVED_CHANNEL = 5,
}

/**
 * Describes the enum lnrpc.ChannelEventUpdate.UpdateType.
 */
export const ChannelEventUpdate_UpdateTypeSchema: GenEnum<ChannelEventUpdate_UpdateType> = /*@__PURE__*/
  enumDesc(file_lightning, 88, 0);

/**
 * @generated from message lnrpc.WalletAccountBalance
 */
export type WalletAccountBalance = Message<"lnrpc.WalletAccountBalance"> & {
  /**
   * The confirmed balance of the account (with >= 1 confirmations).
   *
   * @generated from field: int64 confirmed_balance = 1;
   */
  confirmedBalance: bigint;

  /**
   * The unconfirmed balance of the account (with 0 confirmations).
   *
   * @generated from field: int64 unconfirmed_balance = 2;
   */
  unconfirmedBalance: bigint;
};

/**
 * Describes the message lnrpc.WalletAccountBalance.
 * Use `create(WalletAccountBalanceSchema)` to create a new message.
 */
export const WalletAccountBalanceSchema: GenMessage<WalletAccountBalance> = /*@__PURE__*/
  messageDesc(file_lightning, 89);

/**
 * @generated from message lnrpc.WalletBalanceRequest
 */
export type WalletBalanceRequest = Message<"lnrpc.WalletBalanceRequest"> & {
  /**
   * The wallet account the balance is shown for.
   * If this is not specified, the balance of the "default" account is shown.
   *
   * @generated from field: string account = 1;
   */
  account: string;
};

/**
 * Describes the message lnrpc.WalletBalanceRequest.
 * Use `create(WalletBalanceRequestSchema)` to create a new message.
 */
export const WalletBalanceRequestSchema: GenMessage<WalletBalanceRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 90);

/**
 * @generated from message lnrpc.WalletBalanceResponse
 */
export type WalletBalanceResponse = Message<"lnrpc.WalletBalanceResponse"> & {
  /**
   * The balance of the wallet
   *
   * @generated from field: int64 total_balance = 1;
   */
  totalBalance: bigint;

  /**
   * The confirmed balance of a wallet(with >= 1 confirmations)
   *
   * @generated from field: int64 confirmed_balance = 2;
   */
  confirmedBalance: bigint;

  /**
   * The unconfirmed balance of a wallet(with 0 confirmations)
   *
   * @generated from field: int64 unconfirmed_balance = 3;
   */
  unconfirmedBalance: bigint;

  /**
   * The total amount of wallet UTXOs held in outputs that are locked for
   * other usage.
   *
   * @generated from field: int64 locked_balance = 5;
   */
  lockedBalance: bigint;

  /**
   * The amount of reserve required.
   *
   * @generated from field: int64 reserved_balance_anchor_chan = 6;
   */
  reservedBalanceAnchorChan: bigint;

  /**
   * A mapping of each wallet account's name to its balance.
   *
   * @generated from field: map<string, lnrpc.WalletAccountBalance> account_balance = 4;
   */
  accountBalance: { [key: string]: WalletAccountBalance };
};

/**
 * Describes the message lnrpc.WalletBalanceResponse.
 * Use `create(WalletBalanceResponseSchema)` to create a new message.
 */
export const WalletBalanceResponseSchema: GenMessage<WalletBalanceResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 91);

/**
 * @generated from message lnrpc.Amount
 */
export type Amount = Message<"lnrpc.Amount"> & {
  /**
   * Value denominated in satoshis.
   *
   * @generated from field: uint64 sat = 1;
   */
  sat: bigint;

  /**
   * Value denominated in milli-satoshis.
   *
   * @generated from field: uint64 msat = 2;
   */
  msat: bigint;
};

/**
 * Describes the message lnrpc.Amount.
 * Use `create(AmountSchema)` to create a new message.
 */
export const AmountSchema: GenMessage<Amount> = /*@__PURE__*/
  messageDesc(file_lightning, 92);

/**
 * @generated from message lnrpc.ChannelBalanceRequest
 */
export type ChannelBalanceRequest = Message<"lnrpc.ChannelBalanceRequest"> & {
};

/**
 * Describes the message lnrpc.ChannelBalanceRequest.
 * Use `create(ChannelBalanceRequestSchema)` to create a new message.
 */
export const ChannelBalanceRequestSchema: GenMessage<ChannelBalanceRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 93);

/**
 * @generated from message lnrpc.ChannelBalanceResponse
 */
export type ChannelBalanceResponse = Message<"lnrpc.ChannelBalanceResponse"> & {
  /**
   * Deprecated. Sum of channels balances denominated in satoshis
   *
   * @generated from field: int64 balance = 1 [deprecated = true];
   * @deprecated
   */
  balance: bigint;

  /**
   * Deprecated. Sum of channels pending balances denominated in satoshis
   *
   * @generated from field: int64 pending_open_balance = 2 [deprecated = true];
   * @deprecated
   */
  pendingOpenBalance: bigint;

  /**
   * Sum of channels local balances.
   *
   * @generated from field: lnrpc.Amount local_balance = 3;
   */
  localBalance?: Amount;

  /**
   * Sum of channels remote balances.
   *
   * @generated from field: lnrpc.Amount remote_balance = 4;
   */
  remoteBalance?: Amount;

  /**
   * Sum of channels local unsettled balances.
   *
   * @generated from field: lnrpc.Amount unsettled_local_balance = 5;
   */
  unsettledLocalBalance?: Amount;

  /**
   * Sum of channels remote unsettled balances.
   *
   * @generated from field: lnrpc.Amount unsettled_remote_balance = 6;
   */
  unsettledRemoteBalance?: Amount;

  /**
   * Sum of channels pending local balances.
   *
   * @generated from field: lnrpc.Amount pending_open_local_balance = 7;
   */
  pendingOpenLocalBalance?: Amount;

  /**
   * Sum of channels pending remote balances.
   *
   * @generated from field: lnrpc.Amount pending_open_remote_balance = 8;
   */
  pendingOpenRemoteBalance?: Amount;
};

/**
 * Describes the message lnrpc.ChannelBalanceResponse.
 * Use `create(ChannelBalanceResponseSchema)` to create a new message.
 */
export const ChannelBalanceResponseSchema: GenMessage<ChannelBalanceResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 94);

/**
 * @generated from message lnrpc.QueryRoutesRequest
 */
export type QueryRoutesRequest = Message<"lnrpc.QueryRoutesRequest"> & {
  /**
   * The 33-byte hex-encoded public key for the payment destination
   *
   * @generated from field: string pub_key = 1;
   */
  pubKey: string;

  /**
   * 
   * The amount to send expressed in satoshis.
   * 
   * The fields amt and amt_msat are mutually exclusive.
   *
   * @generated from field: int64 amt = 2;
   */
  amt: bigint;

  /**
   * 
   * The amount to send expressed in millisatoshis.
   * 
   * The fields amt and amt_msat are mutually exclusive.
   *
   * @generated from field: int64 amt_msat = 12;
   */
  amtMsat: bigint;

  /**
   * 
   * An optional CLTV delta from the current height that should be used for the
   * timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
   * not add any additional block padding on top of final_ctlv_delta. This
   * padding of a few blocks needs to be added manually or otherwise failures may
   * happen when a block comes in while the payment is in flight.
   *
   * @generated from field: int32 final_cltv_delta = 4;
   */
  finalCltvDelta: number;

  /**
   * 
   * The maximum number of satoshis that will be paid as a fee of the payment.
   * This value can be represented either as a percentage of the amount being
   * sent, or as a fixed amount of the maximum fee the user is willing the pay to
   * send the payment. If not specified, lnd will use a default value of 100%
   * fees for small amounts (<=1k sat) or 5% fees for larger amounts.
   *
   * @generated from field: lnrpc.FeeLimit fee_limit = 5;
   */
  feeLimit?: FeeLimit;

  /**
   * 
   * A list of nodes to ignore during path finding. When using REST, these fields
   * must be encoded as base64.
   *
   * @generated from field: repeated bytes ignored_nodes = 6;
   */
  ignoredNodes: Uint8Array[];

  /**
   * 
   * Deprecated. A list of edges to ignore during path finding.
   *
   * @generated from field: repeated lnrpc.EdgeLocator ignored_edges = 7 [deprecated = true];
   * @deprecated
   */
  ignoredEdges: EdgeLocator[];

  /**
   * 
   * The source node where the request route should originated from. If empty,
   * self is assumed.
   *
   * @generated from field: string source_pub_key = 8;
   */
  sourcePubKey: string;

  /**
   * 
   * If set to true, edge probabilities from mission control will be used to get
   * the optimal route.
   *
   * @generated from field: bool use_mission_control = 9;
   */
  useMissionControl: boolean;

  /**
   * 
   * A list of directed node pairs that will be ignored during path finding.
   *
   * @generated from field: repeated lnrpc.NodePair ignored_pairs = 10;
   */
  ignoredPairs: NodePair[];

  /**
   * 
   * An optional maximum total time lock for the route. If the source is empty or
   * ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
   * zero, then the value of `--max-cltv-expiry` is used as the limit.
   *
   * @generated from field: uint32 cltv_limit = 11;
   */
  cltvLimit: number;

  /**
   * 
   * An optional field that can be used to pass an arbitrary set of TLV records
   * to a peer which understands the new records. This can be used to pass
   * application specific data during the payment attempt. If the destination
   * does not support the specified records, an error will be returned.
   * Record types are required to be in the custom range >= 65536. When using
   * REST, the values must be encoded as base64.
   *
   * @generated from field: map<uint64, bytes> dest_custom_records = 13;
   */
  destCustomRecords: { [key: string]: Uint8Array };

  /**
   * 
   * The channel id of the channel that must be taken to the first hop. If zero,
   * any channel may be used.
   *
   * @generated from field: uint64 outgoing_chan_id = 14 [jstype = JS_STRING];
   */
  outgoingChanId: string;

  /**
   * 
   * The pubkey of the last hop of the route. If empty, any hop may be used.
   *
   * @generated from field: bytes last_hop_pubkey = 15;
   */
  lastHopPubkey: Uint8Array;

  /**
   * 
   * Optional route hints to reach the destination through private channels.
   *
   * @generated from field: repeated lnrpc.RouteHint route_hints = 16;
   */
  routeHints: RouteHint[];

  /**
   * 
   * Features assumed to be supported by the final node. All transitive feature
   * dependencies must also be set properly. For a given feature bit pair, either
   * optional or remote may be set, but not both. If this field is nil or empty,
   * the router will try to load destination features from the graph as a
   * fallback.
   *
   * @generated from field: repeated lnrpc.FeatureBit dest_features = 17;
   */
  destFeatures: FeatureBit[];

  /**
   * 
   * The time preference for this payment. Set to -1 to optimize for fees
   * only, to 1 to optimize for reliability only or a value inbetween for a mix.
   *
   * @generated from field: double time_pref = 18;
   */
  timePref: number;
};

/**
 * Describes the message lnrpc.QueryRoutesRequest.
 * Use `create(QueryRoutesRequestSchema)` to create a new message.
 */
export const QueryRoutesRequestSchema: GenMessage<QueryRoutesRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 95);

/**
 * @generated from message lnrpc.NodePair
 */
export type NodePair = Message<"lnrpc.NodePair"> & {
  /**
   * 
   * The sending node of the pair. When using REST, this field must be encoded as
   * base64.
   *
   * @generated from field: bytes from = 1;
   */
  from: Uint8Array;

  /**
   * 
   * The receiving node of the pair. When using REST, this field must be encoded
   * as base64.
   *
   * @generated from field: bytes to = 2;
   */
  to: Uint8Array;
};

/**
 * Describes the message lnrpc.NodePair.
 * Use `create(NodePairSchema)` to create a new message.
 */
export const NodePairSchema: GenMessage<NodePair> = /*@__PURE__*/
  messageDesc(file_lightning, 96);

/**
 * @generated from message lnrpc.EdgeLocator
 */
export type EdgeLocator = Message<"lnrpc.EdgeLocator"> & {
  /**
   * The short channel id of this edge.
   *
   * @generated from field: uint64 channel_id = 1 [jstype = JS_STRING];
   */
  channelId: string;

  /**
   * 
   * The direction of this edge. If direction_reverse is false, the direction
   * of this edge is from the channel endpoint with the lexicographically smaller
   * pub key to the endpoint with the larger pub key. If direction_reverse is
   * is true, the edge goes the other way.
   *
   * @generated from field: bool direction_reverse = 2;
   */
  directionReverse: boolean;
};

/**
 * Describes the message lnrpc.EdgeLocator.
 * Use `create(EdgeLocatorSchema)` to create a new message.
 */
export const EdgeLocatorSchema: GenMessage<EdgeLocator> = /*@__PURE__*/
  messageDesc(file_lightning, 97);

/**
 * @generated from message lnrpc.QueryRoutesResponse
 */
export type QueryRoutesResponse = Message<"lnrpc.QueryRoutesResponse"> & {
  /**
   * 
   * The route that results from the path finding operation. This is still a
   * repeated field to retain backwards compatibility.
   *
   * @generated from field: repeated lnrpc.Route routes = 1;
   */
  routes: Route[];

  /**
   * 
   * The success probability of the returned route based on the current mission
   * control state. [EXPERIMENTAL]
   *
   * @generated from field: double success_prob = 2;
   */
  successProb: number;
};

/**
 * Describes the message lnrpc.QueryRoutesResponse.
 * Use `create(QueryRoutesResponseSchema)` to create a new message.
 */
export const QueryRoutesResponseSchema: GenMessage<QueryRoutesResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 98);

/**
 * @generated from message lnrpc.Hop
 */
export type Hop = Message<"lnrpc.Hop"> & {
  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 chan_id = 1 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * @generated from field: int64 chan_capacity = 2 [deprecated = true];
   * @deprecated
   */
  chanCapacity: bigint;

  /**
   * @generated from field: int64 amt_to_forward = 3 [deprecated = true];
   * @deprecated
   */
  amtToForward: bigint;

  /**
   * @generated from field: int64 fee = 4 [deprecated = true];
   * @deprecated
   */
  fee: bigint;

  /**
   * @generated from field: uint32 expiry = 5;
   */
  expiry: number;

  /**
   * @generated from field: int64 amt_to_forward_msat = 6;
   */
  amtToForwardMsat: bigint;

  /**
   * @generated from field: int64 fee_msat = 7;
   */
  feeMsat: bigint;

  /**
   * 
   * An optional public key of the hop. If the public key is given, the payment
   * can be executed without relying on a copy of the channel graph.
   *
   * @generated from field: string pub_key = 8;
   */
  pubKey: string;

  /**
   * 
   * If set to true, then this hop will be encoded using the new variable length
   * TLV format. Note that if any custom tlv_records below are specified, then
   * this field MUST be set to true for them to be encoded properly.
   *
   * @generated from field: bool tlv_payload = 9 [deprecated = true];
   * @deprecated
   */
  tlvPayload: boolean;

  /**
   * 
   * An optional TLV record that signals the use of an MPP payment. If present,
   * the receiver will enforce that the same mpp_record is included in the final
   * hop payload of all non-zero payments in the HTLC set. If empty, a regular
   * single-shot payment is or was attempted.
   *
   * @generated from field: lnrpc.MPPRecord mpp_record = 10;
   */
  mppRecord?: MPPRecord;

  /**
   * 
   * An optional TLV record that signals the use of an AMP payment. If present,
   * the receiver will treat all received payments including the same
   * (payment_addr, set_id) pair  as being part of one logical payment. The
   * payment will be settled by XORing the root_share's together and deriving the
   * child hashes and preimages according to BOLT XX. Must be used in conjunction
   * with mpp_record.
   *
   * @generated from field: lnrpc.AMPRecord amp_record = 12;
   */
  ampRecord?: AMPRecord;

  /**
   * 
   * An optional set of key-value TLV records. This is useful within the context
   * of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
   * to drop off at each hop within the onion.
   *
   * @generated from field: map<uint64, bytes> custom_records = 11;
   */
  customRecords: { [key: string]: Uint8Array };

  /**
   * The payment metadata to send along with the payment to the payee.
   *
   * @generated from field: bytes metadata = 13;
   */
  metadata: Uint8Array;
};

/**
 * Describes the message lnrpc.Hop.
 * Use `create(HopSchema)` to create a new message.
 */
export const HopSchema: GenMessage<Hop> = /*@__PURE__*/
  messageDesc(file_lightning, 99);

/**
 * @generated from message lnrpc.MPPRecord
 */
export type MPPRecord = Message<"lnrpc.MPPRecord"> & {
  /**
   * 
   * A unique, random identifier used to authenticate the sender as the intended
   * payer of a multi-path payment. The payment_addr must be the same for all
   * subpayments, and match the payment_addr provided in the receiver's invoice.
   * The same payment_addr must be used on all subpayments.
   *
   * @generated from field: bytes payment_addr = 11;
   */
  paymentAddr: Uint8Array;

  /**
   * 
   * The total amount in milli-satoshis being sent as part of a larger multi-path
   * payment. The caller is responsible for ensuring subpayments to the same node
   * and payment_hash sum exactly to total_amt_msat. The same
   * total_amt_msat must be used on all subpayments.
   *
   * @generated from field: int64 total_amt_msat = 10;
   */
  totalAmtMsat: bigint;
};

/**
 * Describes the message lnrpc.MPPRecord.
 * Use `create(MPPRecordSchema)` to create a new message.
 */
export const MPPRecordSchema: GenMessage<MPPRecord> = /*@__PURE__*/
  messageDesc(file_lightning, 100);

/**
 * @generated from message lnrpc.AMPRecord
 */
export type AMPRecord = Message<"lnrpc.AMPRecord"> & {
  /**
   * @generated from field: bytes root_share = 1;
   */
  rootShare: Uint8Array;

  /**
   * @generated from field: bytes set_id = 2;
   */
  setId: Uint8Array;

  /**
   * @generated from field: uint32 child_index = 3;
   */
  childIndex: number;
};

/**
 * Describes the message lnrpc.AMPRecord.
 * Use `create(AMPRecordSchema)` to create a new message.
 */
export const AMPRecordSchema: GenMessage<AMPRecord> = /*@__PURE__*/
  messageDesc(file_lightning, 101);

/**
 * 
 * A path through the channel graph which runs over one or more channels in
 * succession. This struct carries all the information required to craft the
 * Sphinx onion packet, and send the payment along the first hop in the path. A
 * route is only selected as valid if all the channels have sufficient capacity to
 * carry the initial payment amount after fees are accounted for.
 *
 * @generated from message lnrpc.Route
 */
export type Route = Message<"lnrpc.Route"> & {
  /**
   * 
   * The cumulative (final) time lock across the entire route. This is the CLTV
   * value that should be extended to the first hop in the route. All other hops
   * will decrement the time-lock as advertised, leaving enough time for all
   * hops to wait for or present the payment preimage to complete the payment.
   *
   * @generated from field: uint32 total_time_lock = 1;
   */
  totalTimeLock: number;

  /**
   * 
   * The sum of the fees paid at each hop within the final route. In the case
   * of a one-hop payment, this value will be zero as we don't need to pay a fee
   * to ourselves.
   *
   * @generated from field: int64 total_fees = 2 [deprecated = true];
   * @deprecated
   */
  totalFees: bigint;

  /**
   * 
   * The total amount of funds required to complete a payment over this route.
   * This value includes the cumulative fees at each hop. As a result, the HTLC
   * extended to the first-hop in the route will need to have at least this many
   * satoshis, otherwise the route will fail at an intermediate node due to an
   * insufficient amount of fees.
   *
   * @generated from field: int64 total_amt = 3 [deprecated = true];
   * @deprecated
   */
  totalAmt: bigint;

  /**
   * 
   * Contains details concerning the specific forwarding details at each hop.
   *
   * @generated from field: repeated lnrpc.Hop hops = 4;
   */
  hops: Hop[];

  /**
   * 
   * The total fees in millisatoshis.
   *
   * @generated from field: int64 total_fees_msat = 5;
   */
  totalFeesMsat: bigint;

  /**
   * 
   * The total amount in millisatoshis.
   *
   * @generated from field: int64 total_amt_msat = 6;
   */
  totalAmtMsat: bigint;
};

/**
 * Describes the message lnrpc.Route.
 * Use `create(RouteSchema)` to create a new message.
 */
export const RouteSchema: GenMessage<Route> = /*@__PURE__*/
  messageDesc(file_lightning, 102);

/**
 * @generated from message lnrpc.NodeInfoRequest
 */
export type NodeInfoRequest = Message<"lnrpc.NodeInfoRequest"> & {
  /**
   * The 33-byte hex-encoded compressed public of the target node
   *
   * @generated from field: string pub_key = 1;
   */
  pubKey: string;

  /**
   * If true, will include all known channels associated with the node.
   *
   * @generated from field: bool include_channels = 2;
   */
  includeChannels: boolean;
};

/**
 * Describes the message lnrpc.NodeInfoRequest.
 * Use `create(NodeInfoRequestSchema)` to create a new message.
 */
export const NodeInfoRequestSchema: GenMessage<NodeInfoRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 103);

/**
 * @generated from message lnrpc.NodeInfo
 */
export type NodeInfo = Message<"lnrpc.NodeInfo"> & {
  /**
   * 
   * An individual vertex/node within the channel graph. A node is
   * connected to other nodes by one or more channel edges emanating from it. As
   * the graph is directed, a node will also have an incoming edge attached to
   * it for each outgoing edge.
   *
   * @generated from field: lnrpc.LightningNode node = 1;
   */
  node?: LightningNode;

  /**
   * The total number of channels for the node.
   *
   * @generated from field: uint32 num_channels = 2;
   */
  numChannels: number;

  /**
   * The sum of all channels capacity for the node, denominated in satoshis.
   *
   * @generated from field: int64 total_capacity = 3;
   */
  totalCapacity: bigint;

  /**
   * A list of all public channels for the node.
   *
   * @generated from field: repeated lnrpc.ChannelEdge channels = 4;
   */
  channels: ChannelEdge[];
};

/**
 * Describes the message lnrpc.NodeInfo.
 * Use `create(NodeInfoSchema)` to create a new message.
 */
export const NodeInfoSchema: GenMessage<NodeInfo> = /*@__PURE__*/
  messageDesc(file_lightning, 104);

/**
 * 
 * An individual vertex/node within the channel graph. A node is
 * connected to other nodes by one or more channel edges emanating from it. As the
 * graph is directed, a node will also have an incoming edge attached to it for
 * each outgoing edge.
 *
 * @generated from message lnrpc.LightningNode
 */
export type LightningNode = Message<"lnrpc.LightningNode"> & {
  /**
   * @generated from field: uint32 last_update = 1;
   */
  lastUpdate: number;

  /**
   * @generated from field: string pub_key = 2;
   */
  pubKey: string;

  /**
   * @generated from field: string alias = 3;
   */
  alias: string;

  /**
   * @generated from field: repeated lnrpc.NodeAddress addresses = 4;
   */
  addresses: NodeAddress[];

  /**
   * @generated from field: string color = 5;
   */
  color: string;

  /**
   * @generated from field: map<uint32, lnrpc.Feature> features = 6;
   */
  features: { [key: number]: Feature };

  /**
   * Custom node announcement tlv records.
   *
   * @generated from field: map<uint64, bytes> custom_records = 7;
   */
  customRecords: { [key: string]: Uint8Array };
};

/**
 * Describes the message lnrpc.LightningNode.
 * Use `create(LightningNodeSchema)` to create a new message.
 */
export const LightningNodeSchema: GenMessage<LightningNode> = /*@__PURE__*/
  messageDesc(file_lightning, 105);

/**
 * @generated from message lnrpc.NodeAddress
 */
export type NodeAddress = Message<"lnrpc.NodeAddress"> & {
  /**
   * @generated from field: string network = 1;
   */
  network: string;

  /**
   * @generated from field: string addr = 2;
   */
  addr: string;
};

/**
 * Describes the message lnrpc.NodeAddress.
 * Use `create(NodeAddressSchema)` to create a new message.
 */
export const NodeAddressSchema: GenMessage<NodeAddress> = /*@__PURE__*/
  messageDesc(file_lightning, 106);

/**
 * @generated from message lnrpc.RoutingPolicy
 */
export type RoutingPolicy = Message<"lnrpc.RoutingPolicy"> & {
  /**
   * @generated from field: uint32 time_lock_delta = 1;
   */
  timeLockDelta: number;

  /**
   * @generated from field: int64 min_htlc = 2;
   */
  minHtlc: bigint;

  /**
   * @generated from field: int64 fee_base_msat = 3;
   */
  feeBaseMsat: bigint;

  /**
   * @generated from field: int64 fee_rate_milli_msat = 4;
   */
  feeRateMilliMsat: bigint;

  /**
   * @generated from field: bool disabled = 5;
   */
  disabled: boolean;

  /**
   * @generated from field: uint64 max_htlc_msat = 6;
   */
  maxHtlcMsat: bigint;

  /**
   * @generated from field: uint32 last_update = 7;
   */
  lastUpdate: number;

  /**
   * Custom channel update tlv records.
   *
   * @generated from field: map<uint64, bytes> custom_records = 8;
   */
  customRecords: { [key: string]: Uint8Array };
};

/**
 * Describes the message lnrpc.RoutingPolicy.
 * Use `create(RoutingPolicySchema)` to create a new message.
 */
export const RoutingPolicySchema: GenMessage<RoutingPolicy> = /*@__PURE__*/
  messageDesc(file_lightning, 107);

/**
 * 
 * A fully authenticated channel along with all its unique attributes.
 * Once an authenticated channel announcement has been processed on the network,
 * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
 * stored. The other portions relevant to routing policy of a channel are stored
 * within a ChannelEdgePolicy for each direction of the channel.
 *
 * @generated from message lnrpc.ChannelEdge
 */
export type ChannelEdge = Message<"lnrpc.ChannelEdge"> & {
  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 channel_id = 1 [jstype = JS_STRING];
   */
  channelId: string;

  /**
   * @generated from field: string chan_point = 2;
   */
  chanPoint: string;

  /**
   * @generated from field: uint32 last_update = 3 [deprecated = true];
   * @deprecated
   */
  lastUpdate: number;

  /**
   * @generated from field: string node1_pub = 4;
   */
  node1Pub: string;

  /**
   * @generated from field: string node2_pub = 5;
   */
  node2Pub: string;

  /**
   * @generated from field: int64 capacity = 6;
   */
  capacity: bigint;

  /**
   * @generated from field: lnrpc.RoutingPolicy node1_policy = 7;
   */
  node1Policy?: RoutingPolicy;

  /**
   * @generated from field: lnrpc.RoutingPolicy node2_policy = 8;
   */
  node2Policy?: RoutingPolicy;

  /**
   * Custom channel announcement tlv records.
   *
   * @generated from field: map<uint64, bytes> custom_records = 9;
   */
  customRecords: { [key: string]: Uint8Array };
};

/**
 * Describes the message lnrpc.ChannelEdge.
 * Use `create(ChannelEdgeSchema)` to create a new message.
 */
export const ChannelEdgeSchema: GenMessage<ChannelEdge> = /*@__PURE__*/
  messageDesc(file_lightning, 108);

/**
 * @generated from message lnrpc.ChannelGraphRequest
 */
export type ChannelGraphRequest = Message<"lnrpc.ChannelGraphRequest"> & {
  /**
   * 
   * Whether unannounced channels are included in the response or not. If set,
   * unannounced channels are included. Unannounced channels are both private
   * channels, and public channels that are not yet announced to the network.
   *
   * @generated from field: bool include_unannounced = 1;
   */
  includeUnannounced: boolean;
};

/**
 * Describes the message lnrpc.ChannelGraphRequest.
 * Use `create(ChannelGraphRequestSchema)` to create a new message.
 */
export const ChannelGraphRequestSchema: GenMessage<ChannelGraphRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 109);

/**
 * Returns a new instance of the directed channel graph.
 *
 * @generated from message lnrpc.ChannelGraph
 */
export type ChannelGraph = Message<"lnrpc.ChannelGraph"> & {
  /**
   * The list of `LightningNode`s in this channel graph
   *
   * @generated from field: repeated lnrpc.LightningNode nodes = 1;
   */
  nodes: LightningNode[];

  /**
   * The list of `ChannelEdge`s in this channel graph
   *
   * @generated from field: repeated lnrpc.ChannelEdge edges = 2;
   */
  edges: ChannelEdge[];
};

/**
 * Describes the message lnrpc.ChannelGraph.
 * Use `create(ChannelGraphSchema)` to create a new message.
 */
export const ChannelGraphSchema: GenMessage<ChannelGraph> = /*@__PURE__*/
  messageDesc(file_lightning, 110);

/**
 * @generated from message lnrpc.NodeMetricsRequest
 */
export type NodeMetricsRequest = Message<"lnrpc.NodeMetricsRequest"> & {
  /**
   * The requested node metrics.
   *
   * @generated from field: repeated lnrpc.NodeMetricType types = 1;
   */
  types: NodeMetricType[];
};

/**
 * Describes the message lnrpc.NodeMetricsRequest.
 * Use `create(NodeMetricsRequestSchema)` to create a new message.
 */
export const NodeMetricsRequestSchema: GenMessage<NodeMetricsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 111);

/**
 * @generated from message lnrpc.NodeMetricsResponse
 */
export type NodeMetricsResponse = Message<"lnrpc.NodeMetricsResponse"> & {
  /**
   * 
   * Betweenness centrality is the sum of the ratio of shortest paths that pass
   * through the node for each pair of nodes in the graph (not counting paths
   * starting or ending at this node).
   * Map of node pubkey to betweenness centrality of the node. Normalized
   * values are in the [0,1] closed interval.
   *
   * @generated from field: map<string, lnrpc.FloatMetric> betweenness_centrality = 1;
   */
  betweennessCentrality: { [key: string]: FloatMetric };
};

/**
 * Describes the message lnrpc.NodeMetricsResponse.
 * Use `create(NodeMetricsResponseSchema)` to create a new message.
 */
export const NodeMetricsResponseSchema: GenMessage<NodeMetricsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 112);

/**
 * @generated from message lnrpc.FloatMetric
 */
export type FloatMetric = Message<"lnrpc.FloatMetric"> & {
  /**
   * Arbitrary float value.
   *
   * @generated from field: double value = 1;
   */
  value: number;

  /**
   * The value normalized to [0,1] or [-1,1].
   *
   * @generated from field: double normalized_value = 2;
   */
  normalizedValue: number;
};

/**
 * Describes the message lnrpc.FloatMetric.
 * Use `create(FloatMetricSchema)` to create a new message.
 */
export const FloatMetricSchema: GenMessage<FloatMetric> = /*@__PURE__*/
  messageDesc(file_lightning, 113);

/**
 * @generated from message lnrpc.ChanInfoRequest
 */
export type ChanInfoRequest = Message<"lnrpc.ChanInfoRequest"> & {
  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 chan_id = 1 [jstype = JS_STRING];
   */
  chanId: string;
};

/**
 * Describes the message lnrpc.ChanInfoRequest.
 * Use `create(ChanInfoRequestSchema)` to create a new message.
 */
export const ChanInfoRequestSchema: GenMessage<ChanInfoRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 114);

/**
 * @generated from message lnrpc.NetworkInfoRequest
 */
export type NetworkInfoRequest = Message<"lnrpc.NetworkInfoRequest"> & {
};

/**
 * Describes the message lnrpc.NetworkInfoRequest.
 * Use `create(NetworkInfoRequestSchema)` to create a new message.
 */
export const NetworkInfoRequestSchema: GenMessage<NetworkInfoRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 115);

/**
 * @generated from message lnrpc.NetworkInfo
 */
export type NetworkInfo = Message<"lnrpc.NetworkInfo"> & {
  /**
   * @generated from field: uint32 graph_diameter = 1;
   */
  graphDiameter: number;

  /**
   * @generated from field: double avg_out_degree = 2;
   */
  avgOutDegree: number;

  /**
   * @generated from field: uint32 max_out_degree = 3;
   */
  maxOutDegree: number;

  /**
   * @generated from field: uint32 num_nodes = 4;
   */
  numNodes: number;

  /**
   * @generated from field: uint32 num_channels = 5;
   */
  numChannels: number;

  /**
   * @generated from field: int64 total_network_capacity = 6;
   */
  totalNetworkCapacity: bigint;

  /**
   * @generated from field: double avg_channel_size = 7;
   */
  avgChannelSize: number;

  /**
   * @generated from field: int64 min_channel_size = 8;
   */
  minChannelSize: bigint;

  /**
   * @generated from field: int64 max_channel_size = 9;
   */
  maxChannelSize: bigint;

  /**
   * @generated from field: int64 median_channel_size_sat = 10;
   */
  medianChannelSizeSat: bigint;

  /**
   * The number of edges marked as zombies.
   *
   * @generated from field: uint64 num_zombie_chans = 11;
   */
  numZombieChans: bigint;
};

/**
 * Describes the message lnrpc.NetworkInfo.
 * Use `create(NetworkInfoSchema)` to create a new message.
 */
export const NetworkInfoSchema: GenMessage<NetworkInfo> = /*@__PURE__*/
  messageDesc(file_lightning, 116);

/**
 * @generated from message lnrpc.StopRequest
 */
export type StopRequest = Message<"lnrpc.StopRequest"> & {
};

/**
 * Describes the message lnrpc.StopRequest.
 * Use `create(StopRequestSchema)` to create a new message.
 */
export const StopRequestSchema: GenMessage<StopRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 117);

/**
 * @generated from message lnrpc.StopResponse
 */
export type StopResponse = Message<"lnrpc.StopResponse"> & {
};

/**
 * Describes the message lnrpc.StopResponse.
 * Use `create(StopResponseSchema)` to create a new message.
 */
export const StopResponseSchema: GenMessage<StopResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 118);

/**
 * @generated from message lnrpc.GraphTopologySubscription
 */
export type GraphTopologySubscription = Message<"lnrpc.GraphTopologySubscription"> & {
};

/**
 * Describes the message lnrpc.GraphTopologySubscription.
 * Use `create(GraphTopologySubscriptionSchema)` to create a new message.
 */
export const GraphTopologySubscriptionSchema: GenMessage<GraphTopologySubscription> = /*@__PURE__*/
  messageDesc(file_lightning, 119);

/**
 * @generated from message lnrpc.GraphTopologyUpdate
 */
export type GraphTopologyUpdate = Message<"lnrpc.GraphTopologyUpdate"> & {
  /**
   * @generated from field: repeated lnrpc.NodeUpdate node_updates = 1;
   */
  nodeUpdates: NodeUpdate[];

  /**
   * @generated from field: repeated lnrpc.ChannelEdgeUpdate channel_updates = 2;
   */
  channelUpdates: ChannelEdgeUpdate[];

  /**
   * @generated from field: repeated lnrpc.ClosedChannelUpdate closed_chans = 3;
   */
  closedChans: ClosedChannelUpdate[];
};

/**
 * Describes the message lnrpc.GraphTopologyUpdate.
 * Use `create(GraphTopologyUpdateSchema)` to create a new message.
 */
export const GraphTopologyUpdateSchema: GenMessage<GraphTopologyUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 120);

/**
 * @generated from message lnrpc.NodeUpdate
 */
export type NodeUpdate = Message<"lnrpc.NodeUpdate"> & {
  /**
   * 
   * Deprecated, use node_addresses.
   *
   * @generated from field: repeated string addresses = 1 [deprecated = true];
   * @deprecated
   */
  addresses: string[];

  /**
   * @generated from field: string identity_key = 2;
   */
  identityKey: string;

  /**
   * 
   * Deprecated, use features.
   *
   * @generated from field: bytes global_features = 3 [deprecated = true];
   * @deprecated
   */
  globalFeatures: Uint8Array;

  /**
   * @generated from field: string alias = 4;
   */
  alias: string;

  /**
   * @generated from field: string color = 5;
   */
  color: string;

  /**
   * @generated from field: repeated lnrpc.NodeAddress node_addresses = 7;
   */
  nodeAddresses: NodeAddress[];

  /**
   * 
   * Features that the node has advertised in the init message, node
   * announcements and invoices.
   *
   * @generated from field: map<uint32, lnrpc.Feature> features = 6;
   */
  features: { [key: number]: Feature };
};

/**
 * Describes the message lnrpc.NodeUpdate.
 * Use `create(NodeUpdateSchema)` to create a new message.
 */
export const NodeUpdateSchema: GenMessage<NodeUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 121);

/**
 * @generated from message lnrpc.ChannelEdgeUpdate
 */
export type ChannelEdgeUpdate = Message<"lnrpc.ChannelEdgeUpdate"> & {
  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 chan_id = 1 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * @generated from field: lnrpc.ChannelPoint chan_point = 2;
   */
  chanPoint?: ChannelPoint;

  /**
   * @generated from field: int64 capacity = 3;
   */
  capacity: bigint;

  /**
   * @generated from field: lnrpc.RoutingPolicy routing_policy = 4;
   */
  routingPolicy?: RoutingPolicy;

  /**
   * @generated from field: string advertising_node = 5;
   */
  advertisingNode: string;

  /**
   * @generated from field: string connecting_node = 6;
   */
  connectingNode: string;
};

/**
 * Describes the message lnrpc.ChannelEdgeUpdate.
 * Use `create(ChannelEdgeUpdateSchema)` to create a new message.
 */
export const ChannelEdgeUpdateSchema: GenMessage<ChannelEdgeUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 122);

/**
 * @generated from message lnrpc.ClosedChannelUpdate
 */
export type ClosedChannelUpdate = Message<"lnrpc.ClosedChannelUpdate"> & {
  /**
   * 
   * The unique channel ID for the channel. The first 3 bytes are the block
   * height, the next 3 the index within the block, and the last 2 bytes are the
   * output index for the channel.
   *
   * @generated from field: uint64 chan_id = 1 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * @generated from field: int64 capacity = 2;
   */
  capacity: bigint;

  /**
   * @generated from field: uint32 closed_height = 3;
   */
  closedHeight: number;

  /**
   * @generated from field: lnrpc.ChannelPoint chan_point = 4;
   */
  chanPoint?: ChannelPoint;
};

/**
 * Describes the message lnrpc.ClosedChannelUpdate.
 * Use `create(ClosedChannelUpdateSchema)` to create a new message.
 */
export const ClosedChannelUpdateSchema: GenMessage<ClosedChannelUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 123);

/**
 * @generated from message lnrpc.HopHint
 */
export type HopHint = Message<"lnrpc.HopHint"> & {
  /**
   * The public key of the node at the start of the channel.
   *
   * @generated from field: string node_id = 1;
   */
  nodeId: string;

  /**
   * The unique identifier of the channel.
   *
   * @generated from field: uint64 chan_id = 2 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * The base fee of the channel denominated in millisatoshis.
   *
   * @generated from field: uint32 fee_base_msat = 3;
   */
  feeBaseMsat: number;

  /**
   * 
   * The fee rate of the channel for sending one satoshi across it denominated in
   * millionths of a satoshi.
   *
   * @generated from field: uint32 fee_proportional_millionths = 4;
   */
  feeProportionalMillionths: number;

  /**
   * The time-lock delta of the channel.
   *
   * @generated from field: uint32 cltv_expiry_delta = 5;
   */
  cltvExpiryDelta: number;
};

/**
 * Describes the message lnrpc.HopHint.
 * Use `create(HopHintSchema)` to create a new message.
 */
export const HopHintSchema: GenMessage<HopHint> = /*@__PURE__*/
  messageDesc(file_lightning, 124);

/**
 * @generated from message lnrpc.SetID
 */
export type SetID = Message<"lnrpc.SetID"> & {
  /**
   * @generated from field: bytes set_id = 1;
   */
  setId: Uint8Array;
};

/**
 * Describes the message lnrpc.SetID.
 * Use `create(SetIDSchema)` to create a new message.
 */
export const SetIDSchema: GenMessage<SetID> = /*@__PURE__*/
  messageDesc(file_lightning, 125);

/**
 * @generated from message lnrpc.RouteHint
 */
export type RouteHint = Message<"lnrpc.RouteHint"> & {
  /**
   * 
   * A list of hop hints that when chained together can assist in reaching a
   * specific destination.
   *
   * @generated from field: repeated lnrpc.HopHint hop_hints = 1;
   */
  hopHints: HopHint[];
};

/**
 * Describes the message lnrpc.RouteHint.
 * Use `create(RouteHintSchema)` to create a new message.
 */
export const RouteHintSchema: GenMessage<RouteHint> = /*@__PURE__*/
  messageDesc(file_lightning, 126);

/**
 * @generated from message lnrpc.AMPInvoiceState
 */
export type AMPInvoiceState = Message<"lnrpc.AMPInvoiceState"> & {
  /**
   * The state the HTLCs associated with this setID are in.
   *
   * @generated from field: lnrpc.InvoiceHTLCState state = 1;
   */
  state: InvoiceHTLCState;

  /**
   * The settle index of this HTLC set, if the invoice state is settled.
   *
   * @generated from field: uint64 settle_index = 2;
   */
  settleIndex: bigint;

  /**
   * The time this HTLC set was settled expressed in unix epoch.
   *
   * @generated from field: int64 settle_time = 3;
   */
  settleTime: bigint;

  /**
   * The total amount paid for the sub-invoice expressed in milli satoshis.
   *
   * @generated from field: int64 amt_paid_msat = 5;
   */
  amtPaidMsat: bigint;
};

/**
 * Describes the message lnrpc.AMPInvoiceState.
 * Use `create(AMPInvoiceStateSchema)` to create a new message.
 */
export const AMPInvoiceStateSchema: GenMessage<AMPInvoiceState> = /*@__PURE__*/
  messageDesc(file_lightning, 127);

/**
 * @generated from message lnrpc.Invoice
 */
export type Invoice = Message<"lnrpc.Invoice"> & {
  /**
   * 
   * An optional memo to attach along with the invoice. Used for record keeping
   * purposes for the invoice's creator, and will also be set in the description
   * field of the encoded payment request if the description_hash field is not
   * being used.
   *
   * @generated from field: string memo = 1;
   */
  memo: string;

  /**
   * 
   * The hex-encoded preimage (32 byte) which will allow settling an incoming
   * HTLC payable to this preimage. When using REST, this field must be encoded
   * as base64.
   *
   * @generated from field: bytes r_preimage = 3;
   */
  rPreimage: Uint8Array;

  /**
   * 
   * The hash of the preimage. When using REST, this field must be encoded as
   * base64.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: bytes r_hash = 4;
   */
  rHash: Uint8Array;

  /**
   * 
   * The value of this invoice in satoshis
   * 
   * The fields value and value_msat are mutually exclusive.
   *
   * @generated from field: int64 value = 5;
   */
  value: bigint;

  /**
   * 
   * The value of this invoice in millisatoshis
   * 
   * The fields value and value_msat are mutually exclusive.
   *
   * @generated from field: int64 value_msat = 23;
   */
  valueMsat: bigint;

  /**
   * 
   * Whether this invoice has been fulfilled.
   * 
   * The field is deprecated. Use the state field instead (compare to SETTLED).
   *
   * @generated from field: bool settled = 6 [deprecated = true];
   * @deprecated
   */
  settled: boolean;

  /**
   * 
   * When this invoice was created.
   * Measured in seconds since the unix epoch.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: int64 creation_date = 7;
   */
  creationDate: bigint;

  /**
   * 
   * When this invoice was settled.
   * Measured in seconds since the unix epoch.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: int64 settle_date = 8;
   */
  settleDate: bigint;

  /**
   * 
   * A bare-bones invoice for a payment within the Lightning Network. With the
   * details of the invoice, the sender has all the data necessary to send a
   * payment to the recipient.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: string payment_request = 9;
   */
  paymentRequest: string;

  /**
   * 
   * Hash (SHA-256) of a description of the payment. Used if the description of
   * payment (memo) is too long to naturally fit within the description field
   * of an encoded payment request. When using REST, this field must be encoded
   * as base64.
   *
   * @generated from field: bytes description_hash = 10;
   */
  descriptionHash: Uint8Array;

  /**
   * Payment request expiry time in seconds. Default is 86400 (24 hours).
   *
   * @generated from field: int64 expiry = 11;
   */
  expiry: bigint;

  /**
   * Fallback on-chain address.
   *
   * @generated from field: string fallback_addr = 12;
   */
  fallbackAddr: string;

  /**
   * Delta to use for the time-lock of the CLTV extended to the final hop.
   *
   * @generated from field: uint64 cltv_expiry = 13;
   */
  cltvExpiry: bigint;

  /**
   * 
   * Route hints that can each be individually used to assist in reaching the
   * invoice's destination.
   *
   * @generated from field: repeated lnrpc.RouteHint route_hints = 14;
   */
  routeHints: RouteHint[];

  /**
   * Whether this invoice should include routing hints for private channels.
   * Note: When enabled, if value and value_msat are zero, a large number of
   * hints with these channels can be included, which might not be desirable.
   *
   * @generated from field: bool private = 15;
   */
  private: boolean;

  /**
   * 
   * The "add" index of this invoice. Each newly created invoice will increment
   * this index making it monotonically increasing. Callers to the
   * SubscribeInvoices call can use this to instantly get notified of all added
   * invoices with an add_index greater than this one.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: uint64 add_index = 16;
   */
  addIndex: bigint;

  /**
   * 
   * The "settle" index of this invoice. Each newly settled invoice will
   * increment this index making it monotonically increasing. Callers to the
   * SubscribeInvoices call can use this to instantly get notified of all
   * settled invoices with an settle_index greater than this one.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: uint64 settle_index = 17;
   */
  settleIndex: bigint;

  /**
   * Deprecated, use amt_paid_sat or amt_paid_msat.
   *
   * @generated from field: int64 amt_paid = 18 [deprecated = true];
   * @deprecated
   */
  amtPaid: bigint;

  /**
   * 
   * The amount that was accepted for this invoice, in satoshis. This will ONLY
   * be set if this invoice has been settled or accepted. We provide this field
   * as if the invoice was created with a zero value, then we need to record what
   * amount was ultimately accepted. Additionally, it's possible that the sender
   * paid MORE that was specified in the original invoice. So we'll record that
   * here as well.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: int64 amt_paid_sat = 19;
   */
  amtPaidSat: bigint;

  /**
   * 
   * The amount that was accepted for this invoice, in millisatoshis. This will
   * ONLY be set if this invoice has been settled or accepted. We provide this
   * field as if the invoice was created with a zero value, then we need to
   * record what amount was ultimately accepted. Additionally, it's possible that
   * the sender paid MORE that was specified in the original invoice. So we'll
   * record that here as well.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: int64 amt_paid_msat = 20;
   */
  amtPaidMsat: bigint;

  /**
   * 
   * The state the invoice is in.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: lnrpc.Invoice.InvoiceState state = 21;
   */
  state: Invoice_InvoiceState;

  /**
   * 
   * List of HTLCs paying to this invoice [EXPERIMENTAL].
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: repeated lnrpc.InvoiceHTLC htlcs = 22;
   */
  htlcs: InvoiceHTLC[];

  /**
   * 
   * List of features advertised on the invoice.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: map<uint32, lnrpc.Feature> features = 24;
   */
  features: { [key: number]: Feature };

  /**
   * 
   * Indicates if this invoice was a spontaneous payment that arrived via keysend
   * [EXPERIMENTAL].
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: bool is_keysend = 25;
   */
  isKeysend: boolean;

  /**
   * 
   * The payment address of this invoice. This value will be used in MPP
   * payments, and also for newer invoices that always require the MPP payload
   * for added end-to-end security.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: bytes payment_addr = 26;
   */
  paymentAddr: Uint8Array;

  /**
   * 
   * Signals whether or not this is an AMP invoice.
   *
   * @generated from field: bool is_amp = 27;
   */
  isAmp: boolean;

  /**
   * 
   * [EXPERIMENTAL]:
   * 
   * Maps a 32-byte hex-encoded set ID to the sub-invoice AMP state for the
   * given set ID. This field is always populated for AMP invoices, and can be
   * used along side LookupInvoice to obtain the HTLC information related to a
   * given sub-invoice.
   * Note: Output only, don't specify for creating an invoice.
   *
   * @generated from field: map<string, lnrpc.AMPInvoiceState> amp_invoice_state = 28;
   */
  ampInvoiceState: { [key: string]: AMPInvoiceState };

  /**
   * 
   * The minimum number of hop hints to include in this invoice.
   *
   * @generated from field: int32 min_hop_hints = 29;
   */
  minHopHints: number;
};

/**
 * Describes the message lnrpc.Invoice.
 * Use `create(InvoiceSchema)` to create a new message.
 */
export const InvoiceSchema: GenMessage<Invoice> = /*@__PURE__*/
  messageDesc(file_lightning, 128);

/**
 * @generated from enum lnrpc.Invoice.InvoiceState
 */
export enum Invoice_InvoiceState {
  /**
   * @generated from enum value: OPEN = 0;
   */
  OPEN = 0,

  /**
   * @generated from enum value: SETTLED = 1;
   */
  SETTLED = 1,

  /**
   * @generated from enum value: CANCELED = 2;
   */
  CANCELED = 2,

  /**
   * @generated from enum value: ACCEPTED = 3;
   */
  ACCEPTED = 3,
}

/**
 * Describes the enum lnrpc.Invoice.InvoiceState.
 */
export const Invoice_InvoiceStateSchema: GenEnum<Invoice_InvoiceState> = /*@__PURE__*/
  enumDesc(file_lightning, 128, 0);

/**
 * Details of an HTLC that paid to an invoice
 *
 * @generated from message lnrpc.InvoiceHTLC
 */
export type InvoiceHTLC = Message<"lnrpc.InvoiceHTLC"> & {
  /**
   * Short channel id over which the htlc was received.
   *
   * @generated from field: uint64 chan_id = 1 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * Index identifying the htlc on the channel.
   *
   * @generated from field: uint64 htlc_index = 2;
   */
  htlcIndex: bigint;

  /**
   * The amount of the htlc in msat.
   *
   * @generated from field: uint64 amt_msat = 3;
   */
  amtMsat: bigint;

  /**
   * Block height at which this htlc was accepted.
   *
   * @generated from field: int32 accept_height = 4;
   */
  acceptHeight: number;

  /**
   * Time at which this htlc was accepted.
   *
   * @generated from field: int64 accept_time = 5;
   */
  acceptTime: bigint;

  /**
   * Time at which this htlc was settled or canceled.
   *
   * @generated from field: int64 resolve_time = 6;
   */
  resolveTime: bigint;

  /**
   * Block height at which this htlc expires.
   *
   * @generated from field: int32 expiry_height = 7;
   */
  expiryHeight: number;

  /**
   * Current state the htlc is in.
   *
   * @generated from field: lnrpc.InvoiceHTLCState state = 8;
   */
  state: InvoiceHTLCState;

  /**
   * Custom tlv records.
   *
   * @generated from field: map<uint64, bytes> custom_records = 9;
   */
  customRecords: { [key: string]: Uint8Array };

  /**
   * The total amount of the mpp payment in msat.
   *
   * @generated from field: uint64 mpp_total_amt_msat = 10;
   */
  mppTotalAmtMsat: bigint;

  /**
   * Details relevant to AMP HTLCs, only populated if this is an AMP HTLC.
   *
   * @generated from field: lnrpc.AMP amp = 11;
   */
  amp?: AMP;
};

/**
 * Describes the message lnrpc.InvoiceHTLC.
 * Use `create(InvoiceHTLCSchema)` to create a new message.
 */
export const InvoiceHTLCSchema: GenMessage<InvoiceHTLC> = /*@__PURE__*/
  messageDesc(file_lightning, 129);

/**
 * Details specific to AMP HTLCs.
 *
 * @generated from message lnrpc.AMP
 */
export type AMP = Message<"lnrpc.AMP"> & {
  /**
   * An n-of-n secret share of the root seed from which child payment hashes
   * and preimages are derived.
   *
   * @generated from field: bytes root_share = 1;
   */
  rootShare: Uint8Array;

  /**
   * An identifier for the HTLC set that this HTLC belongs to.
   *
   * @generated from field: bytes set_id = 2;
   */
  setId: Uint8Array;

  /**
   * A nonce used to randomize the child preimage and child hash from a given
   * root_share.
   *
   * @generated from field: uint32 child_index = 3;
   */
  childIndex: number;

  /**
   * The payment hash of the AMP HTLC.
   *
   * @generated from field: bytes hash = 4;
   */
  hash: Uint8Array;

  /**
   * The preimage used to settle this AMP htlc. This field will only be
   * populated if the invoice is in InvoiceState_ACCEPTED or
   * InvoiceState_SETTLED.
   *
   * @generated from field: bytes preimage = 5;
   */
  preimage: Uint8Array;
};

/**
 * Describes the message lnrpc.AMP.
 * Use `create(AMPSchema)` to create a new message.
 */
export const AMPSchema: GenMessage<AMP> = /*@__PURE__*/
  messageDesc(file_lightning, 130);

/**
 * @generated from message lnrpc.AddInvoiceResponse
 */
export type AddInvoiceResponse = Message<"lnrpc.AddInvoiceResponse"> & {
  /**
   * @generated from field: bytes r_hash = 1;
   */
  rHash: Uint8Array;

  /**
   * 
   * A bare-bones invoice for a payment within the Lightning Network. With the
   * details of the invoice, the sender has all the data necessary to send a
   * payment to the recipient.
   *
   * @generated from field: string payment_request = 2;
   */
  paymentRequest: string;

  /**
   * 
   * The "add" index of this invoice. Each newly created invoice will increment
   * this index making it monotonically increasing. Callers to the
   * SubscribeInvoices call can use this to instantly get notified of all added
   * invoices with an add_index greater than this one.
   *
   * @generated from field: uint64 add_index = 16;
   */
  addIndex: bigint;

  /**
   * 
   * The payment address of the generated invoice. This value should be used
   * in all payments for this invoice as we require it for end to end
   * security.
   *
   * @generated from field: bytes payment_addr = 17;
   */
  paymentAddr: Uint8Array;
};

/**
 * Describes the message lnrpc.AddInvoiceResponse.
 * Use `create(AddInvoiceResponseSchema)` to create a new message.
 */
export const AddInvoiceResponseSchema: GenMessage<AddInvoiceResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 131);

/**
 * @generated from message lnrpc.PaymentHash
 */
export type PaymentHash = Message<"lnrpc.PaymentHash"> & {
  /**
   * 
   * The hex-encoded payment hash of the invoice to be looked up. The passed
   * payment hash must be exactly 32 bytes, otherwise an error is returned.
   * Deprecated now that the REST gateway supports base64 encoding of bytes
   * fields.
   *
   * @generated from field: string r_hash_str = 1 [deprecated = true];
   * @deprecated
   */
  rHashStr: string;

  /**
   * 
   * The payment hash of the invoice to be looked up. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes r_hash = 2;
   */
  rHash: Uint8Array;
};

/**
 * Describes the message lnrpc.PaymentHash.
 * Use `create(PaymentHashSchema)` to create a new message.
 */
export const PaymentHashSchema: GenMessage<PaymentHash> = /*@__PURE__*/
  messageDesc(file_lightning, 132);

/**
 * @generated from message lnrpc.ListInvoiceRequest
 */
export type ListInvoiceRequest = Message<"lnrpc.ListInvoiceRequest"> & {
  /**
   * 
   * If set, only invoices that are not settled and not canceled will be returned
   * in the response.
   *
   * @generated from field: bool pending_only = 1;
   */
  pendingOnly: boolean;

  /**
   * 
   * The index of an invoice that will be used as either the start or end of a
   * query to determine which invoices should be returned in the response.
   *
   * @generated from field: uint64 index_offset = 4;
   */
  indexOffset: bigint;

  /**
   * The max number of invoices to return in the response to this query.
   *
   * @generated from field: uint64 num_max_invoices = 5;
   */
  numMaxInvoices: bigint;

  /**
   * 
   * If set, the invoices returned will result from seeking backwards from the
   * specified index offset. This can be used to paginate backwards.
   *
   * @generated from field: bool reversed = 6;
   */
  reversed: boolean;

  /**
   * If set, returns all invoices with a creation date greater than or equal
   * to it. Measured in seconds since the unix epoch.
   *
   * @generated from field: uint64 creation_date_start = 7;
   */
  creationDateStart: bigint;

  /**
   * If set, returns all invoices with a creation date less than or equal to
   * it. Measured in seconds since the unix epoch.
   *
   * @generated from field: uint64 creation_date_end = 8;
   */
  creationDateEnd: bigint;
};

/**
 * Describes the message lnrpc.ListInvoiceRequest.
 * Use `create(ListInvoiceRequestSchema)` to create a new message.
 */
export const ListInvoiceRequestSchema: GenMessage<ListInvoiceRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 133);

/**
 * @generated from message lnrpc.ListInvoiceResponse
 */
export type ListInvoiceResponse = Message<"lnrpc.ListInvoiceResponse"> & {
  /**
   * 
   * A list of invoices from the time slice of the time series specified in the
   * request.
   *
   * @generated from field: repeated lnrpc.Invoice invoices = 1;
   */
  invoices: Invoice[];

  /**
   * 
   * The index of the last item in the set of returned invoices. This can be used
   * to seek further, pagination style.
   *
   * @generated from field: uint64 last_index_offset = 2;
   */
  lastIndexOffset: bigint;

  /**
   * 
   * The index of the last item in the set of returned invoices. This can be used
   * to seek backwards, pagination style.
   *
   * @generated from field: uint64 first_index_offset = 3;
   */
  firstIndexOffset: bigint;
};

/**
 * Describes the message lnrpc.ListInvoiceResponse.
 * Use `create(ListInvoiceResponseSchema)` to create a new message.
 */
export const ListInvoiceResponseSchema: GenMessage<ListInvoiceResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 134);

/**
 * @generated from message lnrpc.InvoiceSubscription
 */
export type InvoiceSubscription = Message<"lnrpc.InvoiceSubscription"> & {
  /**
   * 
   * If specified (non-zero), then we'll first start by sending out
   * notifications for all added indexes with an add_index greater than this
   * value. This allows callers to catch up on any events they missed while they
   * weren't connected to the streaming RPC.
   *
   * @generated from field: uint64 add_index = 1;
   */
  addIndex: bigint;

  /**
   * 
   * If specified (non-zero), then we'll first start by sending out
   * notifications for all settled indexes with an settle_index greater than
   * this value. This allows callers to catch up on any events they missed while
   * they weren't connected to the streaming RPC.
   *
   * @generated from field: uint64 settle_index = 2;
   */
  settleIndex: bigint;
};

/**
 * Describes the message lnrpc.InvoiceSubscription.
 * Use `create(InvoiceSubscriptionSchema)` to create a new message.
 */
export const InvoiceSubscriptionSchema: GenMessage<InvoiceSubscription> = /*@__PURE__*/
  messageDesc(file_lightning, 135);

/**
 * @generated from message lnrpc.Payment
 */
export type Payment = Message<"lnrpc.Payment"> & {
  /**
   * The payment hash
   *
   * @generated from field: string payment_hash = 1;
   */
  paymentHash: string;

  /**
   * Deprecated, use value_sat or value_msat.
   *
   * @generated from field: int64 value = 2 [deprecated = true];
   * @deprecated
   */
  value: bigint;

  /**
   * Deprecated, use creation_time_ns
   *
   * @generated from field: int64 creation_date = 3 [deprecated = true];
   * @deprecated
   */
  creationDate: bigint;

  /**
   * Deprecated, use fee_sat or fee_msat.
   *
   * @generated from field: int64 fee = 5 [deprecated = true];
   * @deprecated
   */
  fee: bigint;

  /**
   * The payment preimage
   *
   * @generated from field: string payment_preimage = 6;
   */
  paymentPreimage: string;

  /**
   * The value of the payment in satoshis
   *
   * @generated from field: int64 value_sat = 7;
   */
  valueSat: bigint;

  /**
   * The value of the payment in milli-satoshis
   *
   * @generated from field: int64 value_msat = 8;
   */
  valueMsat: bigint;

  /**
   * The optional payment request being fulfilled.
   *
   * @generated from field: string payment_request = 9;
   */
  paymentRequest: string;

  /**
   * The status of the payment.
   *
   * @generated from field: lnrpc.Payment.PaymentStatus status = 10;
   */
  status: Payment_PaymentStatus;

  /**
   *  The fee paid for this payment in satoshis
   *
   * @generated from field: int64 fee_sat = 11;
   */
  feeSat: bigint;

  /**
   *  The fee paid for this payment in milli-satoshis
   *
   * @generated from field: int64 fee_msat = 12;
   */
  feeMsat: bigint;

  /**
   * The time in UNIX nanoseconds at which the payment was created.
   *
   * @generated from field: int64 creation_time_ns = 13;
   */
  creationTimeNs: bigint;

  /**
   * The HTLCs made in attempt to settle the payment.
   *
   * @generated from field: repeated lnrpc.HTLCAttempt htlcs = 14;
   */
  htlcs: HTLCAttempt[];

  /**
   * 
   * The creation index of this payment. Each payment can be uniquely identified
   * by this index, which may not strictly increment by 1 for payments made in
   * older versions of lnd.
   *
   * @generated from field: uint64 payment_index = 15;
   */
  paymentIndex: bigint;

  /**
   * @generated from field: lnrpc.PaymentFailureReason failure_reason = 16;
   */
  failureReason: PaymentFailureReason;
};

/**
 * Describes the message lnrpc.Payment.
 * Use `create(PaymentSchema)` to create a new message.
 */
export const PaymentSchema: GenMessage<Payment> = /*@__PURE__*/
  messageDesc(file_lightning, 136);

/**
 * @generated from enum lnrpc.Payment.PaymentStatus
 */
export enum Payment_PaymentStatus {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: IN_FLIGHT = 1;
   */
  IN_FLIGHT = 1,

  /**
   * @generated from enum value: SUCCEEDED = 2;
   */
  SUCCEEDED = 2,

  /**
   * @generated from enum value: FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum lnrpc.Payment.PaymentStatus.
 */
export const Payment_PaymentStatusSchema: GenEnum<Payment_PaymentStatus> = /*@__PURE__*/
  enumDesc(file_lightning, 136, 0);

/**
 * @generated from message lnrpc.HTLCAttempt
 */
export type HTLCAttempt = Message<"lnrpc.HTLCAttempt"> & {
  /**
   * The unique ID that is used for this attempt.
   *
   * @generated from field: uint64 attempt_id = 7;
   */
  attemptId: bigint;

  /**
   * The status of the HTLC.
   *
   * @generated from field: lnrpc.HTLCAttempt.HTLCStatus status = 1;
   */
  status: HTLCAttempt_HTLCStatus;

  /**
   * The route taken by this HTLC.
   *
   * @generated from field: lnrpc.Route route = 2;
   */
  route?: Route;

  /**
   * The time in UNIX nanoseconds at which this HTLC was sent.
   *
   * @generated from field: int64 attempt_time_ns = 3;
   */
  attemptTimeNs: bigint;

  /**
   * 
   * The time in UNIX nanoseconds at which this HTLC was settled or failed.
   * This value will not be set if the HTLC is still IN_FLIGHT.
   *
   * @generated from field: int64 resolve_time_ns = 4;
   */
  resolveTimeNs: bigint;

  /**
   * Detailed htlc failure info.
   *
   * @generated from field: lnrpc.Failure failure = 5;
   */
  failure?: Failure;

  /**
   * The preimage that was used to settle the HTLC.
   *
   * @generated from field: bytes preimage = 6;
   */
  preimage: Uint8Array;
};

/**
 * Describes the message lnrpc.HTLCAttempt.
 * Use `create(HTLCAttemptSchema)` to create a new message.
 */
export const HTLCAttemptSchema: GenMessage<HTLCAttempt> = /*@__PURE__*/
  messageDesc(file_lightning, 137);

/**
 * @generated from enum lnrpc.HTLCAttempt.HTLCStatus
 */
export enum HTLCAttempt_HTLCStatus {
  /**
   * @generated from enum value: IN_FLIGHT = 0;
   */
  IN_FLIGHT = 0,

  /**
   * @generated from enum value: SUCCEEDED = 1;
   */
  SUCCEEDED = 1,

  /**
   * @generated from enum value: FAILED = 2;
   */
  FAILED = 2,
}

/**
 * Describes the enum lnrpc.HTLCAttempt.HTLCStatus.
 */
export const HTLCAttempt_HTLCStatusSchema: GenEnum<HTLCAttempt_HTLCStatus> = /*@__PURE__*/
  enumDesc(file_lightning, 137, 0);

/**
 * @generated from message lnrpc.ListPaymentsRequest
 */
export type ListPaymentsRequest = Message<"lnrpc.ListPaymentsRequest"> & {
  /**
   * 
   * If true, then return payments that have not yet fully completed. This means
   * that pending payments, as well as failed payments will show up if this
   * field is set to true. This flag doesn't change the meaning of the indices,
   * which are tied to individual payments.
   *
   * @generated from field: bool include_incomplete = 1;
   */
  includeIncomplete: boolean;

  /**
   * 
   * The index of a payment that will be used as either the start or end of a
   * query to determine which payments should be returned in the response. The
   * index_offset is exclusive. In the case of a zero index_offset, the query
   * will start with the oldest payment when paginating forwards, or will end
   * with the most recent payment when paginating backwards.
   *
   * @generated from field: uint64 index_offset = 2;
   */
  indexOffset: bigint;

  /**
   * The maximal number of payments returned in the response to this query.
   *
   * @generated from field: uint64 max_payments = 3;
   */
  maxPayments: bigint;

  /**
   * 
   * If set, the payments returned will result from seeking backwards from the
   * specified index offset. This can be used to paginate backwards. The order
   * of the returned payments is always oldest first (ascending index order).
   *
   * @generated from field: bool reversed = 4;
   */
  reversed: boolean;

  /**
   * 
   * If set, all payments (complete and incomplete, independent of the
   * max_payments parameter) will be counted. Note that setting this to true will
   * increase the run time of the call significantly on systems that have a lot
   * of payments, as all of them have to be iterated through to be counted.
   *
   * @generated from field: bool count_total_payments = 5;
   */
  countTotalPayments: boolean;

  /**
   * If set, returns all invoices with a creation date greater than or equal
   * to it. Measured in seconds since the unix epoch.
   *
   * @generated from field: uint64 creation_date_start = 6;
   */
  creationDateStart: bigint;

  /**
   * If set, returns all invoices with a creation date less than or equal to
   * it. Measured in seconds since the unix epoch.
   *
   * @generated from field: uint64 creation_date_end = 7;
   */
  creationDateEnd: bigint;
};

/**
 * Describes the message lnrpc.ListPaymentsRequest.
 * Use `create(ListPaymentsRequestSchema)` to create a new message.
 */
export const ListPaymentsRequestSchema: GenMessage<ListPaymentsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 138);

/**
 * @generated from message lnrpc.ListPaymentsResponse
 */
export type ListPaymentsResponse = Message<"lnrpc.ListPaymentsResponse"> & {
  /**
   * The list of payments
   *
   * @generated from field: repeated lnrpc.Payment payments = 1;
   */
  payments: Payment[];

  /**
   * 
   * The index of the first item in the set of returned payments. This can be
   * used as the index_offset to continue seeking backwards in the next request.
   *
   * @generated from field: uint64 first_index_offset = 2;
   */
  firstIndexOffset: bigint;

  /**
   * 
   * The index of the last item in the set of returned payments. This can be used
   * as the index_offset to continue seeking forwards in the next request.
   *
   * @generated from field: uint64 last_index_offset = 3;
   */
  lastIndexOffset: bigint;

  /**
   * 
   * Will only be set if count_total_payments in the request was set. Represents
   * the total number of payments (complete and incomplete, independent of the
   * number of payments requested in the query) currently present in the payments
   * database.
   *
   * @generated from field: uint64 total_num_payments = 4;
   */
  totalNumPayments: bigint;
};

/**
 * Describes the message lnrpc.ListPaymentsResponse.
 * Use `create(ListPaymentsResponseSchema)` to create a new message.
 */
export const ListPaymentsResponseSchema: GenMessage<ListPaymentsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 139);

/**
 * @generated from message lnrpc.DeletePaymentRequest
 */
export type DeletePaymentRequest = Message<"lnrpc.DeletePaymentRequest"> & {
  /**
   * Payment hash to delete.
   *
   * @generated from field: bytes payment_hash = 1;
   */
  paymentHash: Uint8Array;

  /**
   * 
   * Only delete failed HTLCs from the payment, not the payment itself.
   *
   * @generated from field: bool failed_htlcs_only = 2;
   */
  failedHtlcsOnly: boolean;
};

/**
 * Describes the message lnrpc.DeletePaymentRequest.
 * Use `create(DeletePaymentRequestSchema)` to create a new message.
 */
export const DeletePaymentRequestSchema: GenMessage<DeletePaymentRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 140);

/**
 * @generated from message lnrpc.DeleteAllPaymentsRequest
 */
export type DeleteAllPaymentsRequest = Message<"lnrpc.DeleteAllPaymentsRequest"> & {
  /**
   * Only delete failed payments.
   *
   * @generated from field: bool failed_payments_only = 1;
   */
  failedPaymentsOnly: boolean;

  /**
   * 
   * Only delete failed HTLCs from payments, not the payment itself.
   *
   * @generated from field: bool failed_htlcs_only = 2;
   */
  failedHtlcsOnly: boolean;
};

/**
 * Describes the message lnrpc.DeleteAllPaymentsRequest.
 * Use `create(DeleteAllPaymentsRequestSchema)` to create a new message.
 */
export const DeleteAllPaymentsRequestSchema: GenMessage<DeleteAllPaymentsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 141);

/**
 * @generated from message lnrpc.DeletePaymentResponse
 */
export type DeletePaymentResponse = Message<"lnrpc.DeletePaymentResponse"> & {
};

/**
 * Describes the message lnrpc.DeletePaymentResponse.
 * Use `create(DeletePaymentResponseSchema)` to create a new message.
 */
export const DeletePaymentResponseSchema: GenMessage<DeletePaymentResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 142);

/**
 * @generated from message lnrpc.DeleteAllPaymentsResponse
 */
export type DeleteAllPaymentsResponse = Message<"lnrpc.DeleteAllPaymentsResponse"> & {
};

/**
 * Describes the message lnrpc.DeleteAllPaymentsResponse.
 * Use `create(DeleteAllPaymentsResponseSchema)` to create a new message.
 */
export const DeleteAllPaymentsResponseSchema: GenMessage<DeleteAllPaymentsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 143);

/**
 * @generated from message lnrpc.AbandonChannelRequest
 */
export type AbandonChannelRequest = Message<"lnrpc.AbandonChannelRequest"> & {
  /**
   * @generated from field: lnrpc.ChannelPoint channel_point = 1;
   */
  channelPoint?: ChannelPoint;

  /**
   * @generated from field: bool pending_funding_shim_only = 2;
   */
  pendingFundingShimOnly: boolean;

  /**
   * 
   * Override the requirement for being in dev mode by setting this to true and
   * confirming the user knows what they are doing and this is a potential foot
   * gun to lose funds if used on active channels.
   *
   * @generated from field: bool i_know_what_i_am_doing = 3;
   */
  iKnowWhatIAmDoing: boolean;
};

/**
 * Describes the message lnrpc.AbandonChannelRequest.
 * Use `create(AbandonChannelRequestSchema)` to create a new message.
 */
export const AbandonChannelRequestSchema: GenMessage<AbandonChannelRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 144);

/**
 * @generated from message lnrpc.AbandonChannelResponse
 */
export type AbandonChannelResponse = Message<"lnrpc.AbandonChannelResponse"> & {
};

/**
 * Describes the message lnrpc.AbandonChannelResponse.
 * Use `create(AbandonChannelResponseSchema)` to create a new message.
 */
export const AbandonChannelResponseSchema: GenMessage<AbandonChannelResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 145);

/**
 * @generated from message lnrpc.DebugLevelRequest
 */
export type DebugLevelRequest = Message<"lnrpc.DebugLevelRequest"> & {
  /**
   * @generated from field: bool show = 1;
   */
  show: boolean;

  /**
   * @generated from field: string level_spec = 2;
   */
  levelSpec: string;
};

/**
 * Describes the message lnrpc.DebugLevelRequest.
 * Use `create(DebugLevelRequestSchema)` to create a new message.
 */
export const DebugLevelRequestSchema: GenMessage<DebugLevelRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 146);

/**
 * @generated from message lnrpc.DebugLevelResponse
 */
export type DebugLevelResponse = Message<"lnrpc.DebugLevelResponse"> & {
  /**
   * @generated from field: string sub_systems = 1;
   */
  subSystems: string;
};

/**
 * Describes the message lnrpc.DebugLevelResponse.
 * Use `create(DebugLevelResponseSchema)` to create a new message.
 */
export const DebugLevelResponseSchema: GenMessage<DebugLevelResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 147);

/**
 * @generated from message lnrpc.PayReqString
 */
export type PayReqString = Message<"lnrpc.PayReqString"> & {
  /**
   * The payment request string to be decoded
   *
   * @generated from field: string pay_req = 1;
   */
  payReq: string;
};

/**
 * Describes the message lnrpc.PayReqString.
 * Use `create(PayReqStringSchema)` to create a new message.
 */
export const PayReqStringSchema: GenMessage<PayReqString> = /*@__PURE__*/
  messageDesc(file_lightning, 148);

/**
 * @generated from message lnrpc.PayReq
 */
export type PayReq = Message<"lnrpc.PayReq"> & {
  /**
   * @generated from field: string destination = 1;
   */
  destination: string;

  /**
   * @generated from field: string payment_hash = 2;
   */
  paymentHash: string;

  /**
   * @generated from field: int64 num_satoshis = 3;
   */
  numSatoshis: bigint;

  /**
   * @generated from field: int64 timestamp = 4;
   */
  timestamp: bigint;

  /**
   * @generated from field: int64 expiry = 5;
   */
  expiry: bigint;

  /**
   * @generated from field: string description = 6;
   */
  description: string;

  /**
   * @generated from field: string description_hash = 7;
   */
  descriptionHash: string;

  /**
   * @generated from field: string fallback_addr = 8;
   */
  fallbackAddr: string;

  /**
   * @generated from field: int64 cltv_expiry = 9;
   */
  cltvExpiry: bigint;

  /**
   * @generated from field: repeated lnrpc.RouteHint route_hints = 10;
   */
  routeHints: RouteHint[];

  /**
   * @generated from field: bytes payment_addr = 11;
   */
  paymentAddr: Uint8Array;

  /**
   * @generated from field: int64 num_msat = 12;
   */
  numMsat: bigint;

  /**
   * @generated from field: map<uint32, lnrpc.Feature> features = 13;
   */
  features: { [key: number]: Feature };
};

/**
 * Describes the message lnrpc.PayReq.
 * Use `create(PayReqSchema)` to create a new message.
 */
export const PayReqSchema: GenMessage<PayReq> = /*@__PURE__*/
  messageDesc(file_lightning, 149);

/**
 * @generated from message lnrpc.Feature
 */
export type Feature = Message<"lnrpc.Feature"> & {
  /**
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * @generated from field: bool is_required = 3;
   */
  isRequired: boolean;

  /**
   * @generated from field: bool is_known = 4;
   */
  isKnown: boolean;
};

/**
 * Describes the message lnrpc.Feature.
 * Use `create(FeatureSchema)` to create a new message.
 */
export const FeatureSchema: GenMessage<Feature> = /*@__PURE__*/
  messageDesc(file_lightning, 150);

/**
 * @generated from message lnrpc.FeeReportRequest
 */
export type FeeReportRequest = Message<"lnrpc.FeeReportRequest"> & {
};

/**
 * Describes the message lnrpc.FeeReportRequest.
 * Use `create(FeeReportRequestSchema)` to create a new message.
 */
export const FeeReportRequestSchema: GenMessage<FeeReportRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 151);

/**
 * @generated from message lnrpc.ChannelFeeReport
 */
export type ChannelFeeReport = Message<"lnrpc.ChannelFeeReport"> & {
  /**
   * The short channel id that this fee report belongs to.
   *
   * @generated from field: uint64 chan_id = 5 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * The channel that this fee report belongs to.
   *
   * @generated from field: string channel_point = 1;
   */
  channelPoint: string;

  /**
   * The base fee charged regardless of the number of milli-satoshis sent.
   *
   * @generated from field: int64 base_fee_msat = 2;
   */
  baseFeeMsat: bigint;

  /**
   * The amount charged per milli-satoshis transferred expressed in
   * millionths of a satoshi.
   *
   * @generated from field: int64 fee_per_mil = 3;
   */
  feePerMil: bigint;

  /**
   * The effective fee rate in milli-satoshis. Computed by dividing the
   * fee_per_mil value by 1 million.
   *
   * @generated from field: double fee_rate = 4;
   */
  feeRate: number;
};

/**
 * Describes the message lnrpc.ChannelFeeReport.
 * Use `create(ChannelFeeReportSchema)` to create a new message.
 */
export const ChannelFeeReportSchema: GenMessage<ChannelFeeReport> = /*@__PURE__*/
  messageDesc(file_lightning, 152);

/**
 * @generated from message lnrpc.FeeReportResponse
 */
export type FeeReportResponse = Message<"lnrpc.FeeReportResponse"> & {
  /**
   * An array of channel fee reports which describes the current fee schedule
   * for each channel.
   *
   * @generated from field: repeated lnrpc.ChannelFeeReport channel_fees = 1;
   */
  channelFees: ChannelFeeReport[];

  /**
   * The total amount of fee revenue (in satoshis) the switch has collected
   * over the past 24 hrs.
   *
   * @generated from field: uint64 day_fee_sum = 2;
   */
  dayFeeSum: bigint;

  /**
   * The total amount of fee revenue (in satoshis) the switch has collected
   * over the past 1 week.
   *
   * @generated from field: uint64 week_fee_sum = 3;
   */
  weekFeeSum: bigint;

  /**
   * The total amount of fee revenue (in satoshis) the switch has collected
   * over the past 1 month.
   *
   * @generated from field: uint64 month_fee_sum = 4;
   */
  monthFeeSum: bigint;
};

/**
 * Describes the message lnrpc.FeeReportResponse.
 * Use `create(FeeReportResponseSchema)` to create a new message.
 */
export const FeeReportResponseSchema: GenMessage<FeeReportResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 153);

/**
 * @generated from message lnrpc.PolicyUpdateRequest
 */
export type PolicyUpdateRequest = Message<"lnrpc.PolicyUpdateRequest"> & {
  /**
   * @generated from oneof lnrpc.PolicyUpdateRequest.scope
   */
  scope: {
    /**
     * If set, then this update applies to all currently active channels.
     *
     * @generated from field: bool global = 1;
     */
    value: boolean;
    case: "global";
  } | {
    /**
     * If set, this update will target a specific channel.
     *
     * @generated from field: lnrpc.ChannelPoint chan_point = 2;
     */
    value: ChannelPoint;
    case: "chanPoint";
  } | { case: undefined; value?: undefined };

  /**
   * The base fee charged regardless of the number of milli-satoshis sent.
   *
   * @generated from field: int64 base_fee_msat = 3;
   */
  baseFeeMsat: bigint;

  /**
   * The effective fee rate in milli-satoshis. The precision of this value
   * goes up to 6 decimal places, so 1e-6.
   *
   * @generated from field: double fee_rate = 4;
   */
  feeRate: number;

  /**
   * The effective fee rate in micro-satoshis (parts per million).
   *
   * @generated from field: uint32 fee_rate_ppm = 9;
   */
  feeRatePpm: number;

  /**
   * The required timelock delta for HTLCs forwarded over the channel.
   *
   * @generated from field: uint32 time_lock_delta = 5;
   */
  timeLockDelta: number;

  /**
   * If set, the maximum HTLC size in milli-satoshis. If unset, the maximum
   * HTLC will be unchanged.
   *
   * @generated from field: uint64 max_htlc_msat = 6;
   */
  maxHtlcMsat: bigint;

  /**
   * The minimum HTLC size in milli-satoshis. Only applied if
   * min_htlc_msat_specified is true.
   *
   * @generated from field: uint64 min_htlc_msat = 7;
   */
  minHtlcMsat: bigint;

  /**
   * If true, min_htlc_msat is applied.
   *
   * @generated from field: bool min_htlc_msat_specified = 8;
   */
  minHtlcMsatSpecified: boolean;
};

/**
 * Describes the message lnrpc.PolicyUpdateRequest.
 * Use `create(PolicyUpdateRequestSchema)` to create a new message.
 */
export const PolicyUpdateRequestSchema: GenMessage<PolicyUpdateRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 154);

/**
 * @generated from message lnrpc.FailedUpdate
 */
export type FailedUpdate = Message<"lnrpc.FailedUpdate"> & {
  /**
   * The outpoint in format txid:n
   *
   * @generated from field: lnrpc.OutPoint outpoint = 1;
   */
  outpoint?: OutPoint;

  /**
   * Reason for the policy update failure.
   *
   * @generated from field: lnrpc.UpdateFailure reason = 2;
   */
  reason: UpdateFailure;

  /**
   * A string representation of the policy update error.
   *
   * @generated from field: string update_error = 3;
   */
  updateError: string;
};

/**
 * Describes the message lnrpc.FailedUpdate.
 * Use `create(FailedUpdateSchema)` to create a new message.
 */
export const FailedUpdateSchema: GenMessage<FailedUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 155);

/**
 * @generated from message lnrpc.PolicyUpdateResponse
 */
export type PolicyUpdateResponse = Message<"lnrpc.PolicyUpdateResponse"> & {
  /**
   * List of failed policy updates.
   *
   * @generated from field: repeated lnrpc.FailedUpdate failed_updates = 1;
   */
  failedUpdates: FailedUpdate[];
};

/**
 * Describes the message lnrpc.PolicyUpdateResponse.
 * Use `create(PolicyUpdateResponseSchema)` to create a new message.
 */
export const PolicyUpdateResponseSchema: GenMessage<PolicyUpdateResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 156);

/**
 * @generated from message lnrpc.ForwardingHistoryRequest
 */
export type ForwardingHistoryRequest = Message<"lnrpc.ForwardingHistoryRequest"> & {
  /**
   * Start time is the starting point of the forwarding history request. All
   * records beyond this point will be included, respecting the end time, and
   * the index offset.
   *
   * @generated from field: uint64 start_time = 1;
   */
  startTime: bigint;

  /**
   * End time is the end point of the forwarding history request. The
   * response will carry at most 50k records between the start time and the
   * end time. The index offset can be used to implement pagination.
   *
   * @generated from field: uint64 end_time = 2;
   */
  endTime: bigint;

  /**
   * Index offset is the offset in the time series to start at. As each
   * response can only contain 50k records, callers can use this to skip
   * around within a packed time series.
   *
   * @generated from field: uint32 index_offset = 3;
   */
  indexOffset: number;

  /**
   * The max number of events to return in the response to this query.
   *
   * @generated from field: uint32 num_max_events = 4;
   */
  numMaxEvents: number;

  /**
   * Informs the server if the peer alias should be looked up for each
   * forwarding event.
   *
   * @generated from field: bool peer_alias_lookup = 5;
   */
  peerAliasLookup: boolean;
};

/**
 * Describes the message lnrpc.ForwardingHistoryRequest.
 * Use `create(ForwardingHistoryRequestSchema)` to create a new message.
 */
export const ForwardingHistoryRequestSchema: GenMessage<ForwardingHistoryRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 157);

/**
 * @generated from message lnrpc.ForwardingEvent
 */
export type ForwardingEvent = Message<"lnrpc.ForwardingEvent"> & {
  /**
   * Timestamp is the time (unix epoch offset) that this circuit was
   * completed. Deprecated by timestamp_ns.
   *
   * @generated from field: uint64 timestamp = 1 [deprecated = true];
   * @deprecated
   */
  timestamp: bigint;

  /**
   * The incoming channel ID that carried the HTLC that created the circuit.
   *
   * @generated from field: uint64 chan_id_in = 2 [jstype = JS_STRING];
   */
  chanIdIn: string;

  /**
   * The outgoing channel ID that carried the preimage that completed the
   * circuit.
   *
   * @generated from field: uint64 chan_id_out = 4 [jstype = JS_STRING];
   */
  chanIdOut: string;

  /**
   * The total amount (in satoshis) of the incoming HTLC that created half
   * the circuit.
   *
   * @generated from field: uint64 amt_in = 5;
   */
  amtIn: bigint;

  /**
   * The total amount (in satoshis) of the outgoing HTLC that created the
   * second half of the circuit.
   *
   * @generated from field: uint64 amt_out = 6;
   */
  amtOut: bigint;

  /**
   * The total fee (in satoshis) that this payment circuit carried.
   *
   * @generated from field: uint64 fee = 7;
   */
  fee: bigint;

  /**
   * The total fee (in milli-satoshis) that this payment circuit carried.
   *
   * @generated from field: uint64 fee_msat = 8;
   */
  feeMsat: bigint;

  /**
   * The total amount (in milli-satoshis) of the incoming HTLC that created
   * half the circuit.
   *
   * @generated from field: uint64 amt_in_msat = 9;
   */
  amtInMsat: bigint;

  /**
   * The total amount (in milli-satoshis) of the outgoing HTLC that created
   * the second half of the circuit.
   *
   * @generated from field: uint64 amt_out_msat = 10;
   */
  amtOutMsat: bigint;

  /**
   * The number of nanoseconds elapsed since January 1, 1970 UTC when this
   * circuit was completed.
   *
   * @generated from field: uint64 timestamp_ns = 11;
   */
  timestampNs: bigint;

  /**
   * The peer alias of the incoming channel.
   *
   * @generated from field: string peer_alias_in = 12;
   */
  peerAliasIn: string;

  /**
   * The peer alias of the outgoing channel.
   *
   * @generated from field: string peer_alias_out = 13;
   */
  peerAliasOut: string;
};

/**
 * Describes the message lnrpc.ForwardingEvent.
 * Use `create(ForwardingEventSchema)` to create a new message.
 */
export const ForwardingEventSchema: GenMessage<ForwardingEvent> = /*@__PURE__*/
  messageDesc(file_lightning, 158);

/**
 * @generated from message lnrpc.ForwardingHistoryResponse
 */
export type ForwardingHistoryResponse = Message<"lnrpc.ForwardingHistoryResponse"> & {
  /**
   * A list of forwarding events from the time slice of the time series
   * specified in the request.
   *
   * @generated from field: repeated lnrpc.ForwardingEvent forwarding_events = 1;
   */
  forwardingEvents: ForwardingEvent[];

  /**
   * The index of the last time in the set of returned forwarding events. Can
   * be used to seek further, pagination style.
   *
   * @generated from field: uint32 last_offset_index = 2;
   */
  lastOffsetIndex: number;
};

/**
 * Describes the message lnrpc.ForwardingHistoryResponse.
 * Use `create(ForwardingHistoryResponseSchema)` to create a new message.
 */
export const ForwardingHistoryResponseSchema: GenMessage<ForwardingHistoryResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 159);

/**
 * @generated from message lnrpc.ExportChannelBackupRequest
 */
export type ExportChannelBackupRequest = Message<"lnrpc.ExportChannelBackupRequest"> & {
  /**
   * The target channel point to obtain a back up for.
   *
   * @generated from field: lnrpc.ChannelPoint chan_point = 1;
   */
  chanPoint?: ChannelPoint;
};

/**
 * Describes the message lnrpc.ExportChannelBackupRequest.
 * Use `create(ExportChannelBackupRequestSchema)` to create a new message.
 */
export const ExportChannelBackupRequestSchema: GenMessage<ExportChannelBackupRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 160);

/**
 * @generated from message lnrpc.ChannelBackup
 */
export type ChannelBackup = Message<"lnrpc.ChannelBackup"> & {
  /**
   * 
   * Identifies the channel that this backup belongs to.
   *
   * @generated from field: lnrpc.ChannelPoint chan_point = 1;
   */
  chanPoint?: ChannelPoint;

  /**
   * 
   * Is an encrypted single-chan backup. this can be passed to
   * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
   * order to trigger the recovery protocol. When using REST, this field must be
   * encoded as base64.
   *
   * @generated from field: bytes chan_backup = 2;
   */
  chanBackup: Uint8Array;
};

/**
 * Describes the message lnrpc.ChannelBackup.
 * Use `create(ChannelBackupSchema)` to create a new message.
 */
export const ChannelBackupSchema: GenMessage<ChannelBackup> = /*@__PURE__*/
  messageDesc(file_lightning, 161);

/**
 * @generated from message lnrpc.MultiChanBackup
 */
export type MultiChanBackup = Message<"lnrpc.MultiChanBackup"> & {
  /**
   * 
   * Is the set of all channels that are included in this multi-channel backup.
   *
   * @generated from field: repeated lnrpc.ChannelPoint chan_points = 1;
   */
  chanPoints: ChannelPoint[];

  /**
   * 
   * A single encrypted blob containing all the static channel backups of the
   * channel listed above. This can be stored as a single file or blob, and
   * safely be replaced with any prior/future versions. When using REST, this
   * field must be encoded as base64.
   *
   * @generated from field: bytes multi_chan_backup = 2;
   */
  multiChanBackup: Uint8Array;
};

/**
 * Describes the message lnrpc.MultiChanBackup.
 * Use `create(MultiChanBackupSchema)` to create a new message.
 */
export const MultiChanBackupSchema: GenMessage<MultiChanBackup> = /*@__PURE__*/
  messageDesc(file_lightning, 162);

/**
 * @generated from message lnrpc.ChanBackupExportRequest
 */
export type ChanBackupExportRequest = Message<"lnrpc.ChanBackupExportRequest"> & {
};

/**
 * Describes the message lnrpc.ChanBackupExportRequest.
 * Use `create(ChanBackupExportRequestSchema)` to create a new message.
 */
export const ChanBackupExportRequestSchema: GenMessage<ChanBackupExportRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 163);

/**
 * @generated from message lnrpc.ChanBackupSnapshot
 */
export type ChanBackupSnapshot = Message<"lnrpc.ChanBackupSnapshot"> & {
  /**
   * 
   * The set of new channels that have been added since the last channel backup
   * snapshot was requested.
   *
   * @generated from field: lnrpc.ChannelBackups single_chan_backups = 1;
   */
  singleChanBackups?: ChannelBackups;

  /**
   * 
   * A multi-channel backup that covers all open channels currently known to
   * lnd.
   *
   * @generated from field: lnrpc.MultiChanBackup multi_chan_backup = 2;
   */
  multiChanBackup?: MultiChanBackup;
};

/**
 * Describes the message lnrpc.ChanBackupSnapshot.
 * Use `create(ChanBackupSnapshotSchema)` to create a new message.
 */
export const ChanBackupSnapshotSchema: GenMessage<ChanBackupSnapshot> = /*@__PURE__*/
  messageDesc(file_lightning, 164);

/**
 * @generated from message lnrpc.ChannelBackups
 */
export type ChannelBackups = Message<"lnrpc.ChannelBackups"> & {
  /**
   * 
   * A set of single-chan static channel backups.
   *
   * @generated from field: repeated lnrpc.ChannelBackup chan_backups = 1;
   */
  chanBackups: ChannelBackup[];
};

/**
 * Describes the message lnrpc.ChannelBackups.
 * Use `create(ChannelBackupsSchema)` to create a new message.
 */
export const ChannelBackupsSchema: GenMessage<ChannelBackups> = /*@__PURE__*/
  messageDesc(file_lightning, 165);

/**
 * @generated from message lnrpc.RestoreChanBackupRequest
 */
export type RestoreChanBackupRequest = Message<"lnrpc.RestoreChanBackupRequest"> & {
  /**
   * @generated from oneof lnrpc.RestoreChanBackupRequest.backup
   */
  backup: {
    /**
     * 
     * The channels to restore as a list of channel/backup pairs.
     *
     * @generated from field: lnrpc.ChannelBackups chan_backups = 1;
     */
    value: ChannelBackups;
    case: "chanBackups";
  } | {
    /**
     * 
     * The channels to restore in the packed multi backup format. When using
     * REST, this field must be encoded as base64.
     *
     * @generated from field: bytes multi_chan_backup = 2;
     */
    value: Uint8Array;
    case: "multiChanBackup";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.RestoreChanBackupRequest.
 * Use `create(RestoreChanBackupRequestSchema)` to create a new message.
 */
export const RestoreChanBackupRequestSchema: GenMessage<RestoreChanBackupRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 166);

/**
 * @generated from message lnrpc.RestoreBackupResponse
 */
export type RestoreBackupResponse = Message<"lnrpc.RestoreBackupResponse"> & {
};

/**
 * Describes the message lnrpc.RestoreBackupResponse.
 * Use `create(RestoreBackupResponseSchema)` to create a new message.
 */
export const RestoreBackupResponseSchema: GenMessage<RestoreBackupResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 167);

/**
 * @generated from message lnrpc.ChannelBackupSubscription
 */
export type ChannelBackupSubscription = Message<"lnrpc.ChannelBackupSubscription"> & {
};

/**
 * Describes the message lnrpc.ChannelBackupSubscription.
 * Use `create(ChannelBackupSubscriptionSchema)` to create a new message.
 */
export const ChannelBackupSubscriptionSchema: GenMessage<ChannelBackupSubscription> = /*@__PURE__*/
  messageDesc(file_lightning, 168);

/**
 * @generated from message lnrpc.VerifyChanBackupResponse
 */
export type VerifyChanBackupResponse = Message<"lnrpc.VerifyChanBackupResponse"> & {
};

/**
 * Describes the message lnrpc.VerifyChanBackupResponse.
 * Use `create(VerifyChanBackupResponseSchema)` to create a new message.
 */
export const VerifyChanBackupResponseSchema: GenMessage<VerifyChanBackupResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 169);

/**
 * @generated from message lnrpc.MacaroonPermission
 */
export type MacaroonPermission = Message<"lnrpc.MacaroonPermission"> & {
  /**
   * The entity a permission grants access to.
   *
   * @generated from field: string entity = 1;
   */
  entity: string;

  /**
   * The action that is granted.
   *
   * @generated from field: string action = 2;
   */
  action: string;
};

/**
 * Describes the message lnrpc.MacaroonPermission.
 * Use `create(MacaroonPermissionSchema)` to create a new message.
 */
export const MacaroonPermissionSchema: GenMessage<MacaroonPermission> = /*@__PURE__*/
  messageDesc(file_lightning, 170);

/**
 * @generated from message lnrpc.BakeMacaroonRequest
 */
export type BakeMacaroonRequest = Message<"lnrpc.BakeMacaroonRequest"> & {
  /**
   * The list of permissions the new macaroon should grant.
   *
   * @generated from field: repeated lnrpc.MacaroonPermission permissions = 1;
   */
  permissions: MacaroonPermission[];

  /**
   * The root key ID used to create the macaroon, must be a positive integer.
   *
   * @generated from field: uint64 root_key_id = 2;
   */
  rootKeyId: bigint;

  /**
   * 
   * Informs the RPC on whether to allow external permissions that LND is not
   * aware of.
   *
   * @generated from field: bool allow_external_permissions = 3;
   */
  allowExternalPermissions: boolean;
};

/**
 * Describes the message lnrpc.BakeMacaroonRequest.
 * Use `create(BakeMacaroonRequestSchema)` to create a new message.
 */
export const BakeMacaroonRequestSchema: GenMessage<BakeMacaroonRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 171);

/**
 * @generated from message lnrpc.BakeMacaroonResponse
 */
export type BakeMacaroonResponse = Message<"lnrpc.BakeMacaroonResponse"> & {
  /**
   * The hex encoded macaroon, serialized in binary format.
   *
   * @generated from field: string macaroon = 1;
   */
  macaroon: string;
};

/**
 * Describes the message lnrpc.BakeMacaroonResponse.
 * Use `create(BakeMacaroonResponseSchema)` to create a new message.
 */
export const BakeMacaroonResponseSchema: GenMessage<BakeMacaroonResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 172);

/**
 * @generated from message lnrpc.ListMacaroonIDsRequest
 */
export type ListMacaroonIDsRequest = Message<"lnrpc.ListMacaroonIDsRequest"> & {
};

/**
 * Describes the message lnrpc.ListMacaroonIDsRequest.
 * Use `create(ListMacaroonIDsRequestSchema)` to create a new message.
 */
export const ListMacaroonIDsRequestSchema: GenMessage<ListMacaroonIDsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 173);

/**
 * @generated from message lnrpc.ListMacaroonIDsResponse
 */
export type ListMacaroonIDsResponse = Message<"lnrpc.ListMacaroonIDsResponse"> & {
  /**
   * The list of root key IDs that are in use.
   *
   * @generated from field: repeated uint64 root_key_ids = 1;
   */
  rootKeyIds: bigint[];
};

/**
 * Describes the message lnrpc.ListMacaroonIDsResponse.
 * Use `create(ListMacaroonIDsResponseSchema)` to create a new message.
 */
export const ListMacaroonIDsResponseSchema: GenMessage<ListMacaroonIDsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 174);

/**
 * @generated from message lnrpc.DeleteMacaroonIDRequest
 */
export type DeleteMacaroonIDRequest = Message<"lnrpc.DeleteMacaroonIDRequest"> & {
  /**
   * The root key ID to be removed.
   *
   * @generated from field: uint64 root_key_id = 1;
   */
  rootKeyId: bigint;
};

/**
 * Describes the message lnrpc.DeleteMacaroonIDRequest.
 * Use `create(DeleteMacaroonIDRequestSchema)` to create a new message.
 */
export const DeleteMacaroonIDRequestSchema: GenMessage<DeleteMacaroonIDRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 175);

/**
 * @generated from message lnrpc.DeleteMacaroonIDResponse
 */
export type DeleteMacaroonIDResponse = Message<"lnrpc.DeleteMacaroonIDResponse"> & {
  /**
   * A boolean indicates that the deletion is successful.
   *
   * @generated from field: bool deleted = 1;
   */
  deleted: boolean;
};

/**
 * Describes the message lnrpc.DeleteMacaroonIDResponse.
 * Use `create(DeleteMacaroonIDResponseSchema)` to create a new message.
 */
export const DeleteMacaroonIDResponseSchema: GenMessage<DeleteMacaroonIDResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 176);

/**
 * @generated from message lnrpc.MacaroonPermissionList
 */
export type MacaroonPermissionList = Message<"lnrpc.MacaroonPermissionList"> & {
  /**
   * A list of macaroon permissions.
   *
   * @generated from field: repeated lnrpc.MacaroonPermission permissions = 1;
   */
  permissions: MacaroonPermission[];
};

/**
 * Describes the message lnrpc.MacaroonPermissionList.
 * Use `create(MacaroonPermissionListSchema)` to create a new message.
 */
export const MacaroonPermissionListSchema: GenMessage<MacaroonPermissionList> = /*@__PURE__*/
  messageDesc(file_lightning, 177);

/**
 * @generated from message lnrpc.ListPermissionsRequest
 */
export type ListPermissionsRequest = Message<"lnrpc.ListPermissionsRequest"> & {
};

/**
 * Describes the message lnrpc.ListPermissionsRequest.
 * Use `create(ListPermissionsRequestSchema)` to create a new message.
 */
export const ListPermissionsRequestSchema: GenMessage<ListPermissionsRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 178);

/**
 * @generated from message lnrpc.ListPermissionsResponse
 */
export type ListPermissionsResponse = Message<"lnrpc.ListPermissionsResponse"> & {
  /**
   * 
   * A map between all RPC method URIs and their required macaroon permissions to
   * access them.
   *
   * @generated from field: map<string, lnrpc.MacaroonPermissionList> method_permissions = 1;
   */
  methodPermissions: { [key: string]: MacaroonPermissionList };
};

/**
 * Describes the message lnrpc.ListPermissionsResponse.
 * Use `create(ListPermissionsResponseSchema)` to create a new message.
 */
export const ListPermissionsResponseSchema: GenMessage<ListPermissionsResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 179);

/**
 * @generated from message lnrpc.Failure
 */
export type Failure = Message<"lnrpc.Failure"> & {
  /**
   * Failure code as defined in the Lightning spec
   *
   * @generated from field: lnrpc.Failure.FailureCode code = 1;
   */
  code: Failure_FailureCode;

  /**
   * An optional channel update message.
   *
   * @generated from field: lnrpc.ChannelUpdate channel_update = 3;
   */
  channelUpdate?: ChannelUpdate;

  /**
   * A failure type-dependent htlc value.
   *
   * @generated from field: uint64 htlc_msat = 4;
   */
  htlcMsat: bigint;

  /**
   * The sha256 sum of the onion payload.
   *
   * @generated from field: bytes onion_sha_256 = 5;
   */
  onionSha256: Uint8Array;

  /**
   * A failure type-dependent cltv expiry value.
   *
   * @generated from field: uint32 cltv_expiry = 6;
   */
  cltvExpiry: number;

  /**
   * A failure type-dependent flags value.
   *
   * @generated from field: uint32 flags = 7;
   */
  flags: number;

  /**
   * 
   * The position in the path of the intermediate or final node that generated
   * the failure message. Position zero is the sender node.
   *
   * @generated from field: uint32 failure_source_index = 8;
   */
  failureSourceIndex: number;

  /**
   * A failure type-dependent block height.
   *
   * @generated from field: uint32 height = 9;
   */
  height: number;
};

/**
 * Describes the message lnrpc.Failure.
 * Use `create(FailureSchema)` to create a new message.
 */
export const FailureSchema: GenMessage<Failure> = /*@__PURE__*/
  messageDesc(file_lightning, 180);

/**
 * @generated from enum lnrpc.Failure.FailureCode
 */
export enum Failure_FailureCode {
  /**
   * 
   * The numbers assigned in this enumeration match the failure codes as
   * defined in BOLT #4. Because protobuf 3 requires enums to start with 0,
   * a RESERVED value is added.
   *
   * @generated from enum value: RESERVED = 0;
   */
  RESERVED = 0,

  /**
   * @generated from enum value: INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1;
   */
  INCORRECT_OR_UNKNOWN_PAYMENT_DETAILS = 1,

  /**
   * @generated from enum value: INCORRECT_PAYMENT_AMOUNT = 2;
   */
  INCORRECT_PAYMENT_AMOUNT = 2,

  /**
   * @generated from enum value: FINAL_INCORRECT_CLTV_EXPIRY = 3;
   */
  FINAL_INCORRECT_CLTV_EXPIRY = 3,

  /**
   * @generated from enum value: FINAL_INCORRECT_HTLC_AMOUNT = 4;
   */
  FINAL_INCORRECT_HTLC_AMOUNT = 4,

  /**
   * @generated from enum value: FINAL_EXPIRY_TOO_SOON = 5;
   */
  FINAL_EXPIRY_TOO_SOON = 5,

  /**
   * @generated from enum value: INVALID_REALM = 6;
   */
  INVALID_REALM = 6,

  /**
   * @generated from enum value: EXPIRY_TOO_SOON = 7;
   */
  EXPIRY_TOO_SOON = 7,

  /**
   * @generated from enum value: INVALID_ONION_VERSION = 8;
   */
  INVALID_ONION_VERSION = 8,

  /**
   * @generated from enum value: INVALID_ONION_HMAC = 9;
   */
  INVALID_ONION_HMAC = 9,

  /**
   * @generated from enum value: INVALID_ONION_KEY = 10;
   */
  INVALID_ONION_KEY = 10,

  /**
   * @generated from enum value: AMOUNT_BELOW_MINIMUM = 11;
   */
  AMOUNT_BELOW_MINIMUM = 11,

  /**
   * @generated from enum value: FEE_INSUFFICIENT = 12;
   */
  FEE_INSUFFICIENT = 12,

  /**
   * @generated from enum value: INCORRECT_CLTV_EXPIRY = 13;
   */
  INCORRECT_CLTV_EXPIRY = 13,

  /**
   * @generated from enum value: CHANNEL_DISABLED = 14;
   */
  CHANNEL_DISABLED = 14,

  /**
   * @generated from enum value: TEMPORARY_CHANNEL_FAILURE = 15;
   */
  TEMPORARY_CHANNEL_FAILURE = 15,

  /**
   * @generated from enum value: REQUIRED_NODE_FEATURE_MISSING = 16;
   */
  REQUIRED_NODE_FEATURE_MISSING = 16,

  /**
   * @generated from enum value: REQUIRED_CHANNEL_FEATURE_MISSING = 17;
   */
  REQUIRED_CHANNEL_FEATURE_MISSING = 17,

  /**
   * @generated from enum value: UNKNOWN_NEXT_PEER = 18;
   */
  UNKNOWN_NEXT_PEER = 18,

  /**
   * @generated from enum value: TEMPORARY_NODE_FAILURE = 19;
   */
  TEMPORARY_NODE_FAILURE = 19,

  /**
   * @generated from enum value: PERMANENT_NODE_FAILURE = 20;
   */
  PERMANENT_NODE_FAILURE = 20,

  /**
   * @generated from enum value: PERMANENT_CHANNEL_FAILURE = 21;
   */
  PERMANENT_CHANNEL_FAILURE = 21,

  /**
   * @generated from enum value: EXPIRY_TOO_FAR = 22;
   */
  EXPIRY_TOO_FAR = 22,

  /**
   * @generated from enum value: MPP_TIMEOUT = 23;
   */
  MPP_TIMEOUT = 23,

  /**
   * @generated from enum value: INVALID_ONION_PAYLOAD = 24;
   */
  INVALID_ONION_PAYLOAD = 24,

  /**
   * 
   * An internal error occurred.
   *
   * @generated from enum value: INTERNAL_FAILURE = 997;
   */
  INTERNAL_FAILURE = 997,

  /**
   * 
   * The error source is known, but the failure itself couldn't be decoded.
   *
   * @generated from enum value: UNKNOWN_FAILURE = 998;
   */
  UNKNOWN_FAILURE = 998,

  /**
   * 
   * An unreadable failure result is returned if the received failure message
   * cannot be decrypted. In that case the error source is unknown.
   *
   * @generated from enum value: UNREADABLE_FAILURE = 999;
   */
  UNREADABLE_FAILURE = 999,
}

/**
 * Describes the enum lnrpc.Failure.FailureCode.
 */
export const Failure_FailureCodeSchema: GenEnum<Failure_FailureCode> = /*@__PURE__*/
  enumDesc(file_lightning, 180, 0);

/**
 * @generated from message lnrpc.ChannelUpdate
 */
export type ChannelUpdate = Message<"lnrpc.ChannelUpdate"> & {
  /**
   * 
   * The signature that validates the announced data and proves the ownership
   * of node id.
   *
   * @generated from field: bytes signature = 1;
   */
  signature: Uint8Array;

  /**
   * 
   * The target chain that this channel was opened within. This value
   * should be the genesis hash of the target chain. Along with the short
   * channel ID, this uniquely identifies the channel globally in a
   * blockchain.
   *
   * @generated from field: bytes chain_hash = 2;
   */
  chainHash: Uint8Array;

  /**
   * 
   * The unique description of the funding transaction.
   *
   * @generated from field: uint64 chan_id = 3 [jstype = JS_STRING];
   */
  chanId: string;

  /**
   * 
   * A timestamp that allows ordering in the case of multiple announcements.
   * We should ignore the message if timestamp is not greater than the
   * last-received.
   *
   * @generated from field: uint32 timestamp = 4;
   */
  timestamp: number;

  /**
   * 
   * The bitfield that describes whether optional fields are present in this
   * update. Currently, the least-significant bit must be set to 1 if the
   * optional field MaxHtlc is present.
   *
   * @generated from field: uint32 message_flags = 10;
   */
  messageFlags: number;

  /**
   * 
   * The bitfield that describes additional meta-data concerning how the
   * update is to be interpreted. Currently, the least-significant bit must be
   * set to 0 if the creating node corresponds to the first node in the
   * previously sent channel announcement and 1 otherwise. If the second bit
   * is set, then the channel is set to be disabled.
   *
   * @generated from field: uint32 channel_flags = 5;
   */
  channelFlags: number;

  /**
   * 
   * The minimum number of blocks this node requires to be added to the expiry
   * of HTLCs. This is a security parameter determined by the node operator.
   * This value represents the required gap between the time locks of the
   * incoming and outgoing HTLC's set to this node.
   *
   * @generated from field: uint32 time_lock_delta = 6;
   */
  timeLockDelta: number;

  /**
   * 
   * The minimum HTLC value which will be accepted.
   *
   * @generated from field: uint64 htlc_minimum_msat = 7;
   */
  htlcMinimumMsat: bigint;

  /**
   * 
   * The base fee that must be used for incoming HTLC's to this particular
   * channel. This value will be tacked onto the required for a payment
   * independent of the size of the payment.
   *
   * @generated from field: uint32 base_fee = 8;
   */
  baseFee: number;

  /**
   * 
   * The fee rate that will be charged per millionth of a satoshi.
   *
   * @generated from field: uint32 fee_rate = 9;
   */
  feeRate: number;

  /**
   * 
   * The maximum HTLC value which will be accepted.
   *
   * @generated from field: uint64 htlc_maximum_msat = 11;
   */
  htlcMaximumMsat: bigint;

  /**
   * 
   * The set of data that was appended to this message, some of which we may
   * not actually know how to iterate or parse. By holding onto this data, we
   * ensure that we're able to properly validate the set of signatures that
   * cover these new fields, and ensure we're able to make upgrades to the
   * network in a forwards compatible manner.
   *
   * @generated from field: bytes extra_opaque_data = 12;
   */
  extraOpaqueData: Uint8Array;
};

/**
 * Describes the message lnrpc.ChannelUpdate.
 * Use `create(ChannelUpdateSchema)` to create a new message.
 */
export const ChannelUpdateSchema: GenMessage<ChannelUpdate> = /*@__PURE__*/
  messageDesc(file_lightning, 181);

/**
 * @generated from message lnrpc.MacaroonId
 */
export type MacaroonId = Message<"lnrpc.MacaroonId"> & {
  /**
   * @generated from field: bytes nonce = 1;
   */
  nonce: Uint8Array;

  /**
   * @generated from field: bytes storageId = 2;
   */
  storageId: Uint8Array;

  /**
   * @generated from field: repeated lnrpc.Op ops = 3;
   */
  ops: Op[];
};

/**
 * Describes the message lnrpc.MacaroonId.
 * Use `create(MacaroonIdSchema)` to create a new message.
 */
export const MacaroonIdSchema: GenMessage<MacaroonId> = /*@__PURE__*/
  messageDesc(file_lightning, 182);

/**
 * @generated from message lnrpc.Op
 */
export type Op = Message<"lnrpc.Op"> & {
  /**
   * @generated from field: string entity = 1;
   */
  entity: string;

  /**
   * @generated from field: repeated string actions = 2;
   */
  actions: string[];
};

/**
 * Describes the message lnrpc.Op.
 * Use `create(OpSchema)` to create a new message.
 */
export const OpSchema: GenMessage<Op> = /*@__PURE__*/
  messageDesc(file_lightning, 183);

/**
 * @generated from message lnrpc.CheckMacPermRequest
 */
export type CheckMacPermRequest = Message<"lnrpc.CheckMacPermRequest"> & {
  /**
   * @generated from field: bytes macaroon = 1;
   */
  macaroon: Uint8Array;

  /**
   * @generated from field: repeated lnrpc.MacaroonPermission permissions = 2;
   */
  permissions: MacaroonPermission[];

  /**
   * @generated from field: string fullMethod = 3;
   */
  fullMethod: string;
};

/**
 * Describes the message lnrpc.CheckMacPermRequest.
 * Use `create(CheckMacPermRequestSchema)` to create a new message.
 */
export const CheckMacPermRequestSchema: GenMessage<CheckMacPermRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 184);

/**
 * @generated from message lnrpc.CheckMacPermResponse
 */
export type CheckMacPermResponse = Message<"lnrpc.CheckMacPermResponse"> & {
  /**
   * @generated from field: bool valid = 1;
   */
  valid: boolean;
};

/**
 * Describes the message lnrpc.CheckMacPermResponse.
 * Use `create(CheckMacPermResponseSchema)` to create a new message.
 */
export const CheckMacPermResponseSchema: GenMessage<CheckMacPermResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 185);

/**
 * @generated from message lnrpc.RPCMiddlewareRequest
 */
export type RPCMiddlewareRequest = Message<"lnrpc.RPCMiddlewareRequest"> & {
  /**
   * 
   * The unique ID of the intercepted original gRPC request. Useful for mapping
   * request to response when implementing full duplex message interception. For
   * streaming requests, this will be the same ID for all incoming and outgoing
   * middleware intercept messages of the _same_ stream.
   *
   * @generated from field: uint64 request_id = 1;
   */
  requestId: bigint;

  /**
   * 
   * The raw bytes of the complete macaroon as sent by the gRPC client in the
   * original request. This might be empty for a request that doesn't require
   * macaroons such as the wallet unlocker RPCs.
   *
   * @generated from field: bytes raw_macaroon = 2;
   */
  rawMacaroon: Uint8Array;

  /**
   * 
   * The parsed condition of the macaroon's custom caveat for convenient access.
   * This field only contains the value of the custom caveat that the handling
   * middleware has registered itself for. The condition _must_ be validated for
   * messages of intercept_type stream_auth and request!
   *
   * @generated from field: string custom_caveat_condition = 3;
   */
  customCaveatCondition: string;

  /**
   * 
   * There are three types of messages that will be sent to the middleware for
   * inspection and approval: Stream authentication, request and response
   * interception. The first two can only be accepted (=forward to main RPC
   * server) or denied (=return error to client). Intercepted responses can also
   * be replaced/overwritten.
   *
   * @generated from oneof lnrpc.RPCMiddlewareRequest.intercept_type
   */
  interceptType: {
    /**
     * 
     * Intercept stream authentication: each new streaming RPC call that is
     * initiated against lnd and contains the middleware's custom macaroon
     * caveat can be approved or denied based upon the macaroon in the stream
     * header. This message will only be sent for streaming RPCs, unary RPCs
     * must handle the macaroon authentication in the request interception to
     * avoid an additional message round trip between lnd and the middleware.
     *
     * @generated from field: lnrpc.StreamAuth stream_auth = 4;
     */
    value: StreamAuth;
    case: "streamAuth";
  } | {
    /**
     * 
     * Intercept incoming gRPC client request message: all incoming messages,
     * both on streaming and unary RPCs, are forwarded to the middleware for
     * inspection. For unary RPC messages the middleware is also expected to
     * validate the custom macaroon caveat of the request.
     *
     * @generated from field: lnrpc.RPCMessage request = 5;
     */
    value: RPCMessage;
    case: "request";
  } | {
    /**
     * 
     * Intercept outgoing gRPC response message: all outgoing messages, both on
     * streaming and unary RPCs, are forwarded to the middleware for inspection
     * and amendment. The response in this message is the original response as
     * it was generated by the main RPC server. It can either be accepted
     * (=forwarded to the client), replaced/overwritten with a new message of
     * the same type, or replaced by an error message.
     *
     * @generated from field: lnrpc.RPCMessage response = 6;
     */
    value: RPCMessage;
    case: "response";
  } | {
    /**
     * 
     * This is used to indicate to the client that the server has successfully
     * registered the interceptor. This is only used in the very first message
     * that the server sends to the client after the client sends the server
     * the middleware registration message.
     *
     * @generated from field: bool reg_complete = 8;
     */
    value: boolean;
    case: "regComplete";
  } | { case: undefined; value?: undefined };

  /**
   * 
   * The unique message ID of this middleware intercept message. There can be
   * multiple middleware intercept messages per single gRPC request (one for the
   * incoming request and one for the outgoing response) or gRPC stream (one for
   * each incoming message and one for each outgoing response). This message ID
   * must be referenced when responding (accepting/rejecting/modifying) to an
   * intercept message.
   *
   * @generated from field: uint64 msg_id = 7;
   */
  msgId: bigint;
};

/**
 * Describes the message lnrpc.RPCMiddlewareRequest.
 * Use `create(RPCMiddlewareRequestSchema)` to create a new message.
 */
export const RPCMiddlewareRequestSchema: GenMessage<RPCMiddlewareRequest> = /*@__PURE__*/
  messageDesc(file_lightning, 186);

/**
 * @generated from message lnrpc.StreamAuth
 */
export type StreamAuth = Message<"lnrpc.StreamAuth"> & {
  /**
   * 
   * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
   * example /lnrpc.Lightning/GetInfo) of the streaming RPC method that was just
   * established.
   *
   * @generated from field: string method_full_uri = 1;
   */
  methodFullUri: string;
};

/**
 * Describes the message lnrpc.StreamAuth.
 * Use `create(StreamAuthSchema)` to create a new message.
 */
export const StreamAuthSchema: GenMessage<StreamAuth> = /*@__PURE__*/
  messageDesc(file_lightning, 187);

/**
 * @generated from message lnrpc.RPCMessage
 */
export type RPCMessage = Message<"lnrpc.RPCMessage"> & {
  /**
   * 
   * The full URI (in the format /<rpcpackage>.<ServiceName>/MethodName, for
   * example /lnrpc.Lightning/GetInfo) of the RPC method the message was sent
   * to/from.
   *
   * @generated from field: string method_full_uri = 1;
   */
  methodFullUri: string;

  /**
   * 
   * Indicates whether the message was sent over a streaming RPC method or not.
   *
   * @generated from field: bool stream_rpc = 2;
   */
  streamRpc: boolean;

  /**
   * 
   * The full canonical gRPC name of the message type (in the format
   * <rpcpackage>.TypeName, for example lnrpc.GetInfoRequest). In case of an
   * error being returned from lnd, this simply contains the string "error".
   *
   * @generated from field: string type_name = 3;
   */
  typeName: string;

  /**
   * 
   * The full content of the gRPC message, serialized in the binary protobuf
   * format.
   *
   * @generated from field: bytes serialized = 4;
   */
  serialized: Uint8Array;

  /**
   * 
   * Indicates that the response from lnd was an error, not a gRPC response. If
   * this is set to true then the type_name contains the string "error" and
   * serialized contains the error string.
   *
   * @generated from field: bool is_error = 5;
   */
  isError: boolean;
};

/**
 * Describes the message lnrpc.RPCMessage.
 * Use `create(RPCMessageSchema)` to create a new message.
 */
export const RPCMessageSchema: GenMessage<RPCMessage> = /*@__PURE__*/
  messageDesc(file_lightning, 188);

/**
 * @generated from message lnrpc.RPCMiddlewareResponse
 */
export type RPCMiddlewareResponse = Message<"lnrpc.RPCMiddlewareResponse"> & {
  /**
   * 
   * The request message ID this response refers to. Must always be set when
   * giving feedback to an intercept but is ignored for the initial registration
   * message.
   *
   * @generated from field: uint64 ref_msg_id = 1;
   */
  refMsgId: bigint;

  /**
   * 
   * The middleware can only send two types of messages to lnd: The initial
   * registration message that identifies the middleware and after that only
   * feedback messages to requests sent to the middleware.
   *
   * @generated from oneof lnrpc.RPCMiddlewareResponse.middleware_message
   */
  middlewareMessage: {
    /**
     * 
     * The registration message identifies the middleware that's being
     * registered in lnd. The registration message must be sent immediately
     * after initiating the RegisterRpcMiddleware stream, otherwise lnd will
     * time out the attempt and terminate the request. NOTE: The middleware
     * will only receive interception messages for requests that contain a
     * macaroon with the custom caveat that the middleware declares it is
     * responsible for handling in the registration message! As a security
     * measure, _no_ middleware can intercept requests made with _unencumbered_
     * macaroons!
     *
     * @generated from field: lnrpc.MiddlewareRegistration register = 2;
     */
    value: MiddlewareRegistration;
    case: "register";
  } | {
    /**
     * 
     * The middleware received an interception request and gives feedback to
     * it. The request_id indicates what message the feedback refers to.
     *
     * @generated from field: lnrpc.InterceptFeedback feedback = 3;
     */
    value: InterceptFeedback;
    case: "feedback";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message lnrpc.RPCMiddlewareResponse.
 * Use `create(RPCMiddlewareResponseSchema)` to create a new message.
 */
export const RPCMiddlewareResponseSchema: GenMessage<RPCMiddlewareResponse> = /*@__PURE__*/
  messageDesc(file_lightning, 189);

/**
 * @generated from message lnrpc.MiddlewareRegistration
 */
export type MiddlewareRegistration = Message<"lnrpc.MiddlewareRegistration"> & {
  /**
   * 
   * The name of the middleware to register. The name should be as informative
   * as possible and is logged on registration.
   *
   * @generated from field: string middleware_name = 1;
   */
  middlewareName: string;

  /**
   * 
   * The name of the custom macaroon caveat that this middleware is responsible
   * for. Only requests/responses that contain a macaroon with the registered
   * custom caveat are forwarded for interception to the middleware. The
   * exception being the read-only mode: All requests/responses are forwarded to
   * a middleware that requests read-only access but such a middleware won't be
   * allowed to _alter_ responses. As a security measure, _no_ middleware can
   * change responses to requests made with _unencumbered_ macaroons!
   * NOTE: Cannot be used at the same time as read_only_mode.
   *
   * @generated from field: string custom_macaroon_caveat_name = 2;
   */
  customMacaroonCaveatName: string;

  /**
   * 
   * Instead of defining a custom macaroon caveat name a middleware can register
   * itself for read-only access only. In that mode all requests/responses are
   * forwarded to the middleware but the middleware isn't allowed to alter any of
   * the responses.
   * NOTE: Cannot be used at the same time as custom_macaroon_caveat_name.
   *
   * @generated from field: bool read_only_mode = 3;
   */
  readOnlyMode: boolean;
};

/**
 * Describes the message lnrpc.MiddlewareRegistration.
 * Use `create(MiddlewareRegistrationSchema)` to create a new message.
 */
export const MiddlewareRegistrationSchema: GenMessage<MiddlewareRegistration> = /*@__PURE__*/
  messageDesc(file_lightning, 190);

/**
 * @generated from message lnrpc.InterceptFeedback
 */
export type InterceptFeedback = Message<"lnrpc.InterceptFeedback"> & {
  /**
   * 
   * The error to return to the user. If this is non-empty, the incoming gRPC
   * stream/request is aborted and the error is returned to the gRPC client. If
   * this value is empty, it means the middleware accepts the stream/request/
   * response and the processing of it can continue.
   *
   * @generated from field: string error = 1;
   */
  error: string;

  /**
   * 
   * A boolean indicating that the gRPC message should be replaced/overwritten.
   * This boolean is needed because in protobuf an empty message is serialized as
   * a 0-length or nil byte slice and we wouldn't be able to distinguish between
   * an empty replacement message and the "don't replace anything" case.
   *
   * @generated from field: bool replace_response = 2;
   */
  replaceResponse: boolean;

  /**
   * 
   * If the replace_response field is set to true, this field must contain the
   * binary serialized gRPC message in the protobuf format.
   *
   * @generated from field: bytes replacement_serialized = 3;
   */
  replacementSerialized: Uint8Array;
};

/**
 * Describes the message lnrpc.InterceptFeedback.
 * Use `create(InterceptFeedbackSchema)` to create a new message.
 */
export const InterceptFeedbackSchema: GenMessage<InterceptFeedback> = /*@__PURE__*/
  messageDesc(file_lightning, 191);

/**
 * @generated from enum lnrpc.OutputScriptType
 */
export enum OutputScriptType {
  /**
   * @generated from enum value: SCRIPT_TYPE_PUBKEY_HASH = 0;
   */
  SCRIPT_TYPE_PUBKEY_HASH = 0,

  /**
   * @generated from enum value: SCRIPT_TYPE_SCRIPT_HASH = 1;
   */
  SCRIPT_TYPE_SCRIPT_HASH = 1,

  /**
   * @generated from enum value: SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2;
   */
  SCRIPT_TYPE_WITNESS_V0_PUBKEY_HASH = 2,

  /**
   * @generated from enum value: SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3;
   */
  SCRIPT_TYPE_WITNESS_V0_SCRIPT_HASH = 3,

  /**
   * @generated from enum value: SCRIPT_TYPE_PUBKEY = 4;
   */
  SCRIPT_TYPE_PUBKEY = 4,

  /**
   * @generated from enum value: SCRIPT_TYPE_MULTISIG = 5;
   */
  SCRIPT_TYPE_MULTISIG = 5,

  /**
   * @generated from enum value: SCRIPT_TYPE_NULLDATA = 6;
   */
  SCRIPT_TYPE_NULLDATA = 6,

  /**
   * @generated from enum value: SCRIPT_TYPE_NON_STANDARD = 7;
   */
  SCRIPT_TYPE_NON_STANDARD = 7,

  /**
   * @generated from enum value: SCRIPT_TYPE_WITNESS_UNKNOWN = 8;
   */
  SCRIPT_TYPE_WITNESS_UNKNOWN = 8,

  /**
   * @generated from enum value: SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9;
   */
  SCRIPT_TYPE_WITNESS_V1_TAPROOT = 9,
}

/**
 * Describes the enum lnrpc.OutputScriptType.
 */
export const OutputScriptTypeSchema: GenEnum<OutputScriptType> = /*@__PURE__*/
  enumDesc(file_lightning, 0);

/**
 * 
 * `AddressType` has to be one of:
 * 
 * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
 * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
 * - `p2tr`: Pay to taproot pubkey (`TAPROOT_PUBKEY` = 4)
 *
 * @generated from enum lnrpc.AddressType
 */
export enum AddressType {
  /**
   * @generated from enum value: WITNESS_PUBKEY_HASH = 0;
   */
  WITNESS_PUBKEY_HASH = 0,

  /**
   * @generated from enum value: NESTED_PUBKEY_HASH = 1;
   */
  NESTED_PUBKEY_HASH = 1,

  /**
   * @generated from enum value: UNUSED_WITNESS_PUBKEY_HASH = 2;
   */
  UNUSED_WITNESS_PUBKEY_HASH = 2,

  /**
   * @generated from enum value: UNUSED_NESTED_PUBKEY_HASH = 3;
   */
  UNUSED_NESTED_PUBKEY_HASH = 3,

  /**
   * @generated from enum value: TAPROOT_PUBKEY = 4;
   */
  TAPROOT_PUBKEY = 4,

  /**
   * @generated from enum value: UNUSED_TAPROOT_PUBKEY = 5;
   */
  UNUSED_TAPROOT_PUBKEY = 5,
}

/**
 * Describes the enum lnrpc.AddressType.
 */
export const AddressTypeSchema: GenEnum<AddressType> = /*@__PURE__*/
  enumDesc(file_lightning, 1);

/**
 * @generated from enum lnrpc.CommitmentType
 */
export enum CommitmentType {
  /**
   * 
   * Returned when the commitment type isn't known or unavailable.
   *
   * @generated from enum value: UNKNOWN_COMMITMENT_TYPE = 0;
   */
  UNKNOWN_COMMITMENT_TYPE = 0,

  /**
   * 
   * A channel using the legacy commitment format having tweaked to_remote
   * keys.
   *
   * @generated from enum value: LEGACY = 1;
   */
  LEGACY = 1,

  /**
   * 
   * A channel that uses the modern commitment format where the key in the
   * output of the remote party does not change each state. This makes back
   * up and recovery easier as when the channel is closed, the funds go
   * directly to that key.
   *
   * @generated from enum value: STATIC_REMOTE_KEY = 2;
   */
  STATIC_REMOTE_KEY = 2,

  /**
   * 
   * A channel that uses a commitment format that has anchor outputs on the
   * commitments, allowing fee bumping after a force close transaction has
   * been broadcast.
   *
   * @generated from enum value: ANCHORS = 3;
   */
  ANCHORS = 3,

  /**
   * 
   * A channel that uses a commitment type that builds upon the anchors
   * commitment format, but in addition requires a CLTV clause to spend outputs
   * paying to the channel initiator. This is intended for use on leased channels
   * to guarantee that the channel initiator has no incentives to close a leased
   * channel before its maturity date.
   *
   * @generated from enum value: SCRIPT_ENFORCED_LEASE = 4;
   */
  SCRIPT_ENFORCED_LEASE = 4,

  /**
   * TODO(roasbeef): need script enforce mirror type for the above as well?
   *
   * @generated from enum value: SIMPLE_TAPROOT = 5;
   */
  SIMPLE_TAPROOT = 5,
}

/**
 * Describes the enum lnrpc.CommitmentType.
 */
export const CommitmentTypeSchema: GenEnum<CommitmentType> = /*@__PURE__*/
  enumDesc(file_lightning, 2);

/**
 * @generated from enum lnrpc.Initiator
 */
export enum Initiator {
  /**
   * @generated from enum value: INITIATOR_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: INITIATOR_LOCAL = 1;
   */
  LOCAL = 1,

  /**
   * @generated from enum value: INITIATOR_REMOTE = 2;
   */
  REMOTE = 2,

  /**
   * @generated from enum value: INITIATOR_BOTH = 3;
   */
  BOTH = 3,
}

/**
 * Describes the enum lnrpc.Initiator.
 */
export const InitiatorSchema: GenEnum<Initiator> = /*@__PURE__*/
  enumDesc(file_lightning, 3);

/**
 * @generated from enum lnrpc.ResolutionType
 */
export enum ResolutionType {
  /**
   * @generated from enum value: TYPE_UNKNOWN = 0;
   */
  TYPE_UNKNOWN = 0,

  /**
   * We resolved an anchor output.
   *
   * @generated from enum value: ANCHOR = 1;
   */
  ANCHOR = 1,

  /**
   * 
   * We are resolving an incoming htlc on chain. This if this htlc is
   * claimed, we swept the incoming htlc with the preimage. If it is timed
   * out, our peer swept the timeout path.
   *
   * @generated from enum value: INCOMING_HTLC = 2;
   */
  INCOMING_HTLC = 2,

  /**
   * 
   * We are resolving an outgoing htlc on chain. If this htlc is claimed,
   * the remote party swept the htlc with the preimage. If it is timed out,
   * we swept it with the timeout path.
   *
   * @generated from enum value: OUTGOING_HTLC = 3;
   */
  OUTGOING_HTLC = 3,

  /**
   * We force closed and need to sweep our time locked commitment output.
   *
   * @generated from enum value: COMMIT = 4;
   */
  COMMIT = 4,
}

/**
 * Describes the enum lnrpc.ResolutionType.
 */
export const ResolutionTypeSchema: GenEnum<ResolutionType> = /*@__PURE__*/
  enumDesc(file_lightning, 4);

/**
 * @generated from enum lnrpc.ResolutionOutcome
 */
export enum ResolutionOutcome {
  /**
   * Outcome unknown.
   *
   * @generated from enum value: OUTCOME_UNKNOWN = 0;
   */
  OUTCOME_UNKNOWN = 0,

  /**
   * An output was claimed on chain.
   *
   * @generated from enum value: CLAIMED = 1;
   */
  CLAIMED = 1,

  /**
   * An output was left unclaimed on chain.
   *
   * @generated from enum value: UNCLAIMED = 2;
   */
  UNCLAIMED = 2,

  /**
   * 
   * ResolverOutcomeAbandoned indicates that an output that we did not
   * claim on chain, for example an anchor that we did not sweep and a
   * third party claimed on chain, or a htlc that we could not decode
   * so left unclaimed.
   *
   * @generated from enum value: ABANDONED = 3;
   */
  ABANDONED = 3,

  /**
   * 
   * If we force closed our channel, our htlcs need to be claimed in two
   * stages. This outcome represents the broadcast of a timeout or success
   * transaction for this two stage htlc claim.
   *
   * @generated from enum value: FIRST_STAGE = 4;
   */
  FIRST_STAGE = 4,

  /**
   * A htlc was timed out on chain.
   *
   * @generated from enum value: TIMEOUT = 5;
   */
  TIMEOUT = 5,
}

/**
 * Describes the enum lnrpc.ResolutionOutcome.
 */
export const ResolutionOutcomeSchema: GenEnum<ResolutionOutcome> = /*@__PURE__*/
  enumDesc(file_lightning, 5);

/**
 * @generated from enum lnrpc.NodeMetricType
 */
export enum NodeMetricType {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: BETWEENNESS_CENTRALITY = 1;
   */
  BETWEENNESS_CENTRALITY = 1,
}

/**
 * Describes the enum lnrpc.NodeMetricType.
 */
export const NodeMetricTypeSchema: GenEnum<NodeMetricType> = /*@__PURE__*/
  enumDesc(file_lightning, 6);

/**
 * @generated from enum lnrpc.InvoiceHTLCState
 */
export enum InvoiceHTLCState {
  /**
   * @generated from enum value: ACCEPTED = 0;
   */
  ACCEPTED = 0,

  /**
   * @generated from enum value: SETTLED = 1;
   */
  SETTLED = 1,

  /**
   * @generated from enum value: CANCELED = 2;
   */
  CANCELED = 2,
}

/**
 * Describes the enum lnrpc.InvoiceHTLCState.
 */
export const InvoiceHTLCStateSchema: GenEnum<InvoiceHTLCState> = /*@__PURE__*/
  enumDesc(file_lightning, 7);

/**
 * @generated from enum lnrpc.PaymentFailureReason
 */
export enum PaymentFailureReason {
  /**
   * 
   * Payment isn't failed (yet).
   *
   * @generated from enum value: FAILURE_REASON_NONE = 0;
   */
  FAILURE_REASON_NONE = 0,

  /**
   * 
   * There are more routes to try, but the payment timeout was exceeded.
   *
   * @generated from enum value: FAILURE_REASON_TIMEOUT = 1;
   */
  FAILURE_REASON_TIMEOUT = 1,

  /**
   * 
   * All possible routes were tried and failed permanently. Or were no
   * routes to the destination at all.
   *
   * @generated from enum value: FAILURE_REASON_NO_ROUTE = 2;
   */
  FAILURE_REASON_NO_ROUTE = 2,

  /**
   * 
   * A non-recoverable error has occured.
   *
   * @generated from enum value: FAILURE_REASON_ERROR = 3;
   */
  FAILURE_REASON_ERROR = 3,

  /**
   * 
   * Payment details incorrect (unknown hash, invalid amt or
   * invalid final cltv delta)
   *
   * @generated from enum value: FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4;
   */
  FAILURE_REASON_INCORRECT_PAYMENT_DETAILS = 4,

  /**
   * 
   * Insufficient local balance.
   *
   * @generated from enum value: FAILURE_REASON_INSUFFICIENT_BALANCE = 5;
   */
  FAILURE_REASON_INSUFFICIENT_BALANCE = 5,
}

/**
 * Describes the enum lnrpc.PaymentFailureReason.
 */
export const PaymentFailureReasonSchema: GenEnum<PaymentFailureReason> = /*@__PURE__*/
  enumDesc(file_lightning, 8);

/**
 * @generated from enum lnrpc.FeatureBit
 */
export enum FeatureBit {
  /**
   * @generated from enum value: DATALOSS_PROTECT_REQ = 0;
   */
  DATALOSS_PROTECT_REQ = 0,

  /**
   * @generated from enum value: DATALOSS_PROTECT_OPT = 1;
   */
  DATALOSS_PROTECT_OPT = 1,

  /**
   * @generated from enum value: INITIAL_ROUING_SYNC = 3;
   */
  INITIAL_ROUING_SYNC = 3,

  /**
   * @generated from enum value: UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
   */
  UPFRONT_SHUTDOWN_SCRIPT_REQ = 4,

  /**
   * @generated from enum value: UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
   */
  UPFRONT_SHUTDOWN_SCRIPT_OPT = 5,

  /**
   * @generated from enum value: GOSSIP_QUERIES_REQ = 6;
   */
  GOSSIP_QUERIES_REQ = 6,

  /**
   * @generated from enum value: GOSSIP_QUERIES_OPT = 7;
   */
  GOSSIP_QUERIES_OPT = 7,

  /**
   * @generated from enum value: TLV_ONION_REQ = 8;
   */
  TLV_ONION_REQ = 8,

  /**
   * @generated from enum value: TLV_ONION_OPT = 9;
   */
  TLV_ONION_OPT = 9,

  /**
   * @generated from enum value: EXT_GOSSIP_QUERIES_REQ = 10;
   */
  EXT_GOSSIP_QUERIES_REQ = 10,

  /**
   * @generated from enum value: EXT_GOSSIP_QUERIES_OPT = 11;
   */
  EXT_GOSSIP_QUERIES_OPT = 11,

  /**
   * @generated from enum value: STATIC_REMOTE_KEY_REQ = 12;
   */
  STATIC_REMOTE_KEY_REQ = 12,

  /**
   * @generated from enum value: STATIC_REMOTE_KEY_OPT = 13;
   */
  STATIC_REMOTE_KEY_OPT = 13,

  /**
   * @generated from enum value: PAYMENT_ADDR_REQ = 14;
   */
  PAYMENT_ADDR_REQ = 14,

  /**
   * @generated from enum value: PAYMENT_ADDR_OPT = 15;
   */
  PAYMENT_ADDR_OPT = 15,

  /**
   * @generated from enum value: MPP_REQ = 16;
   */
  MPP_REQ = 16,

  /**
   * @generated from enum value: MPP_OPT = 17;
   */
  MPP_OPT = 17,

  /**
   * @generated from enum value: WUMBO_CHANNELS_REQ = 18;
   */
  WUMBO_CHANNELS_REQ = 18,

  /**
   * @generated from enum value: WUMBO_CHANNELS_OPT = 19;
   */
  WUMBO_CHANNELS_OPT = 19,

  /**
   * @generated from enum value: ANCHORS_REQ = 20;
   */
  ANCHORS_REQ = 20,

  /**
   * @generated from enum value: ANCHORS_OPT = 21;
   */
  ANCHORS_OPT = 21,

  /**
   * @generated from enum value: ANCHORS_ZERO_FEE_HTLC_REQ = 22;
   */
  ANCHORS_ZERO_FEE_HTLC_REQ = 22,

  /**
   * @generated from enum value: ANCHORS_ZERO_FEE_HTLC_OPT = 23;
   */
  ANCHORS_ZERO_FEE_HTLC_OPT = 23,

  /**
   * @generated from enum value: AMP_REQ = 30;
   */
  AMP_REQ = 30,

  /**
   * @generated from enum value: AMP_OPT = 31;
   */
  AMP_OPT = 31,
}

/**
 * Describes the enum lnrpc.FeatureBit.
 */
export const FeatureBitSchema: GenEnum<FeatureBit> = /*@__PURE__*/
  enumDesc(file_lightning, 9);

/**
 * @generated from enum lnrpc.UpdateFailure
 */
export enum UpdateFailure {
  /**
   * @generated from enum value: UPDATE_FAILURE_UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: UPDATE_FAILURE_PENDING = 1;
   */
  PENDING = 1,

  /**
   * @generated from enum value: UPDATE_FAILURE_NOT_FOUND = 2;
   */
  NOT_FOUND = 2,

  /**
   * @generated from enum value: UPDATE_FAILURE_INTERNAL_ERR = 3;
   */
  INTERNAL_ERR = 3,

  /**
   * @generated from enum value: UPDATE_FAILURE_INVALID_PARAMETER = 4;
   */
  INVALID_PARAMETER = 4,
}

/**
 * Describes the enum lnrpc.UpdateFailure.
 */
export const UpdateFailureSchema: GenEnum<UpdateFailure> = /*@__PURE__*/
  enumDesc(file_lightning, 10);

/**
 * Lightning is the main RPC server of the daemon.
 *
 * @generated from service lnrpc.Lightning
 */
export const Lightning: GenService<{
  /**
   * lncli: `walletbalance`
   * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
   * confirmed unspent outputs and all unconfirmed unspent outputs under control
   * of the wallet.
   *
   * @generated from rpc lnrpc.Lightning.WalletBalance
   */
  walletBalance: {
    methodKind: "unary";
    input: typeof WalletBalanceRequestSchema;
    output: typeof WalletBalanceResponseSchema;
  },
  /**
   * lncli: `channelbalance`
   * ChannelBalance returns a report on the total funds across all open channels,
   * categorized in local/remote, pending local/remote and unsettled local/remote
   * balances.
   *
   * @generated from rpc lnrpc.Lightning.ChannelBalance
   */
  channelBalance: {
    methodKind: "unary";
    input: typeof ChannelBalanceRequestSchema;
    output: typeof ChannelBalanceResponseSchema;
  },
  /**
   * lncli: `listchaintxns`
   * GetTransactions returns a list describing all the known transactions
   * relevant to the wallet.
   *
   * @generated from rpc lnrpc.Lightning.GetTransactions
   */
  getTransactions: {
    methodKind: "unary";
    input: typeof GetTransactionsRequestSchema;
    output: typeof TransactionDetailsSchema;
  },
  /**
   * lncli: `estimatefee`
   * EstimateFee asks the chain backend to estimate the fee rate and total fees
   * for a transaction that pays to multiple specified outputs.
   * 
   * When using REST, the `AddrToAmount` map type can be set by appending
   * `&AddrToAmount[<address>]=<amount_to_send>` to the URL. Unfortunately this
   * map type doesn't appear in the REST API documentation because of a bug in
   * the grpc-gateway library.
   *
   * @generated from rpc lnrpc.Lightning.EstimateFee
   */
  estimateFee: {
    methodKind: "unary";
    input: typeof EstimateFeeRequestSchema;
    output: typeof EstimateFeeResponseSchema;
  },
  /**
   * lncli: `sendcoins`
   * SendCoins executes a request to send coins to a particular address. Unlike
   * SendMany, this RPC call only allows creating a single output at a time. If
   * neither target_conf, or sat_per_vbyte are set, then the internal wallet will
   * consult its fee model to determine a fee for the default confirmation
   * target.
   *
   * @generated from rpc lnrpc.Lightning.SendCoins
   */
  sendCoins: {
    methodKind: "unary";
    input: typeof SendCoinsRequestSchema;
    output: typeof SendCoinsResponseSchema;
  },
  /**
   * lncli: `listunspent`
   * Deprecated, use walletrpc.ListUnspent instead.
   * 
   * ListUnspent returns a list of all utxos spendable by the wallet with a
   * number of confirmations between the specified minimum and maximum.
   *
   * @generated from rpc lnrpc.Lightning.ListUnspent
   */
  listUnspent: {
    methodKind: "unary";
    input: typeof ListUnspentRequestSchema;
    output: typeof ListUnspentResponseSchema;
  },
  /**
   * 
   * SubscribeTransactions creates a uni-directional stream from the server to
   * the client in which any newly discovered transactions relevant to the
   * wallet are sent over.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeTransactions
   */
  subscribeTransactions: {
    methodKind: "server_streaming";
    input: typeof GetTransactionsRequestSchema;
    output: typeof TransactionSchema;
  },
  /**
   * lncli: `sendmany`
   * SendMany handles a request for a transaction that creates multiple specified
   * outputs in parallel. If neither target_conf, or sat_per_vbyte are set, then
   * the internal wallet will consult its fee model to determine a fee for the
   * default confirmation target.
   *
   * @generated from rpc lnrpc.Lightning.SendMany
   */
  sendMany: {
    methodKind: "unary";
    input: typeof SendManyRequestSchema;
    output: typeof SendManyResponseSchema;
  },
  /**
   * lncli: `newaddress`
   * NewAddress creates a new address under control of the local wallet.
   *
   * @generated from rpc lnrpc.Lightning.NewAddress
   */
  newAddress: {
    methodKind: "unary";
    input: typeof NewAddressRequestSchema;
    output: typeof NewAddressResponseSchema;
  },
  /**
   * lncli: `signmessage`
   * SignMessage signs a message with this node's private key. The returned
   * signature string is `zbase32` encoded and pubkey recoverable, meaning that
   * only the message digest and signature are needed for verification.
   *
   * @generated from rpc lnrpc.Lightning.SignMessage
   */
  signMessage: {
    methodKind: "unary";
    input: typeof SignMessageRequestSchema;
    output: typeof SignMessageResponseSchema;
  },
  /**
   * lncli: `verifymessage`
   * VerifyMessage verifies a signature over a message and recovers the signer's
   * public key. The signature is only deemed valid if the recovered public key
   * corresponds to a node key in the public Lightning network. The signature
   * must be zbase32 encoded and signed by an active node in the resident node's
   * channel database. In addition to returning the validity of the signature,
   * VerifyMessage also returns the recovered pubkey from the signature.
   *
   * @generated from rpc lnrpc.Lightning.VerifyMessage
   */
  verifyMessage: {
    methodKind: "unary";
    input: typeof VerifyMessageRequestSchema;
    output: typeof VerifyMessageResponseSchema;
  },
  /**
   * lncli: `connect`
   * ConnectPeer attempts to establish a connection to a remote peer. This is at
   * the networking level, and is used for communication between nodes. This is
   * distinct from establishing a channel with a peer.
   *
   * @generated from rpc lnrpc.Lightning.ConnectPeer
   */
  connectPeer: {
    methodKind: "unary";
    input: typeof ConnectPeerRequestSchema;
    output: typeof ConnectPeerResponseSchema;
  },
  /**
   * lncli: `disconnect`
   * DisconnectPeer attempts to disconnect one peer from another identified by a
   * given pubKey. In the case that we currently have a pending or active channel
   * with the target peer, then this action will be not be allowed.
   *
   * @generated from rpc lnrpc.Lightning.DisconnectPeer
   */
  disconnectPeer: {
    methodKind: "unary";
    input: typeof DisconnectPeerRequestSchema;
    output: typeof DisconnectPeerResponseSchema;
  },
  /**
   * lncli: `listpeers`
   * ListPeers returns a verbose listing of all currently active peers.
   *
   * @generated from rpc lnrpc.Lightning.ListPeers
   */
  listPeers: {
    methodKind: "unary";
    input: typeof ListPeersRequestSchema;
    output: typeof ListPeersResponseSchema;
  },
  /**
   * 
   * SubscribePeerEvents creates a uni-directional stream from the server to
   * the client in which any events relevant to the state of peers are sent
   * over. Events include peers going online and offline.
   *
   * @generated from rpc lnrpc.Lightning.SubscribePeerEvents
   */
  subscribePeerEvents: {
    methodKind: "server_streaming";
    input: typeof PeerEventSubscriptionSchema;
    output: typeof PeerEventSchema;
  },
  /**
   * lncli: `getinfo`
   * GetInfo returns general information concerning the lightning node including
   * it's identity pubkey, alias, the chains it is connected to, and information
   * concerning the number of open+pending channels.
   *
   * @generated from rpc lnrpc.Lightning.GetInfo
   */
  getInfo: {
    methodKind: "unary";
    input: typeof GetInfoRequestSchema;
    output: typeof GetInfoResponseSchema;
  },
  /**
   * * lncli: `getrecoveryinfo`
   * GetRecoveryInfo returns information concerning the recovery mode including
   * whether it's in a recovery mode, whether the recovery is finished, and the
   * progress made so far.
   *
   * @generated from rpc lnrpc.Lightning.GetRecoveryInfo
   */
  getRecoveryInfo: {
    methodKind: "unary";
    input: typeof GetRecoveryInfoRequestSchema;
    output: typeof GetRecoveryInfoResponseSchema;
  },
  /**
   * lncli: `pendingchannels`
   * PendingChannels returns a list of all the channels that are currently
   * considered "pending". A channel is pending if it has finished the funding
   * workflow and is waiting for confirmations for the funding txn, or is in the
   * process of closure, either initiated cooperatively or non-cooperatively.
   *
   * @generated from rpc lnrpc.Lightning.PendingChannels
   */
  pendingChannels: {
    methodKind: "unary";
    input: typeof PendingChannelsRequestSchema;
    output: typeof PendingChannelsResponseSchema;
  },
  /**
   * lncli: `listchannels`
   * ListChannels returns a description of all the open channels that this node
   * is a participant in.
   *
   * @generated from rpc lnrpc.Lightning.ListChannels
   */
  listChannels: {
    methodKind: "unary";
    input: typeof ListChannelsRequestSchema;
    output: typeof ListChannelsResponseSchema;
  },
  /**
   * 
   * SubscribeChannelEvents creates a uni-directional stream from the server to
   * the client in which any updates relevant to the state of the channels are
   * sent over. Events include new active channels, inactive channels, and closed
   * channels.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeChannelEvents
   */
  subscribeChannelEvents: {
    methodKind: "server_streaming";
    input: typeof ChannelEventSubscriptionSchema;
    output: typeof ChannelEventUpdateSchema;
  },
  /**
   * lncli: `closedchannels`
   * ClosedChannels returns a description of all the closed channels that
   * this node was a participant in.
   *
   * @generated from rpc lnrpc.Lightning.ClosedChannels
   */
  closedChannels: {
    methodKind: "unary";
    input: typeof ClosedChannelsRequestSchema;
    output: typeof ClosedChannelsResponseSchema;
  },
  /**
   * 
   * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
   * call is meant to be consumed by clients to the REST proxy. As with all
   * other sync calls, all byte slices are intended to be populated as hex
   * encoded strings.
   *
   * @generated from rpc lnrpc.Lightning.OpenChannelSync
   */
  openChannelSync: {
    methodKind: "unary";
    input: typeof OpenChannelRequestSchema;
    output: typeof ChannelPointSchema;
  },
  /**
   * lncli: `openchannel`
   * OpenChannel attempts to open a singly funded channel specified in the
   * request to a remote peer. Users are able to specify a target number of
   * blocks that the funding transaction should be confirmed in, or a manual fee
   * rate to us for the funding transaction. If neither are specified, then a
   * lax block confirmation target is used. Each OpenStatusUpdate will return
   * the pending channel ID of the in-progress channel. Depending on the
   * arguments specified in the OpenChannelRequest, this pending channel ID can
   * then be used to manually progress the channel funding flow.
   *
   * @generated from rpc lnrpc.Lightning.OpenChannel
   */
  openChannel: {
    methodKind: "server_streaming";
    input: typeof OpenChannelRequestSchema;
    output: typeof OpenStatusUpdateSchema;
  },
  /**
   * lncli: `batchopenchannel`
   * BatchOpenChannel attempts to open multiple single-funded channels in a
   * single transaction in an atomic way. This means either all channel open
   * requests succeed at once or all attempts are aborted if any of them fail.
   * This is the safer variant of using PSBTs to manually fund a batch of
   * channels through the OpenChannel RPC.
   *
   * @generated from rpc lnrpc.Lightning.BatchOpenChannel
   */
  batchOpenChannel: {
    methodKind: "unary";
    input: typeof BatchOpenChannelRequestSchema;
    output: typeof BatchOpenChannelResponseSchema;
  },
  /**
   * 
   * FundingStateStep is an advanced funding related call that allows the caller
   * to either execute some preparatory steps for a funding workflow, or
   * manually progress a funding workflow. The primary way a funding flow is
   * identified is via its pending channel ID. As an example, this method can be
   * used to specify that we're expecting a funding flow for a particular
   * pending channel ID, for which we need to use specific parameters.
   * Alternatively, this can be used to interactively drive PSBT signing for
   * funding for partially complete funding transactions.
   *
   * @generated from rpc lnrpc.Lightning.FundingStateStep
   */
  fundingStateStep: {
    methodKind: "unary";
    input: typeof FundingTransitionMsgSchema;
    output: typeof FundingStateStepRespSchema;
  },
  /**
   * 
   * ChannelAcceptor dispatches a bi-directional streaming RPC in which
   * OpenChannel requests are sent to the client and the client responds with
   * a boolean that tells LND whether or not to accept the channel. This allows
   * node operators to specify their own criteria for accepting inbound channels
   * through a single persistent connection.
   *
   * @generated from rpc lnrpc.Lightning.ChannelAcceptor
   */
  channelAcceptor: {
    methodKind: "bidi_streaming";
    input: typeof ChannelAcceptResponseSchema;
    output: typeof ChannelAcceptRequestSchema;
  },
  /**
   * lncli: `closechannel`
   * CloseChannel attempts to close an active channel identified by its channel
   * outpoint (ChannelPoint). The actions of this method can additionally be
   * augmented to attempt a force close after a timeout period in the case of an
   * inactive peer. If a non-force close (cooperative closure) is requested,
   * then the user can specify either a target number of blocks until the
   * closure transaction is confirmed, or a manual fee rate. If neither are
   * specified, then a default lax, block confirmation target is used.
   *
   * @generated from rpc lnrpc.Lightning.CloseChannel
   */
  closeChannel: {
    methodKind: "server_streaming";
    input: typeof CloseChannelRequestSchema;
    output: typeof CloseStatusUpdateSchema;
  },
  /**
   * lncli: `abandonchannel`
   * AbandonChannel removes all channel state from the database except for a
   * close summary. This method can be used to get rid of permanently unusable
   * channels due to bugs fixed in newer versions of lnd. This method can also be
   * used to remove externally funded channels where the funding transaction was
   * never broadcast. Only available for non-externally funded channels in dev
   * build.
   *
   * @generated from rpc lnrpc.Lightning.AbandonChannel
   */
  abandonChannel: {
    methodKind: "unary";
    input: typeof AbandonChannelRequestSchema;
    output: typeof AbandonChannelResponseSchema;
  },
  /**
   * lncli: `sendpayment`
   * Deprecated, use routerrpc.SendPaymentV2. SendPayment dispatches a
   * bi-directional streaming RPC for sending payments through the Lightning
   * Network. A single RPC invocation creates a persistent bi-directional
   * stream allowing clients to rapidly send payments through the Lightning
   * Network with a single persistent connection.
   *
   * @generated from rpc lnrpc.Lightning.SendPayment
   * @deprecated
   */
  sendPayment: {
    methodKind: "bidi_streaming";
    input: typeof SendRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * 
   * SendPaymentSync is the synchronous non-streaming version of SendPayment.
   * This RPC is intended to be consumed by clients of the REST proxy.
   * Additionally, this RPC expects the destination's public key and the payment
   * hash (if any) to be encoded as hex strings.
   *
   * @generated from rpc lnrpc.Lightning.SendPaymentSync
   */
  sendPaymentSync: {
    methodKind: "unary";
    input: typeof SendRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * lncli: `sendtoroute`
   * Deprecated, use routerrpc.SendToRouteV2. SendToRoute is a bi-directional
   * streaming RPC for sending payment through the Lightning Network. This
   * method differs from SendPayment in that it allows users to specify a full
   * route manually. This can be used for things like rebalancing, and atomic
   * swaps.
   *
   * @generated from rpc lnrpc.Lightning.SendToRoute
   * @deprecated
   */
  sendToRoute: {
    methodKind: "bidi_streaming";
    input: typeof SendToRouteRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * 
   * SendToRouteSync is a synchronous version of SendToRoute. It Will block
   * until the payment either fails or succeeds.
   *
   * @generated from rpc lnrpc.Lightning.SendToRouteSync
   */
  sendToRouteSync: {
    methodKind: "unary";
    input: typeof SendToRouteRequestSchema;
    output: typeof SendResponseSchema;
  },
  /**
   * lncli: `addinvoice`
   * AddInvoice attempts to add a new invoice to the invoice database. Any
   * duplicated invoices are rejected, therefore all invoices *must* have a
   * unique payment preimage.
   *
   * @generated from rpc lnrpc.Lightning.AddInvoice
   */
  addInvoice: {
    methodKind: "unary";
    input: typeof InvoiceSchema;
    output: typeof AddInvoiceResponseSchema;
  },
  /**
   * lncli: `listinvoices`
   * ListInvoices returns a list of all the invoices currently stored within the
   * database. Any active debug invoices are ignored. It has full support for
   * paginated responses, allowing users to query for specific invoices through
   * their add_index. This can be done by using either the first_index_offset or
   * last_index_offset fields included in the response as the index_offset of the
   * next request. By default, the first 100 invoices created will be returned.
   * Backwards pagination is also supported through the Reversed flag.
   *
   * @generated from rpc lnrpc.Lightning.ListInvoices
   */
  listInvoices: {
    methodKind: "unary";
    input: typeof ListInvoiceRequestSchema;
    output: typeof ListInvoiceResponseSchema;
  },
  /**
   * lncli: `lookupinvoice`
   * LookupInvoice attempts to look up an invoice according to its payment hash.
   * The passed payment hash *must* be exactly 32 bytes, if not, an error is
   * returned.
   *
   * @generated from rpc lnrpc.Lightning.LookupInvoice
   */
  lookupInvoice: {
    methodKind: "unary";
    input: typeof PaymentHashSchema;
    output: typeof InvoiceSchema;
  },
  /**
   * 
   * SubscribeInvoices returns a uni-directional stream (server -> client) for
   * notifying the client of newly added/settled invoices. The caller can
   * optionally specify the add_index and/or the settle_index. If the add_index
   * is specified, then we'll first start by sending add invoice events for all
   * invoices with an add_index greater than the specified value. If the
   * settle_index is specified, the next, we'll send out all settle events for
   * invoices with a settle_index greater than the specified value. One or both
   * of these fields can be set. If no fields are set, then we'll only send out
   * the latest add/settle events.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeInvoices
   */
  subscribeInvoices: {
    methodKind: "server_streaming";
    input: typeof InvoiceSubscriptionSchema;
    output: typeof InvoiceSchema;
  },
  /**
   * lncli: `decodepayreq`
   * DecodePayReq takes an encoded payment request string and attempts to decode
   * it, returning a full description of the conditions encoded within the
   * payment request.
   *
   * @generated from rpc lnrpc.Lightning.DecodePayReq
   */
  decodePayReq: {
    methodKind: "unary";
    input: typeof PayReqStringSchema;
    output: typeof PayReqSchema;
  },
  /**
   * lncli: `listpayments`
   * ListPayments returns a list of all outgoing payments.
   *
   * @generated from rpc lnrpc.Lightning.ListPayments
   */
  listPayments: {
    methodKind: "unary";
    input: typeof ListPaymentsRequestSchema;
    output: typeof ListPaymentsResponseSchema;
  },
  /**
   * 
   * DeletePayment deletes an outgoing payment from DB. Note that it will not
   * attempt to delete an In-Flight payment, since that would be unsafe.
   *
   * @generated from rpc lnrpc.Lightning.DeletePayment
   */
  deletePayment: {
    methodKind: "unary";
    input: typeof DeletePaymentRequestSchema;
    output: typeof DeletePaymentResponseSchema;
  },
  /**
   * 
   * DeleteAllPayments deletes all outgoing payments from DB. Note that it will
   * not attempt to delete In-Flight payments, since that would be unsafe.
   *
   * @generated from rpc lnrpc.Lightning.DeleteAllPayments
   */
  deleteAllPayments: {
    methodKind: "unary";
    input: typeof DeleteAllPaymentsRequestSchema;
    output: typeof DeleteAllPaymentsResponseSchema;
  },
  /**
   * lncli: `describegraph`
   * DescribeGraph returns a description of the latest graph state from the
   * point of view of the node. The graph information is partitioned into two
   * components: all the nodes/vertexes, and all the edges that connect the
   * vertexes themselves. As this is a directed graph, the edges also contain
   * the node directional specific routing policy which includes: the time lock
   * delta, fee information, etc.
   *
   * @generated from rpc lnrpc.Lightning.DescribeGraph
   */
  describeGraph: {
    methodKind: "unary";
    input: typeof ChannelGraphRequestSchema;
    output: typeof ChannelGraphSchema;
  },
  /**
   * lncli: `getnodemetrics`
   * GetNodeMetrics returns node metrics calculated from the graph. Currently
   * the only supported metric is betweenness centrality of individual nodes.
   *
   * @generated from rpc lnrpc.Lightning.GetNodeMetrics
   */
  getNodeMetrics: {
    methodKind: "unary";
    input: typeof NodeMetricsRequestSchema;
    output: typeof NodeMetricsResponseSchema;
  },
  /**
   * lncli: `getchaninfo`
   * GetChanInfo returns the latest authenticated network announcement for the
   * given channel identified by its channel ID: an 8-byte integer which
   * uniquely identifies the location of transaction's funding output within the
   * blockchain.
   *
   * @generated from rpc lnrpc.Lightning.GetChanInfo
   */
  getChanInfo: {
    methodKind: "unary";
    input: typeof ChanInfoRequestSchema;
    output: typeof ChannelEdgeSchema;
  },
  /**
   * lncli: `getnodeinfo`
   * GetNodeInfo returns the latest advertised, aggregated, and authenticated
   * channel information for the specified node identified by its public key.
   *
   * @generated from rpc lnrpc.Lightning.GetNodeInfo
   */
  getNodeInfo: {
    methodKind: "unary";
    input: typeof NodeInfoRequestSchema;
    output: typeof NodeInfoSchema;
  },
  /**
   * lncli: `queryroutes`
   * QueryRoutes attempts to query the daemon's Channel Router for a possible
   * route to a target destination capable of carrying a specific amount of
   * satoshis. The returned route contains the full details required to craft and
   * send an HTLC, also including the necessary information that should be
   * present within the Sphinx packet encapsulated within the HTLC.
   * 
   * When using REST, the `dest_custom_records` map type can be set by appending
   * `&dest_custom_records[<record_number>]=<record_data_base64_url_encoded>`
   * to the URL. Unfortunately this map type doesn't appear in the REST API
   * documentation because of a bug in the grpc-gateway library.
   *
   * @generated from rpc lnrpc.Lightning.QueryRoutes
   */
  queryRoutes: {
    methodKind: "unary";
    input: typeof QueryRoutesRequestSchema;
    output: typeof QueryRoutesResponseSchema;
  },
  /**
   * lncli: `getnetworkinfo`
   * GetNetworkInfo returns some basic stats about the known channel graph from
   * the point of view of the node.
   *
   * @generated from rpc lnrpc.Lightning.GetNetworkInfo
   */
  getNetworkInfo: {
    methodKind: "unary";
    input: typeof NetworkInfoRequestSchema;
    output: typeof NetworkInfoSchema;
  },
  /**
   * lncli: `stop`
   * StopDaemon will send a shutdown request to the interrupt handler, triggering
   * a graceful shutdown of the daemon.
   *
   * @generated from rpc lnrpc.Lightning.StopDaemon
   */
  stopDaemon: {
    methodKind: "unary";
    input: typeof StopRequestSchema;
    output: typeof StopResponseSchema;
  },
  /**
   * 
   * SubscribeChannelGraph launches a streaming RPC that allows the caller to
   * receive notifications upon any changes to the channel graph topology from
   * the point of view of the responding node. Events notified include: new
   * nodes coming online, nodes updating their authenticated attributes, new
   * channels being advertised, updates in the routing policy for a directional
   * channel edge, and when channels are closed on-chain.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeChannelGraph
   */
  subscribeChannelGraph: {
    methodKind: "server_streaming";
    input: typeof GraphTopologySubscriptionSchema;
    output: typeof GraphTopologyUpdateSchema;
  },
  /**
   * lncli: `debuglevel`
   * DebugLevel allows a caller to programmatically set the logging verbosity of
   * lnd. The logging can be targeted according to a coarse daemon-wide logging
   * level, or in a granular fashion to specify the logging for a target
   * sub-system.
   *
   * @generated from rpc lnrpc.Lightning.DebugLevel
   */
  debugLevel: {
    methodKind: "unary";
    input: typeof DebugLevelRequestSchema;
    output: typeof DebugLevelResponseSchema;
  },
  /**
   * lncli: `feereport`
   * FeeReport allows the caller to obtain a report detailing the current fee
   * schedule enforced by the node globally for each channel.
   *
   * @generated from rpc lnrpc.Lightning.FeeReport
   */
  feeReport: {
    methodKind: "unary";
    input: typeof FeeReportRequestSchema;
    output: typeof FeeReportResponseSchema;
  },
  /**
   * lncli: `updatechanpolicy`
   * UpdateChannelPolicy allows the caller to update the fee schedule and
   * channel policies for all channels globally, or a particular channel.
   *
   * @generated from rpc lnrpc.Lightning.UpdateChannelPolicy
   */
  updateChannelPolicy: {
    methodKind: "unary";
    input: typeof PolicyUpdateRequestSchema;
    output: typeof PolicyUpdateResponseSchema;
  },
  /**
   * lncli: `fwdinghistory`
   * ForwardingHistory allows the caller to query the htlcswitch for a record of
   * all HTLCs forwarded within the target time range, and integer offset
   * within that time range, for a maximum number of events. If no maximum number
   * of events is specified, up to 100 events will be returned. If no time-range
   * is specified, then events will be returned in the order that they occured.
   * 
   * A list of forwarding events are returned. The size of each forwarding event
   * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
   * As a result each message can only contain 50k entries. Each response has
   * the index offset of the last entry. The index offset can be provided to the
   * request to allow the caller to skip a series of records.
   *
   * @generated from rpc lnrpc.Lightning.ForwardingHistory
   */
  forwardingHistory: {
    methodKind: "unary";
    input: typeof ForwardingHistoryRequestSchema;
    output: typeof ForwardingHistoryResponseSchema;
  },
  /**
   * lncli: `exportchanbackup`
   * ExportChannelBackup attempts to return an encrypted static channel backup
   * for the target channel identified by it channel point. The backup is
   * encrypted with a key generated from the aezeed seed of the user. The
   * returned backup can either be restored using the RestoreChannelBackup
   * method once lnd is running, or via the InitWallet and UnlockWallet methods
   * from the WalletUnlocker service.
   *
   * @generated from rpc lnrpc.Lightning.ExportChannelBackup
   */
  exportChannelBackup: {
    methodKind: "unary";
    input: typeof ExportChannelBackupRequestSchema;
    output: typeof ChannelBackupSchema;
  },
  /**
   * 
   * ExportAllChannelBackups returns static channel backups for all existing
   * channels known to lnd. A set of regular singular static channel backups for
   * each channel are returned. Additionally, a multi-channel backup is returned
   * as well, which contains a single encrypted blob containing the backups of
   * each channel.
   *
   * @generated from rpc lnrpc.Lightning.ExportAllChannelBackups
   */
  exportAllChannelBackups: {
    methodKind: "unary";
    input: typeof ChanBackupExportRequestSchema;
    output: typeof ChanBackupSnapshotSchema;
  },
  /**
   * 
   * VerifyChanBackup allows a caller to verify the integrity of a channel backup
   * snapshot. This method will accept either a packed Single or a packed Multi.
   * Specifying both will result in an error.
   *
   * @generated from rpc lnrpc.Lightning.VerifyChanBackup
   */
  verifyChanBackup: {
    methodKind: "unary";
    input: typeof ChanBackupSnapshotSchema;
    output: typeof VerifyChanBackupResponseSchema;
  },
  /**
   * lncli: `restorechanbackup`
   * RestoreChannelBackups accepts a set of singular channel backups, or a
   * single encrypted multi-chan backup and attempts to recover any funds
   * remaining within the channel. If we are able to unpack the backup, then the
   * new channel will be shown under listchannels, as well as pending channels.
   *
   * @generated from rpc lnrpc.Lightning.RestoreChannelBackups
   */
  restoreChannelBackups: {
    methodKind: "unary";
    input: typeof RestoreChanBackupRequestSchema;
    output: typeof RestoreBackupResponseSchema;
  },
  /**
   * 
   * SubscribeChannelBackups allows a client to sub-subscribe to the most up to
   * date information concerning the state of all channel backups. Each time a
   * new channel is added, we return the new set of channels, along with a
   * multi-chan backup containing the backup info for all channels. Each time a
   * channel is closed, we send a new update, which contains new new chan back
   * ups, but the updated set of encrypted multi-chan backups with the closed
   * channel(s) removed.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeChannelBackups
   */
  subscribeChannelBackups: {
    methodKind: "server_streaming";
    input: typeof ChannelBackupSubscriptionSchema;
    output: typeof ChanBackupSnapshotSchema;
  },
  /**
   * lncli: `bakemacaroon`
   * BakeMacaroon allows the creation of a new macaroon with custom read and
   * write permissions. No first-party caveats are added since this can be done
   * offline.
   *
   * @generated from rpc lnrpc.Lightning.BakeMacaroon
   */
  bakeMacaroon: {
    methodKind: "unary";
    input: typeof BakeMacaroonRequestSchema;
    output: typeof BakeMacaroonResponseSchema;
  },
  /**
   * lncli: `listmacaroonids`
   * ListMacaroonIDs returns all root key IDs that are in use.
   *
   * @generated from rpc lnrpc.Lightning.ListMacaroonIDs
   */
  listMacaroonIDs: {
    methodKind: "unary";
    input: typeof ListMacaroonIDsRequestSchema;
    output: typeof ListMacaroonIDsResponseSchema;
  },
  /**
   * lncli: `deletemacaroonid`
   * DeleteMacaroonID deletes the specified macaroon ID and invalidates all
   * macaroons derived from that ID.
   *
   * @generated from rpc lnrpc.Lightning.DeleteMacaroonID
   */
  deleteMacaroonID: {
    methodKind: "unary";
    input: typeof DeleteMacaroonIDRequestSchema;
    output: typeof DeleteMacaroonIDResponseSchema;
  },
  /**
   * lncli: `listpermissions`
   * ListPermissions lists all RPC method URIs and their required macaroon
   * permissions to access them.
   *
   * @generated from rpc lnrpc.Lightning.ListPermissions
   */
  listPermissions: {
    methodKind: "unary";
    input: typeof ListPermissionsRequestSchema;
    output: typeof ListPermissionsResponseSchema;
  },
  /**
   * 
   * CheckMacaroonPermissions checks whether a request follows the constraints
   * imposed on the macaroon and that the macaroon is authorized to follow the
   * provided permissions.
   *
   * @generated from rpc lnrpc.Lightning.CheckMacaroonPermissions
   */
  checkMacaroonPermissions: {
    methodKind: "unary";
    input: typeof CheckMacPermRequestSchema;
    output: typeof CheckMacPermResponseSchema;
  },
  /**
   * 
   * RegisterRPCMiddleware adds a new gRPC middleware to the interceptor chain. A
   * gRPC middleware is software component external to lnd that aims to add
   * additional business logic to lnd by observing/intercepting/validating
   * incoming gRPC client requests and (if needed) replacing/overwriting outgoing
   * messages before they're sent to the client. When registering the middleware
   * must identify itself and indicate what custom macaroon caveats it wants to
   * be responsible for. Only requests that contain a macaroon with that specific
   * custom caveat are then sent to the middleware for inspection. The other
   * option is to register for the read-only mode in which all requests/responses
   * are forwarded for interception to the middleware but the middleware is not
   * allowed to modify any responses. As a security measure, _no_ middleware can
   * modify responses for requests made with _unencumbered_ macaroons!
   *
   * @generated from rpc lnrpc.Lightning.RegisterRPCMiddleware
   */
  registerRPCMiddleware: {
    methodKind: "bidi_streaming";
    input: typeof RPCMiddlewareResponseSchema;
    output: typeof RPCMiddlewareRequestSchema;
  },
  /**
   * lncli: `sendcustom`
   * SendCustomMessage sends a custom peer message.
   *
   * @generated from rpc lnrpc.Lightning.SendCustomMessage
   */
  sendCustomMessage: {
    methodKind: "unary";
    input: typeof SendCustomMessageRequestSchema;
    output: typeof SendCustomMessageResponseSchema;
  },
  /**
   * lncli: `subscribecustom`
   * SubscribeCustomMessages subscribes to a stream of incoming custom peer
   * messages.
   * 
   * To include messages with type outside of the custom range (>= 32768) lnd
   * needs to be compiled with  the `dev` build tag, and the message type to
   * override should be specified in lnd's experimental protocol configuration.
   *
   * @generated from rpc lnrpc.Lightning.SubscribeCustomMessages
   */
  subscribeCustomMessages: {
    methodKind: "server_streaming";
    input: typeof SubscribeCustomMessagesRequestSchema;
    output: typeof CustomMessageSchema;
  },
  /**
   * lncli: `listaliases`
   * ListAliases returns the set of all aliases that have ever existed with
   * their confirmed SCID (if it exists) and/or the base SCID (in the case of
   * zero conf).
   *
   * @generated from rpc lnrpc.Lightning.ListAliases
   */
  listAliases: {
    methodKind: "unary";
    input: typeof ListAliasesRequestSchema;
    output: typeof ListAliasesResponseSchema;
  },
  /**
   * 
   * LookupHtlcResolution retrieves a final htlc resolution from the database.
   * If the htlc has no final resolution yet, a NotFound grpc status code is
   * returned.
   *
   * @generated from rpc lnrpc.Lightning.LookupHtlcResolution
   */
  lookupHtlcResolution: {
    methodKind: "unary";
    input: typeof LookupHtlcResolutionRequestSchema;
    output: typeof LookupHtlcResolutionResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_lightning, 0);





// Merged from walletunlocker_pb.ts
export const file_walletunlocker: GenFile = /*@__PURE__*/
  fileDesc("ChR3YWxsZXR1bmxvY2tlci5wcm90bxIFbG5ycGMiQQoOR2VuU2VlZFJlcXVlc3QSGQoRYWV6ZWVkX3Bhc3NwaHJhc2UYASABKAwSFAoMc2VlZF9lbnRyb3B5GAIgASgMIkgKD0dlblNlZWRSZXNwb25zZRIcChRjaXBoZXJfc2VlZF9tbmVtb25pYxgBIAMoCRIXCg9lbmNpcGhlcmVkX3NlZWQYAiABKAwi2AIKEUluaXRXYWxsZXRSZXF1ZXN0EhcKD3dhbGxldF9wYXNzd29yZBgBIAEoDBIcChRjaXBoZXJfc2VlZF9tbmVtb25pYxgCIAMoCRIZChFhZXplZWRfcGFzc3BocmFzZRgDIAEoDBIXCg9yZWNvdmVyeV93aW5kb3cYBCABKAUSMgoPY2hhbm5lbF9iYWNrdXBzGAUgASgLMhkubG5ycGMuQ2hhbkJhY2t1cFNuYXBzaG90EhYKDnN0YXRlbGVzc19pbml0GAYgASgIEhsKE2V4dGVuZGVkX21hc3Rlcl9rZXkYByABKAkSLgomZXh0ZW5kZWRfbWFzdGVyX2tleV9iaXJ0aGRheV90aW1lc3RhbXAYCCABKAQSJAoKd2F0Y2hfb25seRgJIAEoCzIQLmxucnBjLldhdGNoT25seRIZChFtYWNhcm9vbl9yb290X2tleRgKIAEoDCIsChJJbml0V2FsbGV0UmVzcG9uc2USFgoOYWRtaW5fbWFjYXJvb24YASABKAwifQoJV2F0Y2hPbmx5EiUKHW1hc3Rlcl9rZXlfYmlydGhkYXlfdGltZXN0YW1wGAEgASgEEh4KFm1hc3Rlcl9rZXlfZmluZ2VycHJpbnQYAiABKAwSKQoIYWNjb3VudHMYAyADKAsyFy5sbnJwYy5XYXRjaE9ubHlBY2NvdW50IlUKEFdhdGNoT25seUFjY291bnQSDwoHcHVycG9zZRgBIAEoDRIRCgljb2luX3R5cGUYAiABKA0SDwoHYWNjb3VudBgDIAEoDRIMCgR4cHViGAQgASgJIpMBChNVbmxvY2tXYWxsZXRSZXF1ZXN0EhcKD3dhbGxldF9wYXNzd29yZBgBIAEoDBIXCg9yZWNvdmVyeV93aW5kb3cYAiABKAUSMgoPY2hhbm5lbF9iYWNrdXBzGAMgASgLMhkubG5ycGMuQ2hhbkJhY2t1cFNuYXBzaG90EhYKDnN0YXRlbGVzc19pbml0GAQgASgIIhYKFFVubG9ja1dhbGxldFJlc3BvbnNlIn4KFUNoYW5nZVBhc3N3b3JkUmVxdWVzdBIYChBjdXJyZW50X3Bhc3N3b3JkGAEgASgMEhQKDG5ld19wYXNzd29yZBgCIAEoDBIWCg5zdGF0ZWxlc3NfaW5pdBgDIAEoCBIdChVuZXdfbWFjYXJvb25fcm9vdF9rZXkYBCABKAgiMAoWQ2hhbmdlUGFzc3dvcmRSZXNwb25zZRIWCg5hZG1pbl9tYWNhcm9vbhgBIAEoDDKlAgoOV2FsbGV0VW5sb2NrZXISOAoHR2VuU2VlZBIVLmxucnBjLkdlblNlZWRSZXF1ZXN0GhYubG5ycGMuR2VuU2VlZFJlc3BvbnNlEkEKCkluaXRXYWxsZXQSGC5sbnJwYy5Jbml0V2FsbGV0UmVxdWVzdBoZLmxucnBjLkluaXRXYWxsZXRSZXNwb25zZRJHCgxVbmxvY2tXYWxsZXQSGi5sbnJwYy5VbmxvY2tXYWxsZXRSZXF1ZXN0GhsubG5ycGMuVW5sb2NrV2FsbGV0UmVzcG9uc2USTQoOQ2hhbmdlUGFzc3dvcmQSHC5sbnJwYy5DaGFuZ2VQYXNzd29yZFJlcXVlc3QaHS5sbnJwYy5DaGFuZ2VQYXNzd29yZFJlc3BvbnNlQidaJWdpdGh1Yi5jb20vbGlnaHRuaW5nbmV0d29yay9sbmQvbG5ycGNiBnByb3RvMw", [file_lightning]);

/**
 * @generated from message lnrpc.GenSeedRequest
 */
export type GenSeedRequest = Message<"lnrpc.GenSeedRequest"> & {
  /**
   * 
   * aezeed_passphrase is an optional user provided passphrase that will be used
   * to encrypt the generated aezeed cipher seed. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes aezeed_passphrase = 1;
   */
  aezeedPassphrase: Uint8Array;

  /**
   * 
   * seed_entropy is an optional 16-bytes generated via CSPRNG. If not
   * specified, then a fresh set of randomness will be used to create the seed.
   * When using REST, this field must be encoded as base64.
   *
   * @generated from field: bytes seed_entropy = 2;
   */
  seedEntropy: Uint8Array;
};

/**
 * Describes the message lnrpc.GenSeedRequest.
 * Use `create(GenSeedRequestSchema)` to create a new message.
 */
export const GenSeedRequestSchema: GenMessage<GenSeedRequest> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 0);

/**
 * @generated from message lnrpc.GenSeedResponse
 */
export type GenSeedResponse = Message<"lnrpc.GenSeedResponse"> & {
  /**
   * 
   * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
   * cipher seed obtained by the user. This field is optional, as if not
   * provided, then the daemon will generate a new cipher seed for the user.
   * Otherwise, then the daemon will attempt to recover the wallet state linked
   * to this cipher seed.
   *
   * @generated from field: repeated string cipher_seed_mnemonic = 1;
   */
  cipherSeedMnemonic: string[];

  /**
   * 
   * enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
   * cipher text before run through our mnemonic encoding scheme.
   *
   * @generated from field: bytes enciphered_seed = 2;
   */
  encipheredSeed: Uint8Array;
};

/**
 * Describes the message lnrpc.GenSeedResponse.
 * Use `create(GenSeedResponseSchema)` to create a new message.
 */
export const GenSeedResponseSchema: GenMessage<GenSeedResponse> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 1);

/**
 * @generated from message lnrpc.InitWalletRequest
 */
export type InitWalletRequest = Message<"lnrpc.InitWalletRequest"> & {
  /**
   * 
   * wallet_password is the passphrase that should be used to encrypt the
   * wallet. This MUST be at least 8 chars in length. After creation, this
   * password is required to unlock the daemon. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes wallet_password = 1;
   */
  walletPassword: Uint8Array;

  /**
   * 
   * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
   * cipher seed obtained by the user. This may have been generated by the
   * GenSeed method, or be an existing seed.
   *
   * @generated from field: repeated string cipher_seed_mnemonic = 2;
   */
  cipherSeedMnemonic: string[];

  /**
   * 
   * aezeed_passphrase is an optional user provided passphrase that will be used
   * to encrypt the generated aezeed cipher seed. When using REST, this field
   * must be encoded as base64.
   *
   * @generated from field: bytes aezeed_passphrase = 3;
   */
  aezeedPassphrase: Uint8Array;

  /**
   * 
   * recovery_window is an optional argument specifying the address lookahead
   * when restoring a wallet seed. The recovery window applies to each
   * individual branch of the BIP44 derivation paths. Supplying a recovery
   * window of zero indicates that no addresses should be recovered, such after
   * the first initialization of the wallet.
   *
   * @generated from field: int32 recovery_window = 4;
   */
  recoveryWindow: number;

  /**
   * 
   * channel_backups is an optional argument that allows clients to recover the
   * settled funds within a set of channels. This should be populated if the
   * user was unable to close out all channels and sweep funds before partial or
   * total data loss occurred. If specified, then after on-chain recovery of
   * funds, lnd begin to carry out the data loss recovery protocol in order to
   * recover the funds in each channel from a remote force closed transaction.
   *
   * @generated from field: lnrpc.ChanBackupSnapshot channel_backups = 5;
   */
  channelBackups?: ChanBackupSnapshot;

  /**
   * 
   * stateless_init is an optional argument instructing the daemon NOT to create
   * any *.macaroon files in its filesystem. If this parameter is set, then the
   * admin macaroon returned in the response MUST be stored by the caller of the
   * RPC as otherwise all access to the daemon will be lost!
   *
   * @generated from field: bool stateless_init = 6;
   */
  statelessInit: boolean;

  /**
   * 
   * extended_master_key is an alternative to specifying cipher_seed_mnemonic and
   * aezeed_passphrase. Instead of deriving the master root key from the entropy
   * of an aezeed cipher seed, the given extended master root key is used
   * directly as the wallet's master key. This allows users to import/use a
   * master key from another wallet. When doing so, lnd still uses its default
   * SegWit only (BIP49/84) derivation paths and funds from custom/non-default
   * derivation paths will not automatically appear in the on-chain wallet. Using
   * an 'xprv' instead of an aezeed also has the disadvantage that the wallet's
   * birthday is not known as that is an information that's only encoded in the
   * aezeed, not the xprv. Therefore a birthday needs to be specified in
   * extended_master_key_birthday_timestamp or a "safe" default value will be
   * used.
   *
   * @generated from field: string extended_master_key = 7;
   */
  extendedMasterKey: string;

  /**
   * 
   * extended_master_key_birthday_timestamp is the optional unix timestamp in
   * seconds to use as the wallet's birthday when using an extended master key
   * to restore the wallet. lnd will only start scanning for funds in blocks that
   * are after the birthday which can speed up the process significantly. If the
   * birthday is not known, this should be left at its default value of 0 in
   * which case lnd will start scanning from the first SegWit block (481824 on
   * mainnet).
   *
   * @generated from field: uint64 extended_master_key_birthday_timestamp = 8;
   */
  extendedMasterKeyBirthdayTimestamp: bigint;

  /**
   * 
   * watch_only is the third option of initializing a wallet: by importing
   * account xpubs only and therefore creating a watch-only wallet that does not
   * contain any private keys. That means the wallet won't be able to sign for
   * any of the keys and _needs_ to be run with a remote signer that has the
   * corresponding private keys and can serve signing RPC requests.
   *
   * @generated from field: lnrpc.WatchOnly watch_only = 9;
   */
  watchOnly?: WatchOnly;

  /**
   * 
   * macaroon_root_key is an optional 32 byte macaroon root key that can be
   * provided when initializing the wallet rather than letting lnd generate one
   * on its own.
   *
   * @generated from field: bytes macaroon_root_key = 10;
   */
  macaroonRootKey: Uint8Array;
};

/**
 * Describes the message lnrpc.InitWalletRequest.
 * Use `create(InitWalletRequestSchema)` to create a new message.
 */
export const InitWalletRequestSchema: GenMessage<InitWalletRequest> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 2);

/**
 * @generated from message lnrpc.InitWalletResponse
 */
export type InitWalletResponse = Message<"lnrpc.InitWalletResponse"> & {
  /**
   * 
   * The binary serialized admin macaroon that can be used to access the daemon
   * after creating the wallet. If the stateless_init parameter was set to true,
   * this is the ONLY copy of the macaroon and MUST be stored safely by the
   * caller. Otherwise a copy of this macaroon is also persisted on disk by the
   * daemon, together with other macaroon files.
   *
   * @generated from field: bytes admin_macaroon = 1;
   */
  adminMacaroon: Uint8Array;
};

/**
 * Describes the message lnrpc.InitWalletResponse.
 * Use `create(InitWalletResponseSchema)` to create a new message.
 */
export const InitWalletResponseSchema: GenMessage<InitWalletResponse> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 3);

/**
 * @generated from message lnrpc.WatchOnly
 */
export type WatchOnly = Message<"lnrpc.WatchOnly"> & {
  /**
   * 
   * The unix timestamp in seconds of when the master key was created. lnd will
   * only start scanning for funds in blocks that are after the birthday which
   * can speed up the process significantly. If the birthday is not known, this
   * should be left at its default value of 0 in which case lnd will start
   * scanning from the first SegWit block (481824 on mainnet).
   *
   * @generated from field: uint64 master_key_birthday_timestamp = 1;
   */
  masterKeyBirthdayTimestamp: bigint;

  /**
   * 
   * The fingerprint of the root key (also known as the key with derivation path
   * m/) from which the account public keys were derived from. This may be
   * required by some hardware wallets for proper identification and signing. The
   * bytes must be in big-endian order.
   *
   * @generated from field: bytes master_key_fingerprint = 2;
   */
  masterKeyFingerprint: Uint8Array;

  /**
   * 
   * The list of accounts to import. There _must_ be an account for all of lnd's
   * main key scopes: BIP49/BIP84 (m/49'/0'/0', m/84'/0'/0', note that the
   * coin type is always 0, even for testnet/regtest) and lnd's internal key
   * scope (m/1017'/<coin_type>'/<account>'), where account is the key family as
   * defined in `keychain/derivation.go` (currently indices 0 to 9).
   *
   * @generated from field: repeated lnrpc.WatchOnlyAccount accounts = 3;
   */
  accounts: WatchOnlyAccount[];
};

/**
 * Describes the message lnrpc.WatchOnly.
 * Use `create(WatchOnlySchema)` to create a new message.
 */
export const WatchOnlySchema: GenMessage<WatchOnly> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 4);

/**
 * @generated from message lnrpc.WatchOnlyAccount
 */
export type WatchOnlyAccount = Message<"lnrpc.WatchOnlyAccount"> & {
  /**
   * 
   * Purpose is the first number in the derivation path, must be either 49, 84
   * or 1017.
   *
   * @generated from field: uint32 purpose = 1;
   */
  purpose: number;

  /**
   * 
   * Coin type is the second number in the derivation path, this is _always_ 0
   * for purposes 49 and 84. It only needs to be set to 1 for purpose 1017 on
   * testnet or regtest.
   *
   * @generated from field: uint32 coin_type = 2;
   */
  coinType: number;

  /**
   * 
   * Account is the third number in the derivation path. For purposes 49 and 84
   * at least the default account (index 0) needs to be created but optional
   * additional accounts are allowed. For purpose 1017 there needs to be exactly
   * one account for each of the key families defined in `keychain/derivation.go`
   * (currently indices 0 to 9)
   *
   * @generated from field: uint32 account = 3;
   */
  account: number;

  /**
   * 
   * The extended public key at depth 3 for the given account.
   *
   * @generated from field: string xpub = 4;
   */
  xpub: string;
};

/**
 * Describes the message lnrpc.WatchOnlyAccount.
 * Use `create(WatchOnlyAccountSchema)` to create a new message.
 */
export const WatchOnlyAccountSchema: GenMessage<WatchOnlyAccount> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 5);

/**
 * @generated from message lnrpc.UnlockWalletRequest
 */
export type UnlockWalletRequest = Message<"lnrpc.UnlockWalletRequest"> & {
  /**
   * 
   * wallet_password should be the current valid passphrase for the daemon. This
   * will be required to decrypt on-disk material that the daemon requires to
   * function properly. When using REST, this field must be encoded as base64.
   *
   * @generated from field: bytes wallet_password = 1;
   */
  walletPassword: Uint8Array;

  /**
   * 
   * recovery_window is an optional argument specifying the address lookahead
   * when restoring a wallet seed. The recovery window applies to each
   * individual branch of the BIP44 derivation paths. Supplying a recovery
   * window of zero indicates that no addresses should be recovered, such after
   * the first initialization of the wallet.
   *
   * @generated from field: int32 recovery_window = 2;
   */
  recoveryWindow: number;

  /**
   * 
   * channel_backups is an optional argument that allows clients to recover the
   * settled funds within a set of channels. This should be populated if the
   * user was unable to close out all channels and sweep funds before partial or
   * total data loss occurred. If specified, then after on-chain recovery of
   * funds, lnd begin to carry out the data loss recovery protocol in order to
   * recover the funds in each channel from a remote force closed transaction.
   *
   * @generated from field: lnrpc.ChanBackupSnapshot channel_backups = 3;
   */
  channelBackups?: ChanBackupSnapshot;

  /**
   * 
   * stateless_init is an optional argument instructing the daemon NOT to create
   * any *.macaroon files in its file system.
   *
   * @generated from field: bool stateless_init = 4;
   */
  statelessInit: boolean;
};

/**
 * Describes the message lnrpc.UnlockWalletRequest.
 * Use `create(UnlockWalletRequestSchema)` to create a new message.
 */
export const UnlockWalletRequestSchema: GenMessage<UnlockWalletRequest> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 6);

/**
 * @generated from message lnrpc.UnlockWalletResponse
 */
export type UnlockWalletResponse = Message<"lnrpc.UnlockWalletResponse"> & {
};

/**
 * Describes the message lnrpc.UnlockWalletResponse.
 * Use `create(UnlockWalletResponseSchema)` to create a new message.
 */
export const UnlockWalletResponseSchema: GenMessage<UnlockWalletResponse> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 7);

/**
 * @generated from message lnrpc.ChangePasswordRequest
 */
export type ChangePasswordRequest = Message<"lnrpc.ChangePasswordRequest"> & {
  /**
   * 
   * current_password should be the current valid passphrase used to unlock the
   * daemon. When using REST, this field must be encoded as base64.
   *
   * @generated from field: bytes current_password = 1;
   */
  currentPassword: Uint8Array;

  /**
   * 
   * new_password should be the new passphrase that will be needed to unlock the
   * daemon. When using REST, this field must be encoded as base64.
   *
   * @generated from field: bytes new_password = 2;
   */
  newPassword: Uint8Array;

  /**
   * 
   * stateless_init is an optional argument instructing the daemon NOT to create
   * any *.macaroon files in its filesystem. If this parameter is set, then the
   * admin macaroon returned in the response MUST be stored by the caller of the
   * RPC as otherwise all access to the daemon will be lost!
   *
   * @generated from field: bool stateless_init = 3;
   */
  statelessInit: boolean;

  /**
   * 
   * new_macaroon_root_key is an optional argument instructing the daemon to
   * rotate the macaroon root key when set to true. This will invalidate all
   * previously generated macaroons.
   *
   * @generated from field: bool new_macaroon_root_key = 4;
   */
  newMacaroonRootKey: boolean;
};

/**
 * Describes the message lnrpc.ChangePasswordRequest.
 * Use `create(ChangePasswordRequestSchema)` to create a new message.
 */
export const ChangePasswordRequestSchema: GenMessage<ChangePasswordRequest> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 8);

/**
 * @generated from message lnrpc.ChangePasswordResponse
 */
export type ChangePasswordResponse = Message<"lnrpc.ChangePasswordResponse"> & {
  /**
   * 
   * The binary serialized admin macaroon that can be used to access the daemon
   * after rotating the macaroon root key. If both the stateless_init and
   * new_macaroon_root_key parameter were set to true, this is the ONLY copy of
   * the macaroon that was created from the new root key and MUST be stored
   * safely by the caller. Otherwise a copy of this macaroon is also persisted on
   * disk by the daemon, together with other macaroon files.
   *
   * @generated from field: bytes admin_macaroon = 1;
   */
  adminMacaroon: Uint8Array;
};

/**
 * Describes the message lnrpc.ChangePasswordResponse.
 * Use `create(ChangePasswordResponseSchema)` to create a new message.
 */
export const ChangePasswordResponseSchema: GenMessage<ChangePasswordResponse> = /*@__PURE__*/
  messageDesc(file_walletunlocker, 9);

/**
 * WalletUnlocker is a service that is used to set up a wallet password for
 * lnd at first startup, and unlock a previously set up wallet.
 *
 * @generated from service lnrpc.WalletUnlocker
 */
export const WalletUnlocker: GenService<{
  /**
   * 
   * GenSeed is the first method that should be used to instantiate a new lnd
   * instance. This method allows a caller to generate a new aezeed cipher seed
   * given an optional passphrase. If provided, the passphrase will be necessary
   * to decrypt the cipherseed to expose the internal wallet seed.
   * 
   * Once the cipherseed is obtained and verified by the user, the InitWallet
   * method should be used to commit the newly generated seed, and create the
   * wallet.
   *
   * @generated from rpc lnrpc.WalletUnlocker.GenSeed
   */
  genSeed: {
    methodKind: "unary";
    input: typeof GenSeedRequestSchema;
    output: typeof GenSeedResponseSchema;
  },
  /**
   * 
   * InitWallet is used when lnd is starting up for the first time to fully
   * initialize the daemon and its internal wallet. At the very least a wallet
   * password must be provided. This will be used to encrypt sensitive material
   * on disk.
   * 
   * In the case of a recovery scenario, the user can also specify their aezeed
   * mnemonic and passphrase. If set, then the daemon will use this prior state
   * to initialize its internal wallet.
   * 
   * Alternatively, this can be used along with the GenSeed RPC to obtain a
   * seed, then present it to the user. Once it has been verified by the user,
   * the seed can be fed into this RPC in order to commit the new wallet.
   *
   * @generated from rpc lnrpc.WalletUnlocker.InitWallet
   */
  initWallet: {
    methodKind: "unary";
    input: typeof InitWalletRequestSchema;
    output: typeof InitWalletResponseSchema;
  },
  /**
   * lncli: `unlock`
   * UnlockWallet is used at startup of lnd to provide a password to unlock
   * the wallet database.
   *
   * @generated from rpc lnrpc.WalletUnlocker.UnlockWallet
   */
  unlockWallet: {
    methodKind: "unary";
    input: typeof UnlockWalletRequestSchema;
    output: typeof UnlockWalletResponseSchema;
  },
  /**
   * lncli: `changepassword`
   * ChangePassword changes the password of the encrypted wallet. This will
   * automatically unlock the wallet database if successful.
   *
   * @generated from rpc lnrpc.WalletUnlocker.ChangePassword
   */
  changePassword: {
    methodKind: "unary";
    input: typeof ChangePasswordRequestSchema;
    output: typeof ChangePasswordResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_walletunlocker, 0);



// Merged from stateservice_pb.ts
export const file_stateservice: GenFile = /*@__PURE__*/
  fileDesc("ChJzdGF0ZXNlcnZpY2UucHJvdG8SBWxucnBjIhcKFVN1YnNjcmliZVN0YXRlUmVxdWVzdCI7ChZTdWJzY3JpYmVTdGF0ZVJlc3BvbnNlEiEKBXN0YXRlGAEgASgOMhIubG5ycGMuV2FsbGV0U3RhdGUiEQoPR2V0U3RhdGVSZXF1ZXN0IjUKEEdldFN0YXRlUmVzcG9uc2USIQoFc3RhdGUYASABKA4yEi5sbnJwYy5XYWxsZXRTdGF0ZSpzCgtXYWxsZXRTdGF0ZRIQCgxOT05fRVhJU1RJTkcQABIKCgZMT0NLRUQQARIMCghVTkxPQ0tFRBACEg4KClJQQ19BQ1RJVkUQAxIRCg1TRVJWRVJfQUNUSVZFEAQSFQoQV0FJVElOR19UT19TVEFSVBD/ATKVAQoFU3RhdGUSTwoOU3Vic2NyaWJlU3RhdGUSHC5sbnJwYy5TdWJzY3JpYmVTdGF0ZVJlcXVlc3QaHS5sbnJwYy5TdWJzY3JpYmVTdGF0ZVJlc3BvbnNlMAESOwoIR2V0U3RhdGUSFi5sbnJwYy5HZXRTdGF0ZVJlcXVlc3QaFy5sbnJwYy5HZXRTdGF0ZVJlc3BvbnNlQidaJWdpdGh1Yi5jb20vbGlnaHRuaW5nbmV0d29yay9sbmQvbG5ycGNiBnByb3RvMw");

/**
 * @generated from message lnrpc.SubscribeStateRequest
 */
export type SubscribeStateRequest = Message<"lnrpc.SubscribeStateRequest"> & {
};

/**
 * Describes the message lnrpc.SubscribeStateRequest.
 * Use `create(SubscribeStateRequestSchema)` to create a new message.
 */
export const SubscribeStateRequestSchema: GenMessage<SubscribeStateRequest> = /*@__PURE__*/
  messageDesc(file_stateservice, 0);

/**
 * @generated from message lnrpc.SubscribeStateResponse
 */
export type SubscribeStateResponse = Message<"lnrpc.SubscribeStateResponse"> & {
  /**
   * @generated from field: lnrpc.WalletState state = 1;
   */
  state: WalletState;
};

/**
 * Describes the message lnrpc.SubscribeStateResponse.
 * Use `create(SubscribeStateResponseSchema)` to create a new message.
 */
export const SubscribeStateResponseSchema: GenMessage<SubscribeStateResponse> = /*@__PURE__*/
  messageDesc(file_stateservice, 1);

/**
 * @generated from message lnrpc.GetStateRequest
 */
export type GetStateRequest = Message<"lnrpc.GetStateRequest"> & {
};

/**
 * Describes the message lnrpc.GetStateRequest.
 * Use `create(GetStateRequestSchema)` to create a new message.
 */
export const GetStateRequestSchema: GenMessage<GetStateRequest> = /*@__PURE__*/
  messageDesc(file_stateservice, 2);

/**
 * @generated from message lnrpc.GetStateResponse
 */
export type GetStateResponse = Message<"lnrpc.GetStateResponse"> & {
  /**
   * @generated from field: lnrpc.WalletState state = 1;
   */
  state: WalletState;
};

/**
 * Describes the message lnrpc.GetStateResponse.
 * Use `create(GetStateResponseSchema)` to create a new message.
 */
export const GetStateResponseSchema: GenMessage<GetStateResponse> = /*@__PURE__*/
  messageDesc(file_stateservice, 3);

/**
 * @generated from enum lnrpc.WalletState
 */
export enum WalletState {
  /**
   * NON_EXISTING means that the wallet has not yet been initialized.
   *
   * @generated from enum value: NON_EXISTING = 0;
   */
  NON_EXISTING = 0,

  /**
   * LOCKED means that the wallet is locked and requires a password to unlock.
   *
   * @generated from enum value: LOCKED = 1;
   */
  LOCKED = 1,

  /**
   * UNLOCKED means that the wallet was unlocked successfully, but RPC server
   * isn't ready.
   *
   * @generated from enum value: UNLOCKED = 2;
   */
  UNLOCKED = 2,

  /**
   * RPC_ACTIVE means that the lnd server is active but not fully ready for
   * calls.
   *
   * @generated from enum value: RPC_ACTIVE = 3;
   */
  RPC_ACTIVE = 3,

  /**
   * SERVER_ACTIVE means that the lnd server is ready to accept calls.
   *
   * @generated from enum value: SERVER_ACTIVE = 4;
   */
  SERVER_ACTIVE = 4,

  /**
   * WAITING_TO_START means that node is waiting to become the leader in a
   * cluster and is not started yet.
   *
   * @generated from enum value: WAITING_TO_START = 255;
   */
  WAITING_TO_START = 255,
}

/**
 * Describes the enum lnrpc.WalletState.
 */
export const WalletStateSchema: GenEnum<WalletState> = /*@__PURE__*/
  enumDesc(file_stateservice, 0);

/**
 * State service is a always running service that exposes the current state of
 * the wallet and RPC server.
 *
 * @generated from service lnrpc.State
 */
export const State: GenService<{
  /**
   * SubscribeState subscribes to the state of the wallet. The current wallet
   * state will always be delivered immediately.
   *
   * @generated from rpc lnrpc.State.SubscribeState
   */
  subscribeState: {
    methodKind: "server_streaming";
    input: typeof SubscribeStateRequestSchema;
    output: typeof SubscribeStateResponseSchema;
  },
  /**
   * GetState returns the current wallet state without streaming further
   * changes.
   *
   * @generated from rpc lnrpc.State.GetState
   */
  getState: {
    methodKind: "unary";
    input: typeof GetStateRequestSchema;
    output: typeof GetStateResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_stateservice, 0);